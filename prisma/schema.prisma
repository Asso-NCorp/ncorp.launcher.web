generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model account {
  id                    String    @id @db.VarChar(36)
  accountId             String    @db.Text
  providerId            String    @db.Text
  userId                String    @db.VarChar(36)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime? @db.DateTime(0)
  refreshTokenExpiresAt DateTime? @db.DateTime(0)
  scope                 String?   @db.Text
  password              String?   @db.Text
  createdAt             DateTime  @db.DateTime(0)
  updatedAt             DateTime  @db.DateTime(0)
}

model invitation {
  id             String   @id @db.VarChar(36)
  organizationId String   @db.VarChar(36)
  email          String   @db.Text
  role           String?  @db.Text
  status         String   @db.Text
  expiresAt      DateTime @db.DateTime(0)
  inviterId      String   @db.VarChar(36)
}

model jwks {
  id         String   @id @db.VarChar(36)
  publicKey  String   @db.Text
  privateKey String   @db.Text
  createdAt  DateTime @db.DateTime(0)
}

model member {
  id             String   @id @db.VarChar(36)
  organizationId String   @db.VarChar(36)
  userId         String   @db.VarChar(36)
  role           String   @db.Text
  createdAt      DateTime @db.DateTime(0)
}

model organization {
  id        String   @id @db.VarChar(36)
  name      String   @db.Text
  slug      String   @unique(map: "slug") @db.VarChar(255)
  logo      String?  @db.Text
  createdAt DateTime @db.DateTime(0)
  metadata  String?  @db.Text
}

model session {
  id                   String   @id @db.VarChar(36)
  expiresAt            DateTime @db.DateTime(0)
  token                String   @unique(map: "token") @db.VarChar(255)
  createdAt            DateTime @db.DateTime(0)
  updatedAt            DateTime @db.DateTime(0)
  ipAddress            String?  @db.Text
  userAgent            String?  @db.Text
  userId               String   @db.VarChar(36)
  impersonatedBy       String?  @db.Text
  activeOrganizationId String?  @db.Text
}

model user {
  id              String         @id @db.VarChar(36)
  name            String         @db.Text
  email           String         @unique(map: "email") @db.VarChar(255)
  emailVerified   Boolean
  image           String?        @db.Text
  createdAt       DateTime       @db.DateTime(0)
  updatedAt       DateTime       @db.DateTime(0)
  username        String?        @unique(map: "username") @db.VarChar(255)
  role            String         @default("user") @db.VarChar(100)
  banned          Boolean?
  banReason       String?        @db.Text
  banExpires      DateTime?      @db.DateTime(0)
  displayUsername String?        @db.Text
  lastLogin       DateTime?      @db.DateTime(0)
  user_settings   user_settings?
  game_session    game_session[]
  event_created   event[]        @relation("event_created_by")
  event_updated   event[]        @relation("event_updated_by")
  gamesCreated    game[]         @relation("GameCreatedBy")
  gamesUpdated    game[]         @relation("GameUpdatedBy")

  // Relations chat
  guild_memberships   guild_member[]
  room_participations room_participant[]
  messages            message[]
  message_reads       message_read[]
  message_reactions   message_reaction[]
  channel_memberships channel_member[]
  guild               guild[]
  room                room[]
  room_view           room_view[]
}

model verification {
  id         String    @id @db.VarChar(36)
  identifier String    @db.Text
  value      String    @db.Text
  expiresAt  DateTime  @db.DateTime(0)
  createdAt  DateTime? @db.DateTime(0)
  updatedAt  DateTime? @db.DateTime(0)
}

model sidelink {
  id        Int      @id @default(autoincrement())
  name      String   @db.VarChar(100)
  url       String   @db.VarChar(100)
  hidden    Boolean  @default(false)
  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @db.DateTime(0)
  createdBy String   @db.VarChar(36)
  updatedBy String   @db.VarChar(36)

  @@index([createdBy], map: "sidelink_user_FK")
  @@index([updatedBy], map: "sidelink_user_FK_1")
}

model username_file_config {
  id          Int     @id @default(autoincrement()) @db.UnsignedInt
  folder_slug String? @db.VarChar(100)
  config_type String? @db.VarChar(100)
  path        String? @db.VarChar(200)
  variable    String? @db.VarChar(200)
}

enum chat_private_message_status {
  sent
  delivered
  read
}

model user_settings {
  id              Int    @id @default(autoincrement())
  user_id         String @unique @db.VarChar(36)
  local_games_dir String @db.Text

  user user @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model game_session {
  id            String    @id @default(uuid()) @db.Char(36)
  user_id       String    @db.VarChar(36)
  game_slug     String    @db.VarChar(36)
  start_time    DateTime  @db.DateTime(0)
  end_time      DateTime? @db.DateTime(0)
  total_seconds Int?      @db.Int

  user user @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model event {
  id          String   @id @default(uuid()) @db.Char(36)
  name        String   @db.VarChar(255)
  description String?  @db.Text
  location    String?  @db.VarChar(255)
  url         String?  @db.VarChar(500)
  image_url   String?  @db.Text
  start_time  DateTime @db.DateTime(0)
  end_time    DateTime @db.DateTime(0)
  created_at  DateTime @default(now()) @db.DateTime(0)
  updated_at  DateTime @default(now()) @updatedAt @db.DateTime(0)
  created_by  String   @db.VarChar(36)
  updated_by  String   @db.VarChar(36)

  creator user @relation("event_created_by", fields: [created_by], references: [id], onDelete: NoAction, onUpdate: NoAction)
  updater user @relation("event_updated_by", fields: [updated_by], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([created_by], map: "event_created_by_FK")
  @@index([updated_by], map: "event_updated_by_FK")
  @@index([start_time], map: "event_start_time_IDX")
  @@index([end_time], map: "event_end_time_IDX")
}

model global_settings {
  id         Int      @id @default(autoincrement())
  key        String   @unique @db.VarChar(100)
  value      String?  @db.Text
  created_at DateTime @default(now()) @db.DateTime(0)
  updated_at DateTime @default(now()) @updatedAt @db.DateTime(0)
  created_by String   @db.VarChar(36)
  updated_by String   @db.VarChar(36)

  @@index([created_by], map: "global_settings_user_FK")
  @@index([updated_by], map: "global_settings_user_FK_1")
}

model game {
  id                String    @id @default(uuid()) @db.Char(36)
  size_gb           Float     @db.Double
  title             String    @db.VarChar(255)
  folder_slug       String    @unique @db.VarChar(100)
  version           String?   @db.VarChar(50)
  genres            String    @db.Text
  platforms         String?   @db.Text
  game_modes        String    @db.Text
  is_featured       Boolean   @default(false)
  date_updated      DateTime? @db.Date
  date_added        DateTime? @db.Date
  editor_name       String?   @db.VarChar(255)
  main_process_name String?   @db.VarChar(255)
  cover             String?   @db.Text
  logo              String?   @db.Text
  screenshots       String    @db.Text
  description       String?   @db.Text
  start_command     String?   @db.Text
  max_players       Int       @db.Int
  use_notifications Boolean   @default(true)
  created_at        DateTime  @default(now()) @db.DateTime(0)
  updated_at        DateTime  @default(now()) @updatedAt @db.DateTime(0)

  // FK (obligatoires ici; mets ? si nullable)
  created_by String @db.VarChar(36)
  updated_by String @db.VarChar(36)

  // Relations
  createdBy user @relation("GameCreatedBy", fields: [created_by], references: [id], onDelete: Restrict, onUpdate: Cascade)
  updatedBy user @relation("GameUpdatedBy", fields: [updated_by], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@index([created_by], map: "game_user_created_FK")
  @@index([updated_by], map: "game_user_updated_FK")
  @@index([folder_slug], map: "game_folder_slug_IDX")
}

model role {
  name                          String  @id @unique @db.VarChar(100)
  avatar_decoration_static      String? @db.Text
  avatar_decoration_animated    String? @db.Text
  nameplate_decoration_static   String? @db.Text
  nameplate_decoration_animated String? @db.Text
}

model user_game {
  user_id      String    @db.VarChar(36)
  game_slug    String    @db.VarChar(100)
  installed_at DateTime? @db.DateTime(0)

  @@id([user_id, game_slug])
  @@index([user_id], map: "user_game_user_id_FK")
  @@index([game_slug], map: "user_game_game_slug_FK")
  @@index([game_slug, installed_at], map: "user_game_slug_installed_at_idx")
}

/// ====== ENAMS ======
enum room_type {
  DM
  GROUP
  GUILD_CHANNEL
}

enum channel_type {
  TEXT
  VOICE
  CATEGORY
}

enum message_type {
  TEXT
  SYSTEM
  EVENT // join/leave/rename, etc.
}

/// ====== GUILDS ======
model guild {
  id        String   @id @default(uuid()) @db.Char(36)
  name      String   @db.VarChar(100)
  slug      String   @unique @db.VarChar(255)
  icon      String?  @db.Text
  ownerId   String   @db.VarChar(36) // user id -> pas de default
  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  owner    user           @relation(fields: [ownerId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  members  guild_member[]
  channels channel[]
  room     room[]

  @@index([ownerId], map: "guild_owner_FK")
}

/// ====== GUILD MEMBERS ======
model guild_member {
  id       String   @id @default(uuid()) @db.Char(36)
  guildId  String   @db.Char(36)
  userId   String   @db.VarChar(36) // user id
  nickname String?  @db.VarChar(100)
  roles    String?  @db.Text
  joinedAt DateTime @default(now()) @db.DateTime(0)

  guild guild @relation(fields: [guildId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user  user  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([guildId, userId], map: "guild_member_unique")
  @@index([guildId], map: "guild_member_guild_idx")
  @@index([userId], map: "guild_member_user_idx")
}

/// ====== CHANNELS ======
model channel {
  id        String       @id @default(uuid()) @db.Char(36)
  guildId   String       @db.Char(36)
  name      String       @db.VarChar(100)
  slug      String       @db.VarChar(255)
  type      channel_type @default(TEXT)
  topic     String?      @db.VarChar(500)
  position  Int          @default(0)
  isPrivate Boolean      @default(false)
  parentId  String?      @db.Char(36)
  createdAt DateTime     @default(now()) @db.DateTime(0)
  updatedAt DateTime     @default(now()) @updatedAt @db.DateTime(0)

  guild    guild            @relation(fields: [guildId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  parent   channel?         @relation("ChannelToChildren", fields: [parentId], references: [id])
  children channel[]        @relation("ChannelToChildren")
  room     room?
  members  channel_member[]

  @@unique([guildId, slug], map: "channel_slug_per_guild")
  @@index([guildId], map: "channel_guild_idx")
  @@index([parentId], map: "channel_parent_idx")
}

/// Membres autorisés d’un channel privé
model channel_member {
  channelId String   @db.Char(36)
  userId    String   @db.VarChar(36) // user id
  addedAt   DateTime @default(now()) @db.DateTime(0)

  channel channel @relation(fields: [channelId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user    user    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([channelId, userId])
  @@index([userId], map: "channel_member_user_idx")
}

/// ====== ROOMS ======
model room {
  id            String    @id @default(uuid()) @db.Char(36)
  type          room_type
  name          String?   @db.VarChar(255)
  ownerId       String?   @db.VarChar(36) // user id
  guildId       String?   @db.Char(36)
  channelId     String?   @db.Char(36)
  lastMessageAt DateTime? @db.DateTime(0)
  createdAt     DateTime  @default(now()) @db.DateTime(0)
  updatedAt     DateTime  @default(now()) @updatedAt @db.DateTime(0)

  owner          user?              @relation(fields: [ownerId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  guild          guild?             @relation(fields: [guildId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  channel        channel?           @relation(fields: [channelId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participants   room_participant[]
  messages       message[]
  dm_pair_unique dm_pair_unique[]
  room_view      room_view[]

  @@unique([channelId], map: "room_unique_channel")
  @@index([type], map: "room_type_idx")
  @@index([guildId], map: "room_guild_idx")
  @@index([lastMessageAt], map: "room_lastMessageAt_idx")
}

/// Participants
model room_participant {
  roomId   String   @db.Char(36)
  userId   String   @db.VarChar(36) // user id
  joinedAt DateTime @default(now()) @db.DateTime(0)
  isMuted  Boolean  @default(false)
  isPinned Boolean  @default(false)

  room room @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user user @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([roomId, userId])
  @@index([userId], map: "room_participant_user_idx")
}

/// DMs (paire unique)
model dm_pair_unique {
  id     String @id @default(uuid()) @db.Char(36)
  userA  String @db.VarChar(36) // user id
  userB  String @db.VarChar(36) // user id
  roomId String @db.Char(36)

  room room @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([userA, userB], map: "dm_pair_users_unique")
  @@index([roomId], map: "dm_pair_room_idx")
}

/// ====== MESSAGES ======
model message {
  id          String       @id @default(uuid()) @db.Char(36)
  roomId      String       @db.Char(36)
  authorId    String       @db.VarChar(36) // user id
  type        message_type @default(TEXT)
  content     String?      @db.Text
  attachments String?      @db.Text
  createdAt   DateTime     @default(now()) @db.DateTime(0)
  editedAt    DateTime?    @db.DateTime(0)
  deletedAt   DateTime?    @db.DateTime(0)

  room      room               @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  author    user               @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  reads     message_read[]
  reactions message_reaction[]

  @@index([roomId, createdAt, id], map: "message_room_created_id_idx")
  @@index([authorId, createdAt], map: "message_author_created_idx")
}

/// Accusés de lecture
model message_read {
  messageId String   @db.Char(36)
  userId    String   @db.VarChar(36) // user id
  readAt    DateTime @default(now()) @db.DateTime(0)

  message message @relation(fields: [messageId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user    user    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([messageId, userId])
  @@index([userId, readAt], map: "message_read_user_idx")
}

/// Réactions
model message_reaction {
  messageId String   @db.Char(36)
  userId    String   @db.VarChar(36) // user id
  emoji     String   @db.VarChar(64)
  createdAt DateTime @default(now()) @db.DateTime(0)

  message message @relation(fields: [messageId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user    user    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([messageId, userId, emoji])
  @@index([userId], map: "message_reaction_user_idx")
  @@index([messageId, emoji], map: "IX_message_emoji")
}

/// Vues de salon
model room_view {
  roomId     String   @db.Char(36)
  userId     String   @db.VarChar(36) // user id
  lastSeenAt DateTime @default(now()) @db.DateTime(0)

  room room @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user user @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([roomId, userId])
  @@index([userId, lastSeenAt], map: "room_view_user_idx")
}


/**
 * Rappels psq j'ai pas de mémoire :
 * - Tu modifies schema.prisma
 * - Tu fais npx prisma migrate dev --name ajout_model
 * - Prisma applique la migration + met à jour _prisma_migrations
 * - Tu fais npx prisma generate si tu veux rafraîchir le client TypeScript (en général migrate dev le fait déjà automatiquement).
 * Une fois en prod : transférer les nouvelles migrations .sql dans le dossier prisma/migrations sur le serveur
 * Appliquer les migrations : npx prisma migrate deploy
 * Regénérer le client : npx prisma generate
 * Mais tout ça se fait automatiquement via le CI/CD .github/workflows/main.yml
 */
