
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model account
 * 
 */
export type account = $Result.DefaultSelection<Prisma.$accountPayload>
/**
 * Model invitation
 * 
 */
export type invitation = $Result.DefaultSelection<Prisma.$invitationPayload>
/**
 * Model jwks
 * 
 */
export type jwks = $Result.DefaultSelection<Prisma.$jwksPayload>
/**
 * Model member
 * 
 */
export type member = $Result.DefaultSelection<Prisma.$memberPayload>
/**
 * Model organization
 * 
 */
export type organization = $Result.DefaultSelection<Prisma.$organizationPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model verification
 * 
 */
export type verification = $Result.DefaultSelection<Prisma.$verificationPayload>
/**
 * Model sidelink
 * 
 */
export type sidelink = $Result.DefaultSelection<Prisma.$sidelinkPayload>
/**
 * Model username_file_config
 * 
 */
export type username_file_config = $Result.DefaultSelection<Prisma.$username_file_configPayload>
/**
 * Model user_settings
 * 
 */
export type user_settings = $Result.DefaultSelection<Prisma.$user_settingsPayload>
/**
 * Model game_session
 * 
 */
export type game_session = $Result.DefaultSelection<Prisma.$game_sessionPayload>
/**
 * Model event
 * 
 */
export type event = $Result.DefaultSelection<Prisma.$eventPayload>
/**
 * Model global_settings
 * 
 */
export type global_settings = $Result.DefaultSelection<Prisma.$global_settingsPayload>
/**
 * Model game
 * 
 */
export type game = $Result.DefaultSelection<Prisma.$gamePayload>
/**
 * Model game_server
 * 
 */
export type game_server = $Result.DefaultSelection<Prisma.$game_serverPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model user_game
 * 
 */
export type user_game = $Result.DefaultSelection<Prisma.$user_gamePayload>
/**
 * Model user_game_favorite
 * 
 */
export type user_game_favorite = $Result.DefaultSelection<Prisma.$user_game_favoritePayload>
/**
 * Model faq
 * ====== FAQ ======
 */
export type faq = $Result.DefaultSelection<Prisma.$faqPayload>
/**
 * Model guild
 * ====== GUILDS ======
 */
export type guild = $Result.DefaultSelection<Prisma.$guildPayload>
/**
 * Model guild_member
 * ====== GUILD MEMBERS ======
 */
export type guild_member = $Result.DefaultSelection<Prisma.$guild_memberPayload>
/**
 * Model channel
 * ====== CHANNELS ======
 */
export type channel = $Result.DefaultSelection<Prisma.$channelPayload>
/**
 * Model channel_member
 * Membres autorisés d’un channel privé
 */
export type channel_member = $Result.DefaultSelection<Prisma.$channel_memberPayload>
/**
 * Model room
 * ====== ROOMS ======
 */
export type room = $Result.DefaultSelection<Prisma.$roomPayload>
/**
 * Model room_participant
 * Participants
 */
export type room_participant = $Result.DefaultSelection<Prisma.$room_participantPayload>
/**
 * Model dm_pair_unique
 * DMs (paire unique)
 */
export type dm_pair_unique = $Result.DefaultSelection<Prisma.$dm_pair_uniquePayload>
/**
 * Model message
 * ====== MESSAGES ======
 */
export type message = $Result.DefaultSelection<Prisma.$messagePayload>
/**
 * Model message_read
 * Accusés de lecture
 */
export type message_read = $Result.DefaultSelection<Prisma.$message_readPayload>
/**
 * Model message_reaction
 * Réactions
 */
export type message_reaction = $Result.DefaultSelection<Prisma.$message_reactionPayload>
/**
 * Model room_view
 * Vues de salon
 */
export type room_view = $Result.DefaultSelection<Prisma.$room_viewPayload>
/**
 * Model EFMigrationsHistory
 * 
 */
export type EFMigrationsHistory = $Result.DefaultSelection<Prisma.$EFMigrationsHistoryPayload>
/**
 * Model edition
 * ====== TABLE PLAN MANAGER ======
 * Editions (events) that can contain multiple rooms with table plans
 */
export type edition = $Result.DefaultSelection<Prisma.$editionPayload>
/**
 * Model edition_room
 * Rooms within an edition (e.g., "Main Hall", "VIP Section")
 */
export type edition_room = $Result.DefaultSelection<Prisma.$edition_roomPayload>
/**
 * Model table
 * Tables within a room (placed on 2D plane with grid snapping)
 */
export type table = $Result.DefaultSelection<Prisma.$tablePayload>
/**
 * Model table_seat
 * Seats at a table with optional user assignments
 */
export type table_seat = $Result.DefaultSelection<Prisma.$table_seatPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const room_type: {
  DM: 'DM',
  GROUP: 'GROUP',
  GUILD_CHANNEL: 'GUILD_CHANNEL'
};

export type room_type = (typeof room_type)[keyof typeof room_type]


export const channel_type: {
  TEXT: 'TEXT',
  VOICE: 'VOICE',
  CATEGORY: 'CATEGORY'
};

export type channel_type = (typeof channel_type)[keyof typeof channel_type]


export const message_type: {
  TEXT: 'TEXT',
  SYSTEM: 'SYSTEM',
  EVENT: 'EVENT'
};

export type message_type = (typeof message_type)[keyof typeof message_type]

}

export type room_type = $Enums.room_type

export const room_type: typeof $Enums.room_type

export type channel_type = $Enums.channel_type

export const channel_type: typeof $Enums.channel_type

export type message_type = $Enums.message_type

export const message_type: typeof $Enums.message_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.accountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.invitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jwks`: Exposes CRUD operations for the **jwks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jwks
    * const jwks = await prisma.jwks.findMany()
    * ```
    */
  get jwks(): Prisma.jwksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.organizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.verificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sidelink`: Exposes CRUD operations for the **sidelink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sidelinks
    * const sidelinks = await prisma.sidelink.findMany()
    * ```
    */
  get sidelink(): Prisma.sidelinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.username_file_config`: Exposes CRUD operations for the **username_file_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Username_file_configs
    * const username_file_configs = await prisma.username_file_config.findMany()
    * ```
    */
  get username_file_config(): Prisma.username_file_configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_settings`: Exposes CRUD operations for the **user_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_settings
    * const user_settings = await prisma.user_settings.findMany()
    * ```
    */
  get user_settings(): Prisma.user_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game_session`: Exposes CRUD operations for the **game_session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_sessions
    * const game_sessions = await prisma.game_session.findMany()
    * ```
    */
  get game_session(): Prisma.game_sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.eventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.global_settings`: Exposes CRUD operations for the **global_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Global_settings
    * const global_settings = await prisma.global_settings.findMany()
    * ```
    */
  get global_settings(): Prisma.global_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game_server`: Exposes CRUD operations for the **game_server** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_servers
    * const game_servers = await prisma.game_server.findMany()
    * ```
    */
  get game_server(): Prisma.game_serverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_game`: Exposes CRUD operations for the **user_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_games
    * const user_games = await prisma.user_game.findMany()
    * ```
    */
  get user_game(): Prisma.user_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_game_favorite`: Exposes CRUD operations for the **user_game_favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_game_favorites
    * const user_game_favorites = await prisma.user_game_favorite.findMany()
    * ```
    */
  get user_game_favorite(): Prisma.user_game_favoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.faqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guild`: Exposes CRUD operations for the **guild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guild.findMany()
    * ```
    */
  get guild(): Prisma.guildDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guild_member`: Exposes CRUD operations for the **guild_member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guild_members
    * const guild_members = await prisma.guild_member.findMany()
    * ```
    */
  get guild_member(): Prisma.guild_memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.channelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channel_member`: Exposes CRUD operations for the **channel_member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channel_members
    * const channel_members = await prisma.channel_member.findMany()
    * ```
    */
  get channel_member(): Prisma.channel_memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room_participant`: Exposes CRUD operations for the **room_participant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Room_participants
    * const room_participants = await prisma.room_participant.findMany()
    * ```
    */
  get room_participant(): Prisma.room_participantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dm_pair_unique`: Exposes CRUD operations for the **dm_pair_unique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dm_pair_uniques
    * const dm_pair_uniques = await prisma.dm_pair_unique.findMany()
    * ```
    */
  get dm_pair_unique(): Prisma.dm_pair_uniqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message_read`: Exposes CRUD operations for the **message_read** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Message_reads
    * const message_reads = await prisma.message_read.findMany()
    * ```
    */
  get message_read(): Prisma.message_readDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message_reaction`: Exposes CRUD operations for the **message_reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Message_reactions
    * const message_reactions = await prisma.message_reaction.findMany()
    * ```
    */
  get message_reaction(): Prisma.message_reactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room_view`: Exposes CRUD operations for the **room_view** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Room_views
    * const room_views = await prisma.room_view.findMany()
    * ```
    */
  get room_view(): Prisma.room_viewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eFMigrationsHistory`: Exposes CRUD operations for the **EFMigrationsHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EFMigrationsHistories
    * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
    * ```
    */
  get eFMigrationsHistory(): Prisma.EFMigrationsHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edition`: Exposes CRUD operations for the **edition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Editions
    * const editions = await prisma.edition.findMany()
    * ```
    */
  get edition(): Prisma.editionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edition_room`: Exposes CRUD operations for the **edition_room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Edition_rooms
    * const edition_rooms = await prisma.edition_room.findMany()
    * ```
    */
  get edition_room(): Prisma.edition_roomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.tableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table_seat`: Exposes CRUD operations for the **table_seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Table_seats
    * const table_seats = await prisma.table_seat.findMany()
    * ```
    */
  get table_seat(): Prisma.table_seatDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.1
   * Query Engine version: f09f2815f091dbba658cdcd2264306d88bb5bda6
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    account: 'account',
    invitation: 'invitation',
    jwks: 'jwks',
    member: 'member',
    organization: 'organization',
    session: 'session',
    user: 'user',
    verification: 'verification',
    sidelink: 'sidelink',
    username_file_config: 'username_file_config',
    user_settings: 'user_settings',
    game_session: 'game_session',
    event: 'event',
    global_settings: 'global_settings',
    game: 'game',
    game_server: 'game_server',
    role: 'role',
    user_game: 'user_game',
    user_game_favorite: 'user_game_favorite',
    faq: 'faq',
    guild: 'guild',
    guild_member: 'guild_member',
    channel: 'channel',
    channel_member: 'channel_member',
    room: 'room',
    room_participant: 'room_participant',
    dm_pair_unique: 'dm_pair_unique',
    message: 'message',
    message_read: 'message_read',
    message_reaction: 'message_reaction',
    room_view: 'room_view',
    EFMigrationsHistory: 'EFMigrationsHistory',
    edition: 'edition',
    edition_room: 'edition_room',
    table: 'table',
    table_seat: 'table_seat'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "invitation" | "jwks" | "member" | "organization" | "session" | "user" | "verification" | "sidelink" | "username_file_config" | "user_settings" | "game_session" | "event" | "global_settings" | "game" | "game_server" | "role" | "user_game" | "user_game_favorite" | "faq" | "guild" | "guild_member" | "channel" | "channel_member" | "room" | "room_participant" | "dm_pair_unique" | "message" | "message_read" | "message_reaction" | "room_view" | "eFMigrationsHistory" | "edition" | "edition_room" | "table" | "table_seat"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      account: {
        payload: Prisma.$accountPayload<ExtArgs>
        fields: Prisma.accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findFirst: {
            args: Prisma.accountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          findMany: {
            args: Prisma.accountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>[]
          }
          create: {
            args: Prisma.accountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          createMany: {
            args: Prisma.accountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          update: {
            args: Prisma.accountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          deleteMany: {
            args: Prisma.accountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.accountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      invitation: {
        payload: Prisma.$invitationPayload<ExtArgs>
        fields: Prisma.invitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>
          }
          findFirst: {
            args: Prisma.invitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>
          }
          findMany: {
            args: Prisma.invitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>[]
          }
          create: {
            args: Prisma.invitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>
          }
          createMany: {
            args: Prisma.invitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.invitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>
          }
          update: {
            args: Prisma.invitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>
          }
          deleteMany: {
            args: Prisma.invitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.invitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.invitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.invitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      jwks: {
        payload: Prisma.$jwksPayload<ExtArgs>
        fields: Prisma.jwksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jwksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jwksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>
          }
          findFirst: {
            args: Prisma.jwksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jwksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>
          }
          findMany: {
            args: Prisma.jwksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>[]
          }
          create: {
            args: Prisma.jwksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>
          }
          createMany: {
            args: Prisma.jwksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jwksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>
          }
          update: {
            args: Prisma.jwksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>
          }
          deleteMany: {
            args: Prisma.jwksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jwksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jwksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jwksPayload>
          }
          aggregate: {
            args: Prisma.JwksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJwks>
          }
          groupBy: {
            args: Prisma.jwksGroupByArgs<ExtArgs>
            result: $Utils.Optional<JwksGroupByOutputType>[]
          }
          count: {
            args: Prisma.jwksCountArgs<ExtArgs>
            result: $Utils.Optional<JwksCountAggregateOutputType> | number
          }
        }
      }
      member: {
        payload: Prisma.$memberPayload<ExtArgs>
        fields: Prisma.memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          findFirst: {
            args: Prisma.memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          findMany: {
            args: Prisma.memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>[]
          }
          create: {
            args: Prisma.memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          createMany: {
            args: Prisma.memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          update: {
            args: Prisma.memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          deleteMany: {
            args: Prisma.memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.memberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      organization: {
        payload: Prisma.$organizationPayload<ExtArgs>
        fields: Prisma.organizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          findFirst: {
            args: Prisma.organizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          findMany: {
            args: Prisma.organizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>[]
          }
          create: {
            args: Prisma.organizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          createMany: {
            args: Prisma.organizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.organizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          update: {
            args: Prisma.organizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          deleteMany: {
            args: Prisma.organizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.organizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.organizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.organizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.organizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      verification: {
        payload: Prisma.$verificationPayload<ExtArgs>
        fields: Prisma.verificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.verificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.verificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          findFirst: {
            args: Prisma.verificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.verificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          findMany: {
            args: Prisma.verificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>[]
          }
          create: {
            args: Prisma.verificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          createMany: {
            args: Prisma.verificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.verificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          update: {
            args: Prisma.verificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          deleteMany: {
            args: Prisma.verificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.verificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.verificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.verificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.verificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      sidelink: {
        payload: Prisma.$sidelinkPayload<ExtArgs>
        fields: Prisma.sidelinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sidelinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sidelinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>
          }
          findFirst: {
            args: Prisma.sidelinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sidelinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>
          }
          findMany: {
            args: Prisma.sidelinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>[]
          }
          create: {
            args: Prisma.sidelinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>
          }
          createMany: {
            args: Prisma.sidelinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sidelinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>
          }
          update: {
            args: Prisma.sidelinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>
          }
          deleteMany: {
            args: Prisma.sidelinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sidelinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sidelinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sidelinkPayload>
          }
          aggregate: {
            args: Prisma.SidelinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSidelink>
          }
          groupBy: {
            args: Prisma.sidelinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SidelinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.sidelinkCountArgs<ExtArgs>
            result: $Utils.Optional<SidelinkCountAggregateOutputType> | number
          }
        }
      }
      username_file_config: {
        payload: Prisma.$username_file_configPayload<ExtArgs>
        fields: Prisma.username_file_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.username_file_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.username_file_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>
          }
          findFirst: {
            args: Prisma.username_file_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.username_file_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>
          }
          findMany: {
            args: Prisma.username_file_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>[]
          }
          create: {
            args: Prisma.username_file_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>
          }
          createMany: {
            args: Prisma.username_file_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.username_file_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>
          }
          update: {
            args: Prisma.username_file_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>
          }
          deleteMany: {
            args: Prisma.username_file_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.username_file_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.username_file_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$username_file_configPayload>
          }
          aggregate: {
            args: Prisma.Username_file_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsername_file_config>
          }
          groupBy: {
            args: Prisma.username_file_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Username_file_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.username_file_configCountArgs<ExtArgs>
            result: $Utils.Optional<Username_file_configCountAggregateOutputType> | number
          }
        }
      }
      user_settings: {
        payload: Prisma.$user_settingsPayload<ExtArgs>
        fields: Prisma.user_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>
          }
          findFirst: {
            args: Prisma.user_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>
          }
          findMany: {
            args: Prisma.user_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>[]
          }
          create: {
            args: Prisma.user_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>
          }
          createMany: {
            args: Prisma.user_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>
          }
          update: {
            args: Prisma.user_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>
          }
          deleteMany: {
            args: Prisma.user_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_settingsPayload>
          }
          aggregate: {
            args: Prisma.User_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_settings>
          }
          groupBy: {
            args: Prisma.user_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<User_settingsCountAggregateOutputType> | number
          }
        }
      }
      game_session: {
        payload: Prisma.$game_sessionPayload<ExtArgs>
        fields: Prisma.game_sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>
          }
          findFirst: {
            args: Prisma.game_sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>
          }
          findMany: {
            args: Prisma.game_sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>[]
          }
          create: {
            args: Prisma.game_sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>
          }
          createMany: {
            args: Prisma.game_sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.game_sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>
          }
          update: {
            args: Prisma.game_sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>
          }
          deleteMany: {
            args: Prisma.game_sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.game_sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_sessionPayload>
          }
          aggregate: {
            args: Prisma.Game_sessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_session>
          }
          groupBy: {
            args: Prisma.game_sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_sessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_sessionCountArgs<ExtArgs>
            result: $Utils.Optional<Game_sessionCountAggregateOutputType> | number
          }
        }
      }
      event: {
        payload: Prisma.$eventPayload<ExtArgs>
        fields: Prisma.eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findFirst: {
            args: Prisma.eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findMany: {
            args: Prisma.eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          create: {
            args: Prisma.eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          createMany: {
            args: Prisma.eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          update: {
            args: Prisma.eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          deleteMany: {
            args: Prisma.eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      global_settings: {
        payload: Prisma.$global_settingsPayload<ExtArgs>
        fields: Prisma.global_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.global_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.global_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>
          }
          findFirst: {
            args: Prisma.global_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.global_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>
          }
          findMany: {
            args: Prisma.global_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>[]
          }
          create: {
            args: Prisma.global_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>
          }
          createMany: {
            args: Prisma.global_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.global_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>
          }
          update: {
            args: Prisma.global_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>
          }
          deleteMany: {
            args: Prisma.global_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.global_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.global_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$global_settingsPayload>
          }
          aggregate: {
            args: Prisma.Global_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobal_settings>
          }
          groupBy: {
            args: Prisma.global_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Global_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.global_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Global_settingsCountAggregateOutputType> | number
          }
        }
      }
      game: {
        payload: Prisma.$gamePayload<ExtArgs>
        fields: Prisma.gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          findFirst: {
            args: Prisma.gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          findMany: {
            args: Prisma.gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>[]
          }
          create: {
            args: Prisma.gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          createMany: {
            args: Prisma.gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          update: {
            args: Prisma.gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          deleteMany: {
            args: Prisma.gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.gameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      game_server: {
        payload: Prisma.$game_serverPayload<ExtArgs>
        fields: Prisma.game_serverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_serverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_serverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>
          }
          findFirst: {
            args: Prisma.game_serverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_serverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>
          }
          findMany: {
            args: Prisma.game_serverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>[]
          }
          create: {
            args: Prisma.game_serverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>
          }
          createMany: {
            args: Prisma.game_serverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.game_serverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>
          }
          update: {
            args: Prisma.game_serverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>
          }
          deleteMany: {
            args: Prisma.game_serverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_serverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.game_serverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_serverPayload>
          }
          aggregate: {
            args: Prisma.Game_serverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_server>
          }
          groupBy: {
            args: Prisma.game_serverGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_serverGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_serverCountArgs<ExtArgs>
            result: $Utils.Optional<Game_serverCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      user_game: {
        payload: Prisma.$user_gamePayload<ExtArgs>
        fields: Prisma.user_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>
          }
          findFirst: {
            args: Prisma.user_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>
          }
          findMany: {
            args: Prisma.user_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>[]
          }
          create: {
            args: Prisma.user_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>
          }
          createMany: {
            args: Prisma.user_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>
          }
          update: {
            args: Prisma.user_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>
          }
          deleteMany: {
            args: Prisma.user_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_gamePayload>
          }
          aggregate: {
            args: Prisma.User_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_game>
          }
          groupBy: {
            args: Prisma.user_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_gameCountArgs<ExtArgs>
            result: $Utils.Optional<User_gameCountAggregateOutputType> | number
          }
        }
      }
      user_game_favorite: {
        payload: Prisma.$user_game_favoritePayload<ExtArgs>
        fields: Prisma.user_game_favoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_game_favoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_game_favoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>
          }
          findFirst: {
            args: Prisma.user_game_favoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_game_favoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>
          }
          findMany: {
            args: Prisma.user_game_favoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>[]
          }
          create: {
            args: Prisma.user_game_favoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>
          }
          createMany: {
            args: Prisma.user_game_favoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_game_favoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>
          }
          update: {
            args: Prisma.user_game_favoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>
          }
          deleteMany: {
            args: Prisma.user_game_favoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_game_favoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_game_favoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_game_favoritePayload>
          }
          aggregate: {
            args: Prisma.User_game_favoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_game_favorite>
          }
          groupBy: {
            args: Prisma.user_game_favoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_game_favoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_game_favoriteCountArgs<ExtArgs>
            result: $Utils.Optional<User_game_favoriteCountAggregateOutputType> | number
          }
        }
      }
      faq: {
        payload: Prisma.$faqPayload<ExtArgs>
        fields: Prisma.faqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.faqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.faqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          findFirst: {
            args: Prisma.faqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.faqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          findMany: {
            args: Prisma.faqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>[]
          }
          create: {
            args: Prisma.faqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          createMany: {
            args: Prisma.faqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.faqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          update: {
            args: Prisma.faqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          deleteMany: {
            args: Prisma.faqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.faqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.faqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqPayload>
          }
          aggregate: {
            args: Prisma.FaqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaq>
          }
          groupBy: {
            args: Prisma.faqGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqGroupByOutputType>[]
          }
          count: {
            args: Prisma.faqCountArgs<ExtArgs>
            result: $Utils.Optional<FaqCountAggregateOutputType> | number
          }
        }
      }
      guild: {
        payload: Prisma.$guildPayload<ExtArgs>
        fields: Prisma.guildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>
          }
          findFirst: {
            args: Prisma.guildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>
          }
          findMany: {
            args: Prisma.guildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>[]
          }
          create: {
            args: Prisma.guildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>
          }
          createMany: {
            args: Prisma.guildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>
          }
          update: {
            args: Prisma.guildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>
          }
          deleteMany: {
            args: Prisma.guildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildPayload>
          }
          aggregate: {
            args: Prisma.GuildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuild>
          }
          groupBy: {
            args: Prisma.guildGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildCountArgs<ExtArgs>
            result: $Utils.Optional<GuildCountAggregateOutputType> | number
          }
        }
      }
      guild_member: {
        payload: Prisma.$guild_memberPayload<ExtArgs>
        fields: Prisma.guild_memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guild_memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guild_memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>
          }
          findFirst: {
            args: Prisma.guild_memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guild_memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>
          }
          findMany: {
            args: Prisma.guild_memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>[]
          }
          create: {
            args: Prisma.guild_memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>
          }
          createMany: {
            args: Prisma.guild_memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guild_memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>
          }
          update: {
            args: Prisma.guild_memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>
          }
          deleteMany: {
            args: Prisma.guild_memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guild_memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guild_memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guild_memberPayload>
          }
          aggregate: {
            args: Prisma.Guild_memberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuild_member>
          }
          groupBy: {
            args: Prisma.guild_memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<Guild_memberGroupByOutputType>[]
          }
          count: {
            args: Prisma.guild_memberCountArgs<ExtArgs>
            result: $Utils.Optional<Guild_memberCountAggregateOutputType> | number
          }
        }
      }
      channel: {
        payload: Prisma.$channelPayload<ExtArgs>
        fields: Prisma.channelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.channelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.channelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          findFirst: {
            args: Prisma.channelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.channelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          findMany: {
            args: Prisma.channelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          create: {
            args: Prisma.channelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          createMany: {
            args: Prisma.channelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.channelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          update: {
            args: Prisma.channelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          deleteMany: {
            args: Prisma.channelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.channelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.channelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.channelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.channelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      channel_member: {
        payload: Prisma.$channel_memberPayload<ExtArgs>
        fields: Prisma.channel_memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.channel_memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.channel_memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>
          }
          findFirst: {
            args: Prisma.channel_memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.channel_memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>
          }
          findMany: {
            args: Prisma.channel_memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>[]
          }
          create: {
            args: Prisma.channel_memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>
          }
          createMany: {
            args: Prisma.channel_memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.channel_memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>
          }
          update: {
            args: Prisma.channel_memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>
          }
          deleteMany: {
            args: Prisma.channel_memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.channel_memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.channel_memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channel_memberPayload>
          }
          aggregate: {
            args: Prisma.Channel_memberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel_member>
          }
          groupBy: {
            args: Prisma.channel_memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<Channel_memberGroupByOutputType>[]
          }
          count: {
            args: Prisma.channel_memberCountArgs<ExtArgs>
            result: $Utils.Optional<Channel_memberCountAggregateOutputType> | number
          }
        }
      }
      room: {
        payload: Prisma.$roomPayload<ExtArgs>
        fields: Prisma.roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          findFirst: {
            args: Prisma.roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          findMany: {
            args: Prisma.roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>[]
          }
          create: {
            args: Prisma.roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          createMany: {
            args: Prisma.roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          update: {
            args: Prisma.roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          deleteMany: {
            args: Prisma.roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.roomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      room_participant: {
        payload: Prisma.$room_participantPayload<ExtArgs>
        fields: Prisma.room_participantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.room_participantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.room_participantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>
          }
          findFirst: {
            args: Prisma.room_participantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.room_participantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>
          }
          findMany: {
            args: Prisma.room_participantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>[]
          }
          create: {
            args: Prisma.room_participantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>
          }
          createMany: {
            args: Prisma.room_participantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.room_participantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>
          }
          update: {
            args: Prisma.room_participantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>
          }
          deleteMany: {
            args: Prisma.room_participantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.room_participantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.room_participantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_participantPayload>
          }
          aggregate: {
            args: Prisma.Room_participantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom_participant>
          }
          groupBy: {
            args: Prisma.room_participantGroupByArgs<ExtArgs>
            result: $Utils.Optional<Room_participantGroupByOutputType>[]
          }
          count: {
            args: Prisma.room_participantCountArgs<ExtArgs>
            result: $Utils.Optional<Room_participantCountAggregateOutputType> | number
          }
        }
      }
      dm_pair_unique: {
        payload: Prisma.$dm_pair_uniquePayload<ExtArgs>
        fields: Prisma.dm_pair_uniqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dm_pair_uniqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dm_pair_uniqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>
          }
          findFirst: {
            args: Prisma.dm_pair_uniqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dm_pair_uniqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>
          }
          findMany: {
            args: Prisma.dm_pair_uniqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>[]
          }
          create: {
            args: Prisma.dm_pair_uniqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>
          }
          createMany: {
            args: Prisma.dm_pair_uniqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dm_pair_uniqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>
          }
          update: {
            args: Prisma.dm_pair_uniqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>
          }
          deleteMany: {
            args: Prisma.dm_pair_uniqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dm_pair_uniqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dm_pair_uniqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dm_pair_uniquePayload>
          }
          aggregate: {
            args: Prisma.Dm_pair_uniqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDm_pair_unique>
          }
          groupBy: {
            args: Prisma.dm_pair_uniqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dm_pair_uniqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.dm_pair_uniqueCountArgs<ExtArgs>
            result: $Utils.Optional<Dm_pair_uniqueCountAggregateOutputType> | number
          }
        }
      }
      message: {
        payload: Prisma.$messagePayload<ExtArgs>
        fields: Prisma.messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      message_read: {
        payload: Prisma.$message_readPayload<ExtArgs>
        fields: Prisma.message_readFieldRefs
        operations: {
          findUnique: {
            args: Prisma.message_readFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.message_readFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>
          }
          findFirst: {
            args: Prisma.message_readFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.message_readFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>
          }
          findMany: {
            args: Prisma.message_readFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>[]
          }
          create: {
            args: Prisma.message_readCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>
          }
          createMany: {
            args: Prisma.message_readCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.message_readDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>
          }
          update: {
            args: Prisma.message_readUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>
          }
          deleteMany: {
            args: Prisma.message_readDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.message_readUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.message_readUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_readPayload>
          }
          aggregate: {
            args: Prisma.Message_readAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage_read>
          }
          groupBy: {
            args: Prisma.message_readGroupByArgs<ExtArgs>
            result: $Utils.Optional<Message_readGroupByOutputType>[]
          }
          count: {
            args: Prisma.message_readCountArgs<ExtArgs>
            result: $Utils.Optional<Message_readCountAggregateOutputType> | number
          }
        }
      }
      message_reaction: {
        payload: Prisma.$message_reactionPayload<ExtArgs>
        fields: Prisma.message_reactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.message_reactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.message_reactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>
          }
          findFirst: {
            args: Prisma.message_reactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.message_reactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>
          }
          findMany: {
            args: Prisma.message_reactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>[]
          }
          create: {
            args: Prisma.message_reactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>
          }
          createMany: {
            args: Prisma.message_reactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.message_reactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>
          }
          update: {
            args: Prisma.message_reactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>
          }
          deleteMany: {
            args: Prisma.message_reactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.message_reactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.message_reactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionPayload>
          }
          aggregate: {
            args: Prisma.Message_reactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage_reaction>
          }
          groupBy: {
            args: Prisma.message_reactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Message_reactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.message_reactionCountArgs<ExtArgs>
            result: $Utils.Optional<Message_reactionCountAggregateOutputType> | number
          }
        }
      }
      room_view: {
        payload: Prisma.$room_viewPayload<ExtArgs>
        fields: Prisma.room_viewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.room_viewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.room_viewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>
          }
          findFirst: {
            args: Prisma.room_viewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.room_viewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>
          }
          findMany: {
            args: Prisma.room_viewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>[]
          }
          create: {
            args: Prisma.room_viewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>
          }
          createMany: {
            args: Prisma.room_viewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.room_viewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>
          }
          update: {
            args: Prisma.room_viewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>
          }
          deleteMany: {
            args: Prisma.room_viewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.room_viewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.room_viewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_viewPayload>
          }
          aggregate: {
            args: Prisma.Room_viewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom_view>
          }
          groupBy: {
            args: Prisma.room_viewGroupByArgs<ExtArgs>
            result: $Utils.Optional<Room_viewGroupByOutputType>[]
          }
          count: {
            args: Prisma.room_viewCountArgs<ExtArgs>
            result: $Utils.Optional<Room_viewCountAggregateOutputType> | number
          }
        }
      }
      EFMigrationsHistory: {
        payload: Prisma.$EFMigrationsHistoryPayload<ExtArgs>
        fields: Prisma.EFMigrationsHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFMigrationsHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          findFirst: {
            args: Prisma.EFMigrationsHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          findMany: {
            args: Prisma.EFMigrationsHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>[]
          }
          create: {
            args: Prisma.EFMigrationsHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          createMany: {
            args: Prisma.EFMigrationsHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EFMigrationsHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          update: {
            args: Prisma.EFMigrationsHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          deleteMany: {
            args: Prisma.EFMigrationsHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EFMigrationsHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EFMigrationsHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          aggregate: {
            args: Prisma.EFMigrationsHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEFMigrationsHistory>
          }
          groupBy: {
            args: Prisma.EFMigrationsHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EFMigrationsHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EFMigrationsHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<EFMigrationsHistoryCountAggregateOutputType> | number
          }
        }
      }
      edition: {
        payload: Prisma.$editionPayload<ExtArgs>
        fields: Prisma.editionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.editionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.editionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>
          }
          findFirst: {
            args: Prisma.editionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.editionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>
          }
          findMany: {
            args: Prisma.editionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>[]
          }
          create: {
            args: Prisma.editionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>
          }
          createMany: {
            args: Prisma.editionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.editionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>
          }
          update: {
            args: Prisma.editionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>
          }
          deleteMany: {
            args: Prisma.editionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.editionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.editionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$editionPayload>
          }
          aggregate: {
            args: Prisma.EditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdition>
          }
          groupBy: {
            args: Prisma.editionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.editionCountArgs<ExtArgs>
            result: $Utils.Optional<EditionCountAggregateOutputType> | number
          }
        }
      }
      edition_room: {
        payload: Prisma.$edition_roomPayload<ExtArgs>
        fields: Prisma.edition_roomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edition_roomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edition_roomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>
          }
          findFirst: {
            args: Prisma.edition_roomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edition_roomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>
          }
          findMany: {
            args: Prisma.edition_roomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>[]
          }
          create: {
            args: Prisma.edition_roomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>
          }
          createMany: {
            args: Prisma.edition_roomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.edition_roomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>
          }
          update: {
            args: Prisma.edition_roomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>
          }
          deleteMany: {
            args: Prisma.edition_roomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.edition_roomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.edition_roomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edition_roomPayload>
          }
          aggregate: {
            args: Prisma.Edition_roomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdition_room>
          }
          groupBy: {
            args: Prisma.edition_roomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Edition_roomGroupByOutputType>[]
          }
          count: {
            args: Prisma.edition_roomCountArgs<ExtArgs>
            result: $Utils.Optional<Edition_roomCountAggregateOutputType> | number
          }
        }
      }
      table: {
        payload: Prisma.$tablePayload<ExtArgs>
        fields: Prisma.tableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>
          }
          findFirst: {
            args: Prisma.tableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>
          }
          findMany: {
            args: Prisma.tableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>[]
          }
          create: {
            args: Prisma.tableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>
          }
          createMany: {
            args: Prisma.tableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>
          }
          update: {
            args: Prisma.tableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>
          }
          deleteMany: {
            args: Prisma.tableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.tableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.tableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      table_seat: {
        payload: Prisma.$table_seatPayload<ExtArgs>
        fields: Prisma.table_seatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.table_seatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.table_seatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>
          }
          findFirst: {
            args: Prisma.table_seatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.table_seatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>
          }
          findMany: {
            args: Prisma.table_seatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>[]
          }
          create: {
            args: Prisma.table_seatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>
          }
          createMany: {
            args: Prisma.table_seatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.table_seatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>
          }
          update: {
            args: Prisma.table_seatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>
          }
          deleteMany: {
            args: Prisma.table_seatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.table_seatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.table_seatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_seatPayload>
          }
          aggregate: {
            args: Prisma.Table_seatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable_seat>
          }
          groupBy: {
            args: Prisma.table_seatGroupByArgs<ExtArgs>
            result: $Utils.Optional<Table_seatGroupByOutputType>[]
          }
          count: {
            args: Prisma.table_seatCountArgs<ExtArgs>
            result: $Utils.Optional<Table_seatCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: accountOmit
    invitation?: invitationOmit
    jwks?: jwksOmit
    member?: memberOmit
    organization?: organizationOmit
    session?: sessionOmit
    user?: userOmit
    verification?: verificationOmit
    sidelink?: sidelinkOmit
    username_file_config?: username_file_configOmit
    user_settings?: user_settingsOmit
    game_session?: game_sessionOmit
    event?: eventOmit
    global_settings?: global_settingsOmit
    game?: gameOmit
    game_server?: game_serverOmit
    role?: roleOmit
    user_game?: user_gameOmit
    user_game_favorite?: user_game_favoriteOmit
    faq?: faqOmit
    guild?: guildOmit
    guild_member?: guild_memberOmit
    channel?: channelOmit
    channel_member?: channel_memberOmit
    room?: roomOmit
    room_participant?: room_participantOmit
    dm_pair_unique?: dm_pair_uniqueOmit
    message?: messageOmit
    message_read?: message_readOmit
    message_reaction?: message_reactionOmit
    room_view?: room_viewOmit
    eFMigrationsHistory?: EFMigrationsHistoryOmit
    edition?: editionOmit
    edition_room?: edition_roomOmit
    table?: tableOmit
    table_seat?: table_seatOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    channel_memberships: number
    event_created: number
    event_updated: number
    faq_created: number
    faq_updated: number
    gamesCreated: number
    gamesUpdated: number
    game_session: number
    guild: number
    guild_memberships: number
    messages: number
    message_reactions: number
    message_reads: number
    room: number
    room_participations: number
    room_view: number
    edition_created: number
    edition_updated: number
    table_seats: number
    game_server_created: number
    game_server_updated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel_memberships?: boolean | UserCountOutputTypeCountChannel_membershipsArgs
    event_created?: boolean | UserCountOutputTypeCountEvent_createdArgs
    event_updated?: boolean | UserCountOutputTypeCountEvent_updatedArgs
    faq_created?: boolean | UserCountOutputTypeCountFaq_createdArgs
    faq_updated?: boolean | UserCountOutputTypeCountFaq_updatedArgs
    gamesCreated?: boolean | UserCountOutputTypeCountGamesCreatedArgs
    gamesUpdated?: boolean | UserCountOutputTypeCountGamesUpdatedArgs
    game_session?: boolean | UserCountOutputTypeCountGame_sessionArgs
    guild?: boolean | UserCountOutputTypeCountGuildArgs
    guild_memberships?: boolean | UserCountOutputTypeCountGuild_membershipsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    message_reactions?: boolean | UserCountOutputTypeCountMessage_reactionsArgs
    message_reads?: boolean | UserCountOutputTypeCountMessage_readsArgs
    room?: boolean | UserCountOutputTypeCountRoomArgs
    room_participations?: boolean | UserCountOutputTypeCountRoom_participationsArgs
    room_view?: boolean | UserCountOutputTypeCountRoom_viewArgs
    edition_created?: boolean | UserCountOutputTypeCountEdition_createdArgs
    edition_updated?: boolean | UserCountOutputTypeCountEdition_updatedArgs
    table_seats?: boolean | UserCountOutputTypeCountTable_seatsArgs
    game_server_created?: boolean | UserCountOutputTypeCountGame_server_createdArgs
    game_server_updated?: boolean | UserCountOutputTypeCountGame_server_updatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChannel_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channel_memberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvent_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvent_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFaq_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFaq_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGamesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gameWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGamesUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gameWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGame_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_sessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGuild_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guild_memberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_reactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_readWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoom_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_participantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoom_viewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_viewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEdition_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: editionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEdition_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: editionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTable_seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: table_seatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGame_server_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_serverWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGame_server_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_serverWhereInput
  }


  /**
   * Count Type GuildCountOutputType
   */

  export type GuildCountOutputType = {
    channels: number
    members: number
    room: number
  }

  export type GuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | GuildCountOutputTypeCountChannelsArgs
    members?: boolean | GuildCountOutputTypeCountMembersArgs
    room?: boolean | GuildCountOutputTypeCountRoomArgs
  }

  // Custom InputTypes
  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildCountOutputType
     */
    select?: GuildCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
  }

  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guild_memberWhereInput
  }

  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeCountRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roomWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    children: number
    members: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChannelCountOutputTypeCountChildrenArgs
    members?: boolean | ChannelCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channel_memberWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    dm_pair_unique: number
    messages: number
    participants: number
    room_view: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dm_pair_unique?: boolean | RoomCountOutputTypeCountDm_pair_uniqueArgs
    messages?: boolean | RoomCountOutputTypeCountMessagesArgs
    participants?: boolean | RoomCountOutputTypeCountParticipantsArgs
    room_view?: boolean | RoomCountOutputTypeCountRoom_viewArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountDm_pair_uniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dm_pair_uniqueWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_participantWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountRoom_viewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_viewWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    reactions: number
    reads: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | MessageCountOutputTypeCountReactionsArgs
    reads?: boolean | MessageCountOutputTypeCountReadsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_reactionWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_readWhereInput
  }


  /**
   * Count Type EditionCountOutputType
   */

  export type EditionCountOutputType = {
    rooms: number
  }

  export type EditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | EditionCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * EditionCountOutputType without action
   */
  export type EditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EditionCountOutputType
     */
    select?: EditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EditionCountOutputType without action
   */
  export type EditionCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edition_roomWhereInput
  }


  /**
   * Count Type Edition_roomCountOutputType
   */

  export type Edition_roomCountOutputType = {
    tables: number
  }

  export type Edition_roomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | Edition_roomCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * Edition_roomCountOutputType without action
   */
  export type Edition_roomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition_roomCountOutputType
     */
    select?: Edition_roomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Edition_roomCountOutputType without action
   */
  export type Edition_roomCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tableWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    seats: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seats?: boolean | TableCountOutputTypeCountSeatsArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: table_seatWhereInput
  }


  /**
   * Models
   */

  /**
   * Model account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account to aggregate.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountWhereInput
    orderBy?: accountOrderByWithAggregationInput | accountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>



  export type accountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type accountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>

  export type $accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "account"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type accountGetPayload<S extends boolean | null | undefined | accountDefaultArgs> = $Result.GetResult<Prisma.$accountPayload, S>

  type accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account'], meta: { name: 'account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {accountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountFindUniqueArgs>(args: SelectSubset<T, accountFindUniqueArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountFindUniqueOrThrowArgs>(args: SelectSubset<T, accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountFindFirstArgs>(args?: SelectSubset<T, accountFindFirstArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountFindFirstOrThrowArgs>(args?: SelectSubset<T, accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountFindManyArgs>(args?: SelectSubset<T, accountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {accountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends accountCreateArgs>(args: SelectSubset<T, accountCreateArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountCreateManyArgs>(args?: SelectSubset<T, accountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {accountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends accountDeleteArgs>(args: SelectSubset<T, accountDeleteArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {accountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountUpdateArgs>(args: SelectSubset<T, accountUpdateArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountDeleteManyArgs>(args?: SelectSubset<T, accountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountUpdateManyArgs>(args: SelectSubset<T, accountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {accountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends accountUpsertArgs>(args: SelectSubset<T, accountUpsertArgs<ExtArgs>>): Prisma__accountClient<$Result.GetResult<Prisma.$accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountCountArgs>(
      args?: Subset<T, accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountGroupByArgs['orderBy'] }
        : { orderBy?: accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the account model
   */
  readonly fields: accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the account model
   */
  interface accountFieldRefs {
    readonly id: FieldRef<"account", 'String'>
    readonly accountId: FieldRef<"account", 'String'>
    readonly providerId: FieldRef<"account", 'String'>
    readonly userId: FieldRef<"account", 'String'>
    readonly accessToken: FieldRef<"account", 'String'>
    readonly refreshToken: FieldRef<"account", 'String'>
    readonly idToken: FieldRef<"account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"account", 'DateTime'>
    readonly scope: FieldRef<"account", 'String'>
    readonly password: FieldRef<"account", 'String'>
    readonly createdAt: FieldRef<"account", 'DateTime'>
    readonly updatedAt: FieldRef<"account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * account findUnique
   */
  export type accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findUniqueOrThrow
   */
  export type accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findFirst
   */
  export type accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account findFirstOrThrow
   */
  export type accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account findMany
   */
  export type accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * account create
   */
  export type accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The data needed to create a account.
     */
    data: XOR<accountCreateInput, accountUncheckedCreateInput>
  }

  /**
   * account createMany
   */
  export type accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountCreateManyInput | accountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * account update
   */
  export type accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The data needed to update a account.
     */
    data: XOR<accountUpdateInput, accountUncheckedUpdateInput>
    /**
     * Choose, which account to update.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account updateMany
   */
  export type accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * account upsert
   */
  export type accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * The filter to search for the account to update in case it exists.
     */
    where: accountWhereUniqueInput
    /**
     * In case the account found by the `where` argument doesn't exist, create a new account with this data.
     */
    create: XOR<accountCreateInput, accountUncheckedCreateInput>
    /**
     * In case the account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountUpdateInput, accountUncheckedUpdateInput>
  }

  /**
   * account delete
   */
  export type accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
    /**
     * Filter which account to delete.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account deleteMany
   */
  export type accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * account without action
   */
  export type accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null
  }


  /**
   * Model invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    organizationId: number
    email: number
    role: number
    status: number
    expiresAt: number
    inviterId: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitation to aggregate.
     */
    where?: invitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationOrderByWithRelationInput | invitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type invitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationWhereInput
    orderBy?: invitationOrderByWithAggregationInput | invitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: invitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    organizationId: string
    email: string
    role: string | null
    status: string
    expiresAt: Date
    inviterId: string
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends invitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type invitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
  }, ExtArgs["result"]["invitation"]>



  export type invitationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
  }

  export type invitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "email" | "role" | "status" | "expiresAt" | "inviterId", ExtArgs["result"]["invitation"]>

  export type $invitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invitation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      email: string
      role: string | null
      status: string
      expiresAt: Date
      inviterId: string
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type invitationGetPayload<S extends boolean | null | undefined | invitationDefaultArgs> = $Result.GetResult<Prisma.$invitationPayload, S>

  type invitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface invitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invitation'], meta: { name: 'invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {invitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invitationFindUniqueArgs>(args: SelectSubset<T, invitationFindUniqueArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invitationFindUniqueOrThrowArgs>(args: SelectSubset<T, invitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invitationFindFirstArgs>(args?: SelectSubset<T, invitationFindFirstArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invitationFindFirstOrThrowArgs>(args?: SelectSubset<T, invitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invitationFindManyArgs>(args?: SelectSubset<T, invitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {invitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends invitationCreateArgs>(args: SelectSubset<T, invitationCreateArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {invitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invitationCreateManyArgs>(args?: SelectSubset<T, invitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invitation.
     * @param {invitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends invitationDeleteArgs>(args: SelectSubset<T, invitationDeleteArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {invitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invitationUpdateArgs>(args: SelectSubset<T, invitationUpdateArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {invitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invitationDeleteManyArgs>(args?: SelectSubset<T, invitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invitationUpdateManyArgs>(args: SelectSubset<T, invitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {invitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends invitationUpsertArgs>(args: SelectSubset<T, invitationUpsertArgs<ExtArgs>>): Prisma__invitationClient<$Result.GetResult<Prisma.$invitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends invitationCountArgs>(
      args?: Subset<T, invitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invitationGroupByArgs['orderBy'] }
        : { orderBy?: invitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invitation model
   */
  readonly fields: invitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invitation model
   */
  interface invitationFieldRefs {
    readonly id: FieldRef<"invitation", 'String'>
    readonly organizationId: FieldRef<"invitation", 'String'>
    readonly email: FieldRef<"invitation", 'String'>
    readonly role: FieldRef<"invitation", 'String'>
    readonly status: FieldRef<"invitation", 'String'>
    readonly expiresAt: FieldRef<"invitation", 'DateTime'>
    readonly inviterId: FieldRef<"invitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invitation findUnique
   */
  export type invitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * Filter, which invitation to fetch.
     */
    where: invitationWhereUniqueInput
  }

  /**
   * invitation findUniqueOrThrow
   */
  export type invitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * Filter, which invitation to fetch.
     */
    where: invitationWhereUniqueInput
  }

  /**
   * invitation findFirst
   */
  export type invitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * Filter, which invitation to fetch.
     */
    where?: invitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationOrderByWithRelationInput | invitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * invitation findFirstOrThrow
   */
  export type invitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * Filter, which invitation to fetch.
     */
    where?: invitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationOrderByWithRelationInput | invitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * invitation findMany
   */
  export type invitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationOrderByWithRelationInput | invitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invitations.
     */
    cursor?: invitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * invitation create
   */
  export type invitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * The data needed to create a invitation.
     */
    data: XOR<invitationCreateInput, invitationUncheckedCreateInput>
  }

  /**
   * invitation createMany
   */
  export type invitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invitations.
     */
    data: invitationCreateManyInput | invitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invitation update
   */
  export type invitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * The data needed to update a invitation.
     */
    data: XOR<invitationUpdateInput, invitationUncheckedUpdateInput>
    /**
     * Choose, which invitation to update.
     */
    where: invitationWhereUniqueInput
  }

  /**
   * invitation updateMany
   */
  export type invitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationUpdateManyMutationInput, invitationUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
  }

  /**
   * invitation upsert
   */
  export type invitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * The filter to search for the invitation to update in case it exists.
     */
    where: invitationWhereUniqueInput
    /**
     * In case the invitation found by the `where` argument doesn't exist, create a new invitation with this data.
     */
    create: XOR<invitationCreateInput, invitationUncheckedCreateInput>
    /**
     * In case the invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invitationUpdateInput, invitationUncheckedUpdateInput>
  }

  /**
   * invitation delete
   */
  export type invitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
    /**
     * Filter which invitation to delete.
     */
    where: invitationWhereUniqueInput
  }

  /**
   * invitation deleteMany
   */
  export type invitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to delete
     */
    where?: invitationWhereInput
    /**
     * Limit how many invitations to delete.
     */
    limit?: number
  }

  /**
   * invitation without action
   */
  export type invitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitation
     */
    select?: invitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitation
     */
    omit?: invitationOmit<ExtArgs> | null
  }


  /**
   * Model jwks
   */

  export type AggregateJwks = {
    _count: JwksCountAggregateOutputType | null
    _min: JwksMinAggregateOutputType | null
    _max: JwksMaxAggregateOutputType | null
  }

  export type JwksMinAggregateOutputType = {
    id: string | null
    publicKey: string | null
    privateKey: string | null
    createdAt: Date | null
  }

  export type JwksMaxAggregateOutputType = {
    id: string | null
    publicKey: string | null
    privateKey: string | null
    createdAt: Date | null
  }

  export type JwksCountAggregateOutputType = {
    id: number
    publicKey: number
    privateKey: number
    createdAt: number
    _all: number
  }


  export type JwksMinAggregateInputType = {
    id?: true
    publicKey?: true
    privateKey?: true
    createdAt?: true
  }

  export type JwksMaxAggregateInputType = {
    id?: true
    publicKey?: true
    privateKey?: true
    createdAt?: true
  }

  export type JwksCountAggregateInputType = {
    id?: true
    publicKey?: true
    privateKey?: true
    createdAt?: true
    _all?: true
  }

  export type JwksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jwks to aggregate.
     */
    where?: jwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jwks to fetch.
     */
    orderBy?: jwksOrderByWithRelationInput | jwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jwks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jwks
    **/
    _count?: true | JwksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JwksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JwksMaxAggregateInputType
  }

  export type GetJwksAggregateType<T extends JwksAggregateArgs> = {
        [P in keyof T & keyof AggregateJwks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJwks[P]>
      : GetScalarType<T[P], AggregateJwks[P]>
  }




  export type jwksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jwksWhereInput
    orderBy?: jwksOrderByWithAggregationInput | jwksOrderByWithAggregationInput[]
    by: JwksScalarFieldEnum[] | JwksScalarFieldEnum
    having?: jwksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JwksCountAggregateInputType | true
    _min?: JwksMinAggregateInputType
    _max?: JwksMaxAggregateInputType
  }

  export type JwksGroupByOutputType = {
    id: string
    publicKey: string
    privateKey: string
    createdAt: Date
    _count: JwksCountAggregateOutputType | null
    _min: JwksMinAggregateOutputType | null
    _max: JwksMaxAggregateOutputType | null
  }

  type GetJwksGroupByPayload<T extends jwksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JwksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JwksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JwksGroupByOutputType[P]>
            : GetScalarType<T[P], JwksGroupByOutputType[P]>
        }
      >
    >


  export type jwksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicKey?: boolean
    privateKey?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jwks"]>



  export type jwksSelectScalar = {
    id?: boolean
    publicKey?: boolean
    privateKey?: boolean
    createdAt?: boolean
  }

  export type jwksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publicKey" | "privateKey" | "createdAt", ExtArgs["result"]["jwks"]>

  export type $jwksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jwks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publicKey: string
      privateKey: string
      createdAt: Date
    }, ExtArgs["result"]["jwks"]>
    composites: {}
  }

  type jwksGetPayload<S extends boolean | null | undefined | jwksDefaultArgs> = $Result.GetResult<Prisma.$jwksPayload, S>

  type jwksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jwksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JwksCountAggregateInputType | true
    }

  export interface jwksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jwks'], meta: { name: 'jwks' } }
    /**
     * Find zero or one Jwks that matches the filter.
     * @param {jwksFindUniqueArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jwksFindUniqueArgs>(args: SelectSubset<T, jwksFindUniqueArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jwks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jwksFindUniqueOrThrowArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jwksFindUniqueOrThrowArgs>(args: SelectSubset<T, jwksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jwks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jwksFindFirstArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jwksFindFirstArgs>(args?: SelectSubset<T, jwksFindFirstArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jwks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jwksFindFirstOrThrowArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jwksFindFirstOrThrowArgs>(args?: SelectSubset<T, jwksFindFirstOrThrowArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jwks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jwksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jwks
     * const jwks = await prisma.jwks.findMany()
     * 
     * // Get first 10 Jwks
     * const jwks = await prisma.jwks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jwksWithIdOnly = await prisma.jwks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jwksFindManyArgs>(args?: SelectSubset<T, jwksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jwks.
     * @param {jwksCreateArgs} args - Arguments to create a Jwks.
     * @example
     * // Create one Jwks
     * const Jwks = await prisma.jwks.create({
     *   data: {
     *     // ... data to create a Jwks
     *   }
     * })
     * 
     */
    create<T extends jwksCreateArgs>(args: SelectSubset<T, jwksCreateArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jwks.
     * @param {jwksCreateManyArgs} args - Arguments to create many Jwks.
     * @example
     * // Create many Jwks
     * const jwks = await prisma.jwks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jwksCreateManyArgs>(args?: SelectSubset<T, jwksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jwks.
     * @param {jwksDeleteArgs} args - Arguments to delete one Jwks.
     * @example
     * // Delete one Jwks
     * const Jwks = await prisma.jwks.delete({
     *   where: {
     *     // ... filter to delete one Jwks
     *   }
     * })
     * 
     */
    delete<T extends jwksDeleteArgs>(args: SelectSubset<T, jwksDeleteArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jwks.
     * @param {jwksUpdateArgs} args - Arguments to update one Jwks.
     * @example
     * // Update one Jwks
     * const jwks = await prisma.jwks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jwksUpdateArgs>(args: SelectSubset<T, jwksUpdateArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jwks.
     * @param {jwksDeleteManyArgs} args - Arguments to filter Jwks to delete.
     * @example
     * // Delete a few Jwks
     * const { count } = await prisma.jwks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jwksDeleteManyArgs>(args?: SelectSubset<T, jwksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jwksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jwks
     * const jwks = await prisma.jwks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jwksUpdateManyArgs>(args: SelectSubset<T, jwksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jwks.
     * @param {jwksUpsertArgs} args - Arguments to update or create a Jwks.
     * @example
     * // Update or create a Jwks
     * const jwks = await prisma.jwks.upsert({
     *   create: {
     *     // ... data to create a Jwks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jwks we want to update
     *   }
     * })
     */
    upsert<T extends jwksUpsertArgs>(args: SelectSubset<T, jwksUpsertArgs<ExtArgs>>): Prisma__jwksClient<$Result.GetResult<Prisma.$jwksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jwksCountArgs} args - Arguments to filter Jwks to count.
     * @example
     * // Count the number of Jwks
     * const count = await prisma.jwks.count({
     *   where: {
     *     // ... the filter for the Jwks we want to count
     *   }
     * })
    **/
    count<T extends jwksCountArgs>(
      args?: Subset<T, jwksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JwksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JwksAggregateArgs>(args: Subset<T, JwksAggregateArgs>): Prisma.PrismaPromise<GetJwksAggregateType<T>>

    /**
     * Group by Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jwksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jwksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jwksGroupByArgs['orderBy'] }
        : { orderBy?: jwksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jwksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJwksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jwks model
   */
  readonly fields: jwksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jwks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jwksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jwks model
   */
  interface jwksFieldRefs {
    readonly id: FieldRef<"jwks", 'String'>
    readonly publicKey: FieldRef<"jwks", 'String'>
    readonly privateKey: FieldRef<"jwks", 'String'>
    readonly createdAt: FieldRef<"jwks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * jwks findUnique
   */
  export type jwksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * Filter, which jwks to fetch.
     */
    where: jwksWhereUniqueInput
  }

  /**
   * jwks findUniqueOrThrow
   */
  export type jwksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * Filter, which jwks to fetch.
     */
    where: jwksWhereUniqueInput
  }

  /**
   * jwks findFirst
   */
  export type jwksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * Filter, which jwks to fetch.
     */
    where?: jwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jwks to fetch.
     */
    orderBy?: jwksOrderByWithRelationInput | jwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jwks.
     */
    cursor?: jwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jwks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jwks.
     */
    distinct?: JwksScalarFieldEnum | JwksScalarFieldEnum[]
  }

  /**
   * jwks findFirstOrThrow
   */
  export type jwksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * Filter, which jwks to fetch.
     */
    where?: jwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jwks to fetch.
     */
    orderBy?: jwksOrderByWithRelationInput | jwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jwks.
     */
    cursor?: jwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jwks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jwks.
     */
    distinct?: JwksScalarFieldEnum | JwksScalarFieldEnum[]
  }

  /**
   * jwks findMany
   */
  export type jwksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * Filter, which jwks to fetch.
     */
    where?: jwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jwks to fetch.
     */
    orderBy?: jwksOrderByWithRelationInput | jwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jwks.
     */
    cursor?: jwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jwks.
     */
    skip?: number
    distinct?: JwksScalarFieldEnum | JwksScalarFieldEnum[]
  }

  /**
   * jwks create
   */
  export type jwksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * The data needed to create a jwks.
     */
    data: XOR<jwksCreateInput, jwksUncheckedCreateInput>
  }

  /**
   * jwks createMany
   */
  export type jwksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jwks.
     */
    data: jwksCreateManyInput | jwksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jwks update
   */
  export type jwksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * The data needed to update a jwks.
     */
    data: XOR<jwksUpdateInput, jwksUncheckedUpdateInput>
    /**
     * Choose, which jwks to update.
     */
    where: jwksWhereUniqueInput
  }

  /**
   * jwks updateMany
   */
  export type jwksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jwks.
     */
    data: XOR<jwksUpdateManyMutationInput, jwksUncheckedUpdateManyInput>
    /**
     * Filter which jwks to update
     */
    where?: jwksWhereInput
    /**
     * Limit how many jwks to update.
     */
    limit?: number
  }

  /**
   * jwks upsert
   */
  export type jwksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * The filter to search for the jwks to update in case it exists.
     */
    where: jwksWhereUniqueInput
    /**
     * In case the jwks found by the `where` argument doesn't exist, create a new jwks with this data.
     */
    create: XOR<jwksCreateInput, jwksUncheckedCreateInput>
    /**
     * In case the jwks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jwksUpdateInput, jwksUncheckedUpdateInput>
  }

  /**
   * jwks delete
   */
  export type jwksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
    /**
     * Filter which jwks to delete.
     */
    where: jwksWhereUniqueInput
  }

  /**
   * jwks deleteMany
   */
  export type jwksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jwks to delete
     */
    where?: jwksWhereInput
    /**
     * Limit how many jwks to delete.
     */
    limit?: number
  }

  /**
   * jwks without action
   */
  export type jwksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jwks
     */
    select?: jwksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jwks
     */
    omit?: jwksOmit<ExtArgs> | null
  }


  /**
   * Model member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    role: number
    createdAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which member to aggregate.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: memberWhereInput
    orderBy?: memberOrderByWithAggregationInput | memberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["member"]>



  export type memberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "role" | "createdAt", ExtArgs["result"]["member"]>

  export type $memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "member"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      role: string
      createdAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type memberGetPayload<S extends boolean | null | undefined | memberDefaultArgs> = $Result.GetResult<Prisma.$memberPayload, S>

  type memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['member'], meta: { name: 'member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {memberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends memberFindUniqueArgs>(args: SelectSubset<T, memberFindUniqueArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {memberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends memberFindUniqueOrThrowArgs>(args: SelectSubset<T, memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends memberFindFirstArgs>(args?: SelectSubset<T, memberFindFirstArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends memberFindFirstOrThrowArgs>(args?: SelectSubset<T, memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends memberFindManyArgs>(args?: SelectSubset<T, memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {memberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends memberCreateArgs>(args: SelectSubset<T, memberCreateArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {memberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends memberCreateManyArgs>(args?: SelectSubset<T, memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {memberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends memberDeleteArgs>(args: SelectSubset<T, memberDeleteArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {memberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends memberUpdateArgs>(args: SelectSubset<T, memberUpdateArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {memberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends memberDeleteManyArgs>(args?: SelectSubset<T, memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends memberUpdateManyArgs>(args: SelectSubset<T, memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {memberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends memberUpsertArgs>(args: SelectSubset<T, memberUpsertArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends memberCountArgs>(
      args?: Subset<T, memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: memberGroupByArgs['orderBy'] }
        : { orderBy?: memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the member model
   */
  readonly fields: memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the member model
   */
  interface memberFieldRefs {
    readonly id: FieldRef<"member", 'String'>
    readonly organizationId: FieldRef<"member", 'String'>
    readonly userId: FieldRef<"member", 'String'>
    readonly role: FieldRef<"member", 'String'>
    readonly createdAt: FieldRef<"member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * member findUnique
   */
  export type memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findUniqueOrThrow
   */
  export type memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findFirst
   */
  export type memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member findFirstOrThrow
   */
  export type memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member findMany
   */
  export type memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which members to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member create
   */
  export type memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The data needed to create a member.
     */
    data: XOR<memberCreateInput, memberUncheckedCreateInput>
  }

  /**
   * member createMany
   */
  export type memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many members.
     */
    data: memberCreateManyInput | memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * member update
   */
  export type memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The data needed to update a member.
     */
    data: XOR<memberUpdateInput, memberUncheckedUpdateInput>
    /**
     * Choose, which member to update.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member updateMany
   */
  export type memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update members.
     */
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyInput>
    /**
     * Filter which members to update
     */
    where?: memberWhereInput
    /**
     * Limit how many members to update.
     */
    limit?: number
  }

  /**
   * member upsert
   */
  export type memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The filter to search for the member to update in case it exists.
     */
    where: memberWhereUniqueInput
    /**
     * In case the member found by the `where` argument doesn't exist, create a new member with this data.
     */
    create: XOR<memberCreateInput, memberUncheckedCreateInput>
    /**
     * In case the member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<memberUpdateInput, memberUncheckedUpdateInput>
  }

  /**
   * member delete
   */
  export type memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter which member to delete.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member deleteMany
   */
  export type memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which members to delete
     */
    where?: memberWhereInput
    /**
     * Limit how many members to delete.
     */
    limit?: number
  }

  /**
   * member without action
   */
  export type memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
  }


  /**
   * Model organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    metadata: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    metadata: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organization to aggregate.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type organizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationWhereInput
    orderBy?: organizationOrderByWithAggregationInput | organizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: organizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    createdAt: Date
    metadata: string | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends organizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type organizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["organization"]>



  export type organizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type organizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "createdAt" | "metadata", ExtArgs["result"]["organization"]>

  export type $organizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organization"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logo: string | null
      createdAt: Date
      metadata: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type organizationGetPayload<S extends boolean | null | undefined | organizationDefaultArgs> = $Result.GetResult<Prisma.$organizationPayload, S>

  type organizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<organizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface organizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organization'], meta: { name: 'organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {organizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends organizationFindUniqueArgs>(args: SelectSubset<T, organizationFindUniqueArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {organizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends organizationFindUniqueOrThrowArgs>(args: SelectSubset<T, organizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends organizationFindFirstArgs>(args?: SelectSubset<T, organizationFindFirstArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends organizationFindFirstOrThrowArgs>(args?: SelectSubset<T, organizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends organizationFindManyArgs>(args?: SelectSubset<T, organizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {organizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends organizationCreateArgs>(args: SelectSubset<T, organizationCreateArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {organizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends organizationCreateManyArgs>(args?: SelectSubset<T, organizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {organizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends organizationDeleteArgs>(args: SelectSubset<T, organizationDeleteArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {organizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends organizationUpdateArgs>(args: SelectSubset<T, organizationUpdateArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {organizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends organizationDeleteManyArgs>(args?: SelectSubset<T, organizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends organizationUpdateManyArgs>(args: SelectSubset<T, organizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {organizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends organizationUpsertArgs>(args: SelectSubset<T, organizationUpsertArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationCountArgs>(
      args?: Subset<T, organizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizationGroupByArgs['orderBy'] }
        : { orderBy?: organizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organization model
   */
  readonly fields: organizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the organization model
   */
  interface organizationFieldRefs {
    readonly id: FieldRef<"organization", 'String'>
    readonly name: FieldRef<"organization", 'String'>
    readonly slug: FieldRef<"organization", 'String'>
    readonly logo: FieldRef<"organization", 'String'>
    readonly createdAt: FieldRef<"organization", 'DateTime'>
    readonly metadata: FieldRef<"organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * organization findUnique
   */
  export type organizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization findUniqueOrThrow
   */
  export type organizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization findFirst
   */
  export type organizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization findFirstOrThrow
   */
  export type organizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization findMany
   */
  export type organizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization create
   */
  export type organizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * The data needed to create a organization.
     */
    data: XOR<organizationCreateInput, organizationUncheckedCreateInput>
  }

  /**
   * organization createMany
   */
  export type organizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizations.
     */
    data: organizationCreateManyInput | organizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organization update
   */
  export type organizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * The data needed to update a organization.
     */
    data: XOR<organizationUpdateInput, organizationUncheckedUpdateInput>
    /**
     * Choose, which organization to update.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization updateMany
   */
  export type organizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationUpdateManyMutationInput, organizationUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to update.
     */
    limit?: number
  }

  /**
   * organization upsert
   */
  export type organizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * The filter to search for the organization to update in case it exists.
     */
    where: organizationWhereUniqueInput
    /**
     * In case the organization found by the `where` argument doesn't exist, create a new organization with this data.
     */
    create: XOR<organizationCreateInput, organizationUncheckedCreateInput>
    /**
     * In case the organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationUpdateInput, organizationUncheckedUpdateInput>
  }

  /**
   * organization delete
   */
  export type organizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Filter which organization to delete.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization deleteMany
   */
  export type organizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to delete.
     */
    limit?: number
  }

  /**
   * organization without action
   */
  export type organizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
    activeOrganizationId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
    activeOrganizationId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    impersonatedBy: number
    activeOrganizationId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    activeOrganizationId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    activeOrganizationId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    activeOrganizationId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    impersonatedBy: string | null
    activeOrganizationId: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    activeOrganizationId?: boolean
  }, ExtArgs["result"]["session"]>



  export type sessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    activeOrganizationId?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId" | "impersonatedBy" | "activeOrganizationId", ExtArgs["result"]["session"]>

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
      impersonatedBy: string | null
      activeOrganizationId: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly expiresAt: FieldRef<"session", 'DateTime'>
    readonly token: FieldRef<"session", 'String'>
    readonly createdAt: FieldRef<"session", 'DateTime'>
    readonly updatedAt: FieldRef<"session", 'DateTime'>
    readonly ipAddress: FieldRef<"session", 'String'>
    readonly userAgent: FieldRef<"session", 'String'>
    readonly userId: FieldRef<"session", 'String'>
    readonly impersonatedBy: FieldRef<"session", 'String'>
    readonly activeOrganizationId: FieldRef<"session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    displayUsername: string | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    displayUsername: string | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    username: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    displayUsername: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    displayUsername?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    displayUsername?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    displayUsername?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    username: string | null
    role: string
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    displayUsername: string | null
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    displayUsername?: boolean
    lastLogin?: boolean
    channel_memberships?: boolean | user$channel_membershipsArgs<ExtArgs>
    event_created?: boolean | user$event_createdArgs<ExtArgs>
    event_updated?: boolean | user$event_updatedArgs<ExtArgs>
    faq_created?: boolean | user$faq_createdArgs<ExtArgs>
    faq_updated?: boolean | user$faq_updatedArgs<ExtArgs>
    gamesCreated?: boolean | user$gamesCreatedArgs<ExtArgs>
    gamesUpdated?: boolean | user$gamesUpdatedArgs<ExtArgs>
    game_session?: boolean | user$game_sessionArgs<ExtArgs>
    guild?: boolean | user$guildArgs<ExtArgs>
    guild_memberships?: boolean | user$guild_membershipsArgs<ExtArgs>
    messages?: boolean | user$messagesArgs<ExtArgs>
    message_reactions?: boolean | user$message_reactionsArgs<ExtArgs>
    message_reads?: boolean | user$message_readsArgs<ExtArgs>
    room?: boolean | user$roomArgs<ExtArgs>
    room_participations?: boolean | user$room_participationsArgs<ExtArgs>
    room_view?: boolean | user$room_viewArgs<ExtArgs>
    user_settings?: boolean | user$user_settingsArgs<ExtArgs>
    edition_created?: boolean | user$edition_createdArgs<ExtArgs>
    edition_updated?: boolean | user$edition_updatedArgs<ExtArgs>
    table_seats?: boolean | user$table_seatsArgs<ExtArgs>
    game_server_created?: boolean | user$game_server_createdArgs<ExtArgs>
    game_server_updated?: boolean | user$game_server_updatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    displayUsername?: boolean
    lastLogin?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "username" | "role" | "banned" | "banReason" | "banExpires" | "displayUsername" | "lastLogin", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel_memberships?: boolean | user$channel_membershipsArgs<ExtArgs>
    event_created?: boolean | user$event_createdArgs<ExtArgs>
    event_updated?: boolean | user$event_updatedArgs<ExtArgs>
    faq_created?: boolean | user$faq_createdArgs<ExtArgs>
    faq_updated?: boolean | user$faq_updatedArgs<ExtArgs>
    gamesCreated?: boolean | user$gamesCreatedArgs<ExtArgs>
    gamesUpdated?: boolean | user$gamesUpdatedArgs<ExtArgs>
    game_session?: boolean | user$game_sessionArgs<ExtArgs>
    guild?: boolean | user$guildArgs<ExtArgs>
    guild_memberships?: boolean | user$guild_membershipsArgs<ExtArgs>
    messages?: boolean | user$messagesArgs<ExtArgs>
    message_reactions?: boolean | user$message_reactionsArgs<ExtArgs>
    message_reads?: boolean | user$message_readsArgs<ExtArgs>
    room?: boolean | user$roomArgs<ExtArgs>
    room_participations?: boolean | user$room_participationsArgs<ExtArgs>
    room_view?: boolean | user$room_viewArgs<ExtArgs>
    user_settings?: boolean | user$user_settingsArgs<ExtArgs>
    edition_created?: boolean | user$edition_createdArgs<ExtArgs>
    edition_updated?: boolean | user$edition_updatedArgs<ExtArgs>
    table_seats?: boolean | user$table_seatsArgs<ExtArgs>
    game_server_created?: boolean | user$game_server_createdArgs<ExtArgs>
    game_server_updated?: boolean | user$game_server_updatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      channel_memberships: Prisma.$channel_memberPayload<ExtArgs>[]
      event_created: Prisma.$eventPayload<ExtArgs>[]
      event_updated: Prisma.$eventPayload<ExtArgs>[]
      faq_created: Prisma.$faqPayload<ExtArgs>[]
      faq_updated: Prisma.$faqPayload<ExtArgs>[]
      gamesCreated: Prisma.$gamePayload<ExtArgs>[]
      gamesUpdated: Prisma.$gamePayload<ExtArgs>[]
      game_session: Prisma.$game_sessionPayload<ExtArgs>[]
      guild: Prisma.$guildPayload<ExtArgs>[]
      guild_memberships: Prisma.$guild_memberPayload<ExtArgs>[]
      messages: Prisma.$messagePayload<ExtArgs>[]
      message_reactions: Prisma.$message_reactionPayload<ExtArgs>[]
      message_reads: Prisma.$message_readPayload<ExtArgs>[]
      room: Prisma.$roomPayload<ExtArgs>[]
      room_participations: Prisma.$room_participantPayload<ExtArgs>[]
      room_view: Prisma.$room_viewPayload<ExtArgs>[]
      user_settings: Prisma.$user_settingsPayload<ExtArgs> | null
      edition_created: Prisma.$editionPayload<ExtArgs>[]
      edition_updated: Prisma.$editionPayload<ExtArgs>[]
      table_seats: Prisma.$table_seatPayload<ExtArgs>[]
      game_server_created: Prisma.$game_serverPayload<ExtArgs>[]
      game_server_updated: Prisma.$game_serverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      username: string | null
      role: string
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
      displayUsername: string | null
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel_memberships<T extends user$channel_membershipsArgs<ExtArgs> = {}>(args?: Subset<T, user$channel_membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    event_created<T extends user$event_createdArgs<ExtArgs> = {}>(args?: Subset<T, user$event_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    event_updated<T extends user$event_updatedArgs<ExtArgs> = {}>(args?: Subset<T, user$event_updatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faq_created<T extends user$faq_createdArgs<ExtArgs> = {}>(args?: Subset<T, user$faq_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faq_updated<T extends user$faq_updatedArgs<ExtArgs> = {}>(args?: Subset<T, user$faq_updatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gamesCreated<T extends user$gamesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, user$gamesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gamesUpdated<T extends user$gamesUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, user$gamesUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    game_session<T extends user$game_sessionArgs<ExtArgs> = {}>(args?: Subset<T, user$game_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guild<T extends user$guildArgs<ExtArgs> = {}>(args?: Subset<T, user$guildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guild_memberships<T extends user$guild_membershipsArgs<ExtArgs> = {}>(args?: Subset<T, user$guild_membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends user$messagesArgs<ExtArgs> = {}>(args?: Subset<T, user$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message_reactions<T extends user$message_reactionsArgs<ExtArgs> = {}>(args?: Subset<T, user$message_reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message_reads<T extends user$message_readsArgs<ExtArgs> = {}>(args?: Subset<T, user$message_readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room<T extends user$roomArgs<ExtArgs> = {}>(args?: Subset<T, user$roomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room_participations<T extends user$room_participationsArgs<ExtArgs> = {}>(args?: Subset<T, user$room_participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room_view<T extends user$room_viewArgs<ExtArgs> = {}>(args?: Subset<T, user$room_viewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_settings<T extends user$user_settingsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_settingsArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    edition_created<T extends user$edition_createdArgs<ExtArgs> = {}>(args?: Subset<T, user$edition_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    edition_updated<T extends user$edition_updatedArgs<ExtArgs> = {}>(args?: Subset<T, user$edition_updatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    table_seats<T extends user$table_seatsArgs<ExtArgs> = {}>(args?: Subset<T, user$table_seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    game_server_created<T extends user$game_server_createdArgs<ExtArgs> = {}>(args?: Subset<T, user$game_server_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    game_server_updated<T extends user$game_server_updatedArgs<ExtArgs> = {}>(args?: Subset<T, user$game_server_updatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly emailVerified: FieldRef<"user", 'Boolean'>
    readonly image: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
    readonly username: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'String'>
    readonly banned: FieldRef<"user", 'Boolean'>
    readonly banReason: FieldRef<"user", 'String'>
    readonly banExpires: FieldRef<"user", 'DateTime'>
    readonly displayUsername: FieldRef<"user", 'String'>
    readonly lastLogin: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.channel_memberships
   */
  export type user$channel_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    where?: channel_memberWhereInput
    orderBy?: channel_memberOrderByWithRelationInput | channel_memberOrderByWithRelationInput[]
    cursor?: channel_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Channel_memberScalarFieldEnum | Channel_memberScalarFieldEnum[]
  }

  /**
   * user.event_created
   */
  export type user$event_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    where?: eventWhereInput
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    cursor?: eventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * user.event_updated
   */
  export type user$event_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    where?: eventWhereInput
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    cursor?: eventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * user.faq_created
   */
  export type user$faq_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    where?: faqWhereInput
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    cursor?: faqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * user.faq_updated
   */
  export type user$faq_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    where?: faqWhereInput
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    cursor?: faqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * user.gamesCreated
   */
  export type user$gamesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    where?: gameWhereInput
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    cursor?: gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * user.gamesUpdated
   */
  export type user$gamesUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    where?: gameWhereInput
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    cursor?: gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * user.game_session
   */
  export type user$game_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    where?: game_sessionWhereInput
    orderBy?: game_sessionOrderByWithRelationInput | game_sessionOrderByWithRelationInput[]
    cursor?: game_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_sessionScalarFieldEnum | Game_sessionScalarFieldEnum[]
  }

  /**
   * user.guild
   */
  export type user$guildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    where?: guildWhereInput
    orderBy?: guildOrderByWithRelationInput | guildOrderByWithRelationInput[]
    cursor?: guildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * user.guild_memberships
   */
  export type user$guild_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    where?: guild_memberWhereInput
    orderBy?: guild_memberOrderByWithRelationInput | guild_memberOrderByWithRelationInput[]
    cursor?: guild_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Guild_memberScalarFieldEnum | Guild_memberScalarFieldEnum[]
  }

  /**
   * user.messages
   */
  export type user$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * user.message_reactions
   */
  export type user$message_reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    where?: message_reactionWhereInput
    orderBy?: message_reactionOrderByWithRelationInput | message_reactionOrderByWithRelationInput[]
    cursor?: message_reactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Message_reactionScalarFieldEnum | Message_reactionScalarFieldEnum[]
  }

  /**
   * user.message_reads
   */
  export type user$message_readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    where?: message_readWhereInput
    orderBy?: message_readOrderByWithRelationInput | message_readOrderByWithRelationInput[]
    cursor?: message_readWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Message_readScalarFieldEnum | Message_readScalarFieldEnum[]
  }

  /**
   * user.room
   */
  export type user$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    where?: roomWhereInput
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    cursor?: roomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * user.room_participations
   */
  export type user$room_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    where?: room_participantWhereInput
    orderBy?: room_participantOrderByWithRelationInput | room_participantOrderByWithRelationInput[]
    cursor?: room_participantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Room_participantScalarFieldEnum | Room_participantScalarFieldEnum[]
  }

  /**
   * user.room_view
   */
  export type user$room_viewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    where?: room_viewWhereInput
    orderBy?: room_viewOrderByWithRelationInput | room_viewOrderByWithRelationInput[]
    cursor?: room_viewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Room_viewScalarFieldEnum | Room_viewScalarFieldEnum[]
  }

  /**
   * user.user_settings
   */
  export type user$user_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    where?: user_settingsWhereInput
  }

  /**
   * user.edition_created
   */
  export type user$edition_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    where?: editionWhereInput
    orderBy?: editionOrderByWithRelationInput | editionOrderByWithRelationInput[]
    cursor?: editionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * user.edition_updated
   */
  export type user$edition_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    where?: editionWhereInput
    orderBy?: editionOrderByWithRelationInput | editionOrderByWithRelationInput[]
    cursor?: editionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * user.table_seats
   */
  export type user$table_seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    where?: table_seatWhereInput
    orderBy?: table_seatOrderByWithRelationInput | table_seatOrderByWithRelationInput[]
    cursor?: table_seatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Table_seatScalarFieldEnum | Table_seatScalarFieldEnum[]
  }

  /**
   * user.game_server_created
   */
  export type user$game_server_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    where?: game_serverWhereInput
    orderBy?: game_serverOrderByWithRelationInput | game_serverOrderByWithRelationInput[]
    cursor?: game_serverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_serverScalarFieldEnum | Game_serverScalarFieldEnum[]
  }

  /**
   * user.game_server_updated
   */
  export type user$game_server_updatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    where?: game_serverWhereInput
    orderBy?: game_serverOrderByWithRelationInput | game_serverOrderByWithRelationInput[]
    cursor?: game_serverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_serverScalarFieldEnum | Game_serverScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification to aggregate.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type verificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: verificationWhereInput
    orderBy?: verificationOrderByWithAggregationInput | verificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: verificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends verificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type verificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>



  export type verificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type verificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $verificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type verificationGetPayload<S extends boolean | null | undefined | verificationDefaultArgs> = $Result.GetResult<Prisma.$verificationPayload, S>

  type verificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<verificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface verificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['verification'], meta: { name: 'verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {verificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends verificationFindUniqueArgs>(args: SelectSubset<T, verificationFindUniqueArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {verificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends verificationFindUniqueOrThrowArgs>(args: SelectSubset<T, verificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends verificationFindFirstArgs>(args?: SelectSubset<T, verificationFindFirstArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends verificationFindFirstOrThrowArgs>(args?: SelectSubset<T, verificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends verificationFindManyArgs>(args?: SelectSubset<T, verificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {verificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends verificationCreateArgs>(args: SelectSubset<T, verificationCreateArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {verificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends verificationCreateManyArgs>(args?: SelectSubset<T, verificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Verification.
     * @param {verificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends verificationDeleteArgs>(args: SelectSubset<T, verificationDeleteArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {verificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends verificationUpdateArgs>(args: SelectSubset<T, verificationUpdateArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {verificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends verificationDeleteManyArgs>(args?: SelectSubset<T, verificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends verificationUpdateManyArgs>(args: SelectSubset<T, verificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {verificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends verificationUpsertArgs>(args: SelectSubset<T, verificationUpsertArgs<ExtArgs>>): Prisma__verificationClient<$Result.GetResult<Prisma.$verificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends verificationCountArgs>(
      args?: Subset<T, verificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends verificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: verificationGroupByArgs['orderBy'] }
        : { orderBy?: verificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, verificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the verification model
   */
  readonly fields: verificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__verificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the verification model
   */
  interface verificationFieldRefs {
    readonly id: FieldRef<"verification", 'String'>
    readonly identifier: FieldRef<"verification", 'String'>
    readonly value: FieldRef<"verification", 'String'>
    readonly expiresAt: FieldRef<"verification", 'DateTime'>
    readonly createdAt: FieldRef<"verification", 'DateTime'>
    readonly updatedAt: FieldRef<"verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * verification findUnique
   */
  export type verificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification findUniqueOrThrow
   */
  export type verificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification findFirst
   */
  export type verificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification findFirstOrThrow
   */
  export type verificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification findMany
   */
  export type verificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter, which verifications to fetch.
     */
    where?: verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing verifications.
     */
    cursor?: verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * verification create
   */
  export type verificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The data needed to create a verification.
     */
    data: XOR<verificationCreateInput, verificationUncheckedCreateInput>
  }

  /**
   * verification createMany
   */
  export type verificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many verifications.
     */
    data: verificationCreateManyInput | verificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * verification update
   */
  export type verificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The data needed to update a verification.
     */
    data: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>
    /**
     * Choose, which verification to update.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification updateMany
   */
  export type verificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update verifications.
     */
    data: XOR<verificationUpdateManyMutationInput, verificationUncheckedUpdateManyInput>
    /**
     * Filter which verifications to update
     */
    where?: verificationWhereInput
    /**
     * Limit how many verifications to update.
     */
    limit?: number
  }

  /**
   * verification upsert
   */
  export type verificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * The filter to search for the verification to update in case it exists.
     */
    where: verificationWhereUniqueInput
    /**
     * In case the verification found by the `where` argument doesn't exist, create a new verification with this data.
     */
    create: XOR<verificationCreateInput, verificationUncheckedCreateInput>
    /**
     * In case the verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>
  }

  /**
   * verification delete
   */
  export type verificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
    /**
     * Filter which verification to delete.
     */
    where: verificationWhereUniqueInput
  }

  /**
   * verification deleteMany
   */
  export type verificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verifications to delete
     */
    where?: verificationWhereInput
    /**
     * Limit how many verifications to delete.
     */
    limit?: number
  }

  /**
   * verification without action
   */
  export type verificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null
  }


  /**
   * Model sidelink
   */

  export type AggregateSidelink = {
    _count: SidelinkCountAggregateOutputType | null
    _avg: SidelinkAvgAggregateOutputType | null
    _sum: SidelinkSumAggregateOutputType | null
    _min: SidelinkMinAggregateOutputType | null
    _max: SidelinkMaxAggregateOutputType | null
  }

  export type SidelinkAvgAggregateOutputType = {
    id: number | null
  }

  export type SidelinkSumAggregateOutputType = {
    id: number | null
  }

  export type SidelinkMinAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    hidden: boolean | null
  }

  export type SidelinkMaxAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    hidden: boolean | null
  }

  export type SidelinkCountAggregateOutputType = {
    id: number
    name: number
    url: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    hidden: number
    _all: number
  }


  export type SidelinkAvgAggregateInputType = {
    id?: true
  }

  export type SidelinkSumAggregateInputType = {
    id?: true
  }

  export type SidelinkMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    hidden?: true
  }

  export type SidelinkMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    hidden?: true
  }

  export type SidelinkCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    hidden?: true
    _all?: true
  }

  export type SidelinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sidelink to aggregate.
     */
    where?: sidelinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sidelinks to fetch.
     */
    orderBy?: sidelinkOrderByWithRelationInput | sidelinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sidelinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sidelinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sidelinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sidelinks
    **/
    _count?: true | SidelinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SidelinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SidelinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SidelinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SidelinkMaxAggregateInputType
  }

  export type GetSidelinkAggregateType<T extends SidelinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSidelink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSidelink[P]>
      : GetScalarType<T[P], AggregateSidelink[P]>
  }




  export type sidelinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sidelinkWhereInput
    orderBy?: sidelinkOrderByWithAggregationInput | sidelinkOrderByWithAggregationInput[]
    by: SidelinkScalarFieldEnum[] | SidelinkScalarFieldEnum
    having?: sidelinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SidelinkCountAggregateInputType | true
    _avg?: SidelinkAvgAggregateInputType
    _sum?: SidelinkSumAggregateInputType
    _min?: SidelinkMinAggregateInputType
    _max?: SidelinkMaxAggregateInputType
  }

  export type SidelinkGroupByOutputType = {
    id: number
    name: string
    url: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string
    hidden: boolean
    _count: SidelinkCountAggregateOutputType | null
    _avg: SidelinkAvgAggregateOutputType | null
    _sum: SidelinkSumAggregateOutputType | null
    _min: SidelinkMinAggregateOutputType | null
    _max: SidelinkMaxAggregateOutputType | null
  }

  type GetSidelinkGroupByPayload<T extends sidelinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SidelinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SidelinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SidelinkGroupByOutputType[P]>
            : GetScalarType<T[P], SidelinkGroupByOutputType[P]>
        }
      >
    >


  export type sidelinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    hidden?: boolean
  }, ExtArgs["result"]["sidelink"]>



  export type sidelinkSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    hidden?: boolean
  }

  export type sidelinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "hidden", ExtArgs["result"]["sidelink"]>

  export type $sidelinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sidelink"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      url: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string
      hidden: boolean
    }, ExtArgs["result"]["sidelink"]>
    composites: {}
  }

  type sidelinkGetPayload<S extends boolean | null | undefined | sidelinkDefaultArgs> = $Result.GetResult<Prisma.$sidelinkPayload, S>

  type sidelinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sidelinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SidelinkCountAggregateInputType | true
    }

  export interface sidelinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sidelink'], meta: { name: 'sidelink' } }
    /**
     * Find zero or one Sidelink that matches the filter.
     * @param {sidelinkFindUniqueArgs} args - Arguments to find a Sidelink
     * @example
     * // Get one Sidelink
     * const sidelink = await prisma.sidelink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sidelinkFindUniqueArgs>(args: SelectSubset<T, sidelinkFindUniqueArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sidelink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sidelinkFindUniqueOrThrowArgs} args - Arguments to find a Sidelink
     * @example
     * // Get one Sidelink
     * const sidelink = await prisma.sidelink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sidelinkFindUniqueOrThrowArgs>(args: SelectSubset<T, sidelinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sidelink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sidelinkFindFirstArgs} args - Arguments to find a Sidelink
     * @example
     * // Get one Sidelink
     * const sidelink = await prisma.sidelink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sidelinkFindFirstArgs>(args?: SelectSubset<T, sidelinkFindFirstArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sidelink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sidelinkFindFirstOrThrowArgs} args - Arguments to find a Sidelink
     * @example
     * // Get one Sidelink
     * const sidelink = await prisma.sidelink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sidelinkFindFirstOrThrowArgs>(args?: SelectSubset<T, sidelinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sidelinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sidelinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sidelinks
     * const sidelinks = await prisma.sidelink.findMany()
     * 
     * // Get first 10 Sidelinks
     * const sidelinks = await prisma.sidelink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sidelinkWithIdOnly = await prisma.sidelink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sidelinkFindManyArgs>(args?: SelectSubset<T, sidelinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sidelink.
     * @param {sidelinkCreateArgs} args - Arguments to create a Sidelink.
     * @example
     * // Create one Sidelink
     * const Sidelink = await prisma.sidelink.create({
     *   data: {
     *     // ... data to create a Sidelink
     *   }
     * })
     * 
     */
    create<T extends sidelinkCreateArgs>(args: SelectSubset<T, sidelinkCreateArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sidelinks.
     * @param {sidelinkCreateManyArgs} args - Arguments to create many Sidelinks.
     * @example
     * // Create many Sidelinks
     * const sidelink = await prisma.sidelink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sidelinkCreateManyArgs>(args?: SelectSubset<T, sidelinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sidelink.
     * @param {sidelinkDeleteArgs} args - Arguments to delete one Sidelink.
     * @example
     * // Delete one Sidelink
     * const Sidelink = await prisma.sidelink.delete({
     *   where: {
     *     // ... filter to delete one Sidelink
     *   }
     * })
     * 
     */
    delete<T extends sidelinkDeleteArgs>(args: SelectSubset<T, sidelinkDeleteArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sidelink.
     * @param {sidelinkUpdateArgs} args - Arguments to update one Sidelink.
     * @example
     * // Update one Sidelink
     * const sidelink = await prisma.sidelink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sidelinkUpdateArgs>(args: SelectSubset<T, sidelinkUpdateArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sidelinks.
     * @param {sidelinkDeleteManyArgs} args - Arguments to filter Sidelinks to delete.
     * @example
     * // Delete a few Sidelinks
     * const { count } = await prisma.sidelink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sidelinkDeleteManyArgs>(args?: SelectSubset<T, sidelinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sidelinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sidelinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sidelinks
     * const sidelink = await prisma.sidelink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sidelinkUpdateManyArgs>(args: SelectSubset<T, sidelinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sidelink.
     * @param {sidelinkUpsertArgs} args - Arguments to update or create a Sidelink.
     * @example
     * // Update or create a Sidelink
     * const sidelink = await prisma.sidelink.upsert({
     *   create: {
     *     // ... data to create a Sidelink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sidelink we want to update
     *   }
     * })
     */
    upsert<T extends sidelinkUpsertArgs>(args: SelectSubset<T, sidelinkUpsertArgs<ExtArgs>>): Prisma__sidelinkClient<$Result.GetResult<Prisma.$sidelinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sidelinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sidelinkCountArgs} args - Arguments to filter Sidelinks to count.
     * @example
     * // Count the number of Sidelinks
     * const count = await prisma.sidelink.count({
     *   where: {
     *     // ... the filter for the Sidelinks we want to count
     *   }
     * })
    **/
    count<T extends sidelinkCountArgs>(
      args?: Subset<T, sidelinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SidelinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sidelink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SidelinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SidelinkAggregateArgs>(args: Subset<T, SidelinkAggregateArgs>): Prisma.PrismaPromise<GetSidelinkAggregateType<T>>

    /**
     * Group by Sidelink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sidelinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sidelinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sidelinkGroupByArgs['orderBy'] }
        : { orderBy?: sidelinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sidelinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSidelinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sidelink model
   */
  readonly fields: sidelinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sidelink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sidelinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sidelink model
   */
  interface sidelinkFieldRefs {
    readonly id: FieldRef<"sidelink", 'Int'>
    readonly name: FieldRef<"sidelink", 'String'>
    readonly url: FieldRef<"sidelink", 'String'>
    readonly createdAt: FieldRef<"sidelink", 'DateTime'>
    readonly updatedAt: FieldRef<"sidelink", 'DateTime'>
    readonly createdBy: FieldRef<"sidelink", 'String'>
    readonly updatedBy: FieldRef<"sidelink", 'String'>
    readonly hidden: FieldRef<"sidelink", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * sidelink findUnique
   */
  export type sidelinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * Filter, which sidelink to fetch.
     */
    where: sidelinkWhereUniqueInput
  }

  /**
   * sidelink findUniqueOrThrow
   */
  export type sidelinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * Filter, which sidelink to fetch.
     */
    where: sidelinkWhereUniqueInput
  }

  /**
   * sidelink findFirst
   */
  export type sidelinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * Filter, which sidelink to fetch.
     */
    where?: sidelinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sidelinks to fetch.
     */
    orderBy?: sidelinkOrderByWithRelationInput | sidelinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sidelinks.
     */
    cursor?: sidelinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sidelinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sidelinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sidelinks.
     */
    distinct?: SidelinkScalarFieldEnum | SidelinkScalarFieldEnum[]
  }

  /**
   * sidelink findFirstOrThrow
   */
  export type sidelinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * Filter, which sidelink to fetch.
     */
    where?: sidelinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sidelinks to fetch.
     */
    orderBy?: sidelinkOrderByWithRelationInput | sidelinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sidelinks.
     */
    cursor?: sidelinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sidelinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sidelinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sidelinks.
     */
    distinct?: SidelinkScalarFieldEnum | SidelinkScalarFieldEnum[]
  }

  /**
   * sidelink findMany
   */
  export type sidelinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * Filter, which sidelinks to fetch.
     */
    where?: sidelinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sidelinks to fetch.
     */
    orderBy?: sidelinkOrderByWithRelationInput | sidelinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sidelinks.
     */
    cursor?: sidelinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sidelinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sidelinks.
     */
    skip?: number
    distinct?: SidelinkScalarFieldEnum | SidelinkScalarFieldEnum[]
  }

  /**
   * sidelink create
   */
  export type sidelinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * The data needed to create a sidelink.
     */
    data: XOR<sidelinkCreateInput, sidelinkUncheckedCreateInput>
  }

  /**
   * sidelink createMany
   */
  export type sidelinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sidelinks.
     */
    data: sidelinkCreateManyInput | sidelinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sidelink update
   */
  export type sidelinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * The data needed to update a sidelink.
     */
    data: XOR<sidelinkUpdateInput, sidelinkUncheckedUpdateInput>
    /**
     * Choose, which sidelink to update.
     */
    where: sidelinkWhereUniqueInput
  }

  /**
   * sidelink updateMany
   */
  export type sidelinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sidelinks.
     */
    data: XOR<sidelinkUpdateManyMutationInput, sidelinkUncheckedUpdateManyInput>
    /**
     * Filter which sidelinks to update
     */
    where?: sidelinkWhereInput
    /**
     * Limit how many sidelinks to update.
     */
    limit?: number
  }

  /**
   * sidelink upsert
   */
  export type sidelinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * The filter to search for the sidelink to update in case it exists.
     */
    where: sidelinkWhereUniqueInput
    /**
     * In case the sidelink found by the `where` argument doesn't exist, create a new sidelink with this data.
     */
    create: XOR<sidelinkCreateInput, sidelinkUncheckedCreateInput>
    /**
     * In case the sidelink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sidelinkUpdateInput, sidelinkUncheckedUpdateInput>
  }

  /**
   * sidelink delete
   */
  export type sidelinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
    /**
     * Filter which sidelink to delete.
     */
    where: sidelinkWhereUniqueInput
  }

  /**
   * sidelink deleteMany
   */
  export type sidelinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sidelinks to delete
     */
    where?: sidelinkWhereInput
    /**
     * Limit how many sidelinks to delete.
     */
    limit?: number
  }

  /**
   * sidelink without action
   */
  export type sidelinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sidelink
     */
    select?: sidelinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sidelink
     */
    omit?: sidelinkOmit<ExtArgs> | null
  }


  /**
   * Model username_file_config
   */

  export type AggregateUsername_file_config = {
    _count: Username_file_configCountAggregateOutputType | null
    _avg: Username_file_configAvgAggregateOutputType | null
    _sum: Username_file_configSumAggregateOutputType | null
    _min: Username_file_configMinAggregateOutputType | null
    _max: Username_file_configMaxAggregateOutputType | null
  }

  export type Username_file_configAvgAggregateOutputType = {
    id: number | null
  }

  export type Username_file_configSumAggregateOutputType = {
    id: number | null
  }

  export type Username_file_configMinAggregateOutputType = {
    id: number | null
    folder_slug: string | null
    path: string | null
    variable: string | null
    config_type: string | null
  }

  export type Username_file_configMaxAggregateOutputType = {
    id: number | null
    folder_slug: string | null
    path: string | null
    variable: string | null
    config_type: string | null
  }

  export type Username_file_configCountAggregateOutputType = {
    id: number
    folder_slug: number
    path: number
    variable: number
    config_type: number
    _all: number
  }


  export type Username_file_configAvgAggregateInputType = {
    id?: true
  }

  export type Username_file_configSumAggregateInputType = {
    id?: true
  }

  export type Username_file_configMinAggregateInputType = {
    id?: true
    folder_slug?: true
    path?: true
    variable?: true
    config_type?: true
  }

  export type Username_file_configMaxAggregateInputType = {
    id?: true
    folder_slug?: true
    path?: true
    variable?: true
    config_type?: true
  }

  export type Username_file_configCountAggregateInputType = {
    id?: true
    folder_slug?: true
    path?: true
    variable?: true
    config_type?: true
    _all?: true
  }

  export type Username_file_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which username_file_config to aggregate.
     */
    where?: username_file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of username_file_configs to fetch.
     */
    orderBy?: username_file_configOrderByWithRelationInput | username_file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: username_file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` username_file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` username_file_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned username_file_configs
    **/
    _count?: true | Username_file_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Username_file_configAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Username_file_configSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Username_file_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Username_file_configMaxAggregateInputType
  }

  export type GetUsername_file_configAggregateType<T extends Username_file_configAggregateArgs> = {
        [P in keyof T & keyof AggregateUsername_file_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsername_file_config[P]>
      : GetScalarType<T[P], AggregateUsername_file_config[P]>
  }




  export type username_file_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: username_file_configWhereInput
    orderBy?: username_file_configOrderByWithAggregationInput | username_file_configOrderByWithAggregationInput[]
    by: Username_file_configScalarFieldEnum[] | Username_file_configScalarFieldEnum
    having?: username_file_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Username_file_configCountAggregateInputType | true
    _avg?: Username_file_configAvgAggregateInputType
    _sum?: Username_file_configSumAggregateInputType
    _min?: Username_file_configMinAggregateInputType
    _max?: Username_file_configMaxAggregateInputType
  }

  export type Username_file_configGroupByOutputType = {
    id: number
    folder_slug: string | null
    path: string | null
    variable: string | null
    config_type: string | null
    _count: Username_file_configCountAggregateOutputType | null
    _avg: Username_file_configAvgAggregateOutputType | null
    _sum: Username_file_configSumAggregateOutputType | null
    _min: Username_file_configMinAggregateOutputType | null
    _max: Username_file_configMaxAggregateOutputType | null
  }

  type GetUsername_file_configGroupByPayload<T extends username_file_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Username_file_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Username_file_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Username_file_configGroupByOutputType[P]>
            : GetScalarType<T[P], Username_file_configGroupByOutputType[P]>
        }
      >
    >


  export type username_file_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folder_slug?: boolean
    path?: boolean
    variable?: boolean
    config_type?: boolean
  }, ExtArgs["result"]["username_file_config"]>



  export type username_file_configSelectScalar = {
    id?: boolean
    folder_slug?: boolean
    path?: boolean
    variable?: boolean
    config_type?: boolean
  }

  export type username_file_configOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "folder_slug" | "path" | "variable" | "config_type", ExtArgs["result"]["username_file_config"]>

  export type $username_file_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "username_file_config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      folder_slug: string | null
      path: string | null
      variable: string | null
      config_type: string | null
    }, ExtArgs["result"]["username_file_config"]>
    composites: {}
  }

  type username_file_configGetPayload<S extends boolean | null | undefined | username_file_configDefaultArgs> = $Result.GetResult<Prisma.$username_file_configPayload, S>

  type username_file_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<username_file_configFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Username_file_configCountAggregateInputType | true
    }

  export interface username_file_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['username_file_config'], meta: { name: 'username_file_config' } }
    /**
     * Find zero or one Username_file_config that matches the filter.
     * @param {username_file_configFindUniqueArgs} args - Arguments to find a Username_file_config
     * @example
     * // Get one Username_file_config
     * const username_file_config = await prisma.username_file_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends username_file_configFindUniqueArgs>(args: SelectSubset<T, username_file_configFindUniqueArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Username_file_config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {username_file_configFindUniqueOrThrowArgs} args - Arguments to find a Username_file_config
     * @example
     * // Get one Username_file_config
     * const username_file_config = await prisma.username_file_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends username_file_configFindUniqueOrThrowArgs>(args: SelectSubset<T, username_file_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Username_file_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {username_file_configFindFirstArgs} args - Arguments to find a Username_file_config
     * @example
     * // Get one Username_file_config
     * const username_file_config = await prisma.username_file_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends username_file_configFindFirstArgs>(args?: SelectSubset<T, username_file_configFindFirstArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Username_file_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {username_file_configFindFirstOrThrowArgs} args - Arguments to find a Username_file_config
     * @example
     * // Get one Username_file_config
     * const username_file_config = await prisma.username_file_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends username_file_configFindFirstOrThrowArgs>(args?: SelectSubset<T, username_file_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Username_file_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {username_file_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Username_file_configs
     * const username_file_configs = await prisma.username_file_config.findMany()
     * 
     * // Get first 10 Username_file_configs
     * const username_file_configs = await prisma.username_file_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const username_file_configWithIdOnly = await prisma.username_file_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends username_file_configFindManyArgs>(args?: SelectSubset<T, username_file_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Username_file_config.
     * @param {username_file_configCreateArgs} args - Arguments to create a Username_file_config.
     * @example
     * // Create one Username_file_config
     * const Username_file_config = await prisma.username_file_config.create({
     *   data: {
     *     // ... data to create a Username_file_config
     *   }
     * })
     * 
     */
    create<T extends username_file_configCreateArgs>(args: SelectSubset<T, username_file_configCreateArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Username_file_configs.
     * @param {username_file_configCreateManyArgs} args - Arguments to create many Username_file_configs.
     * @example
     * // Create many Username_file_configs
     * const username_file_config = await prisma.username_file_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends username_file_configCreateManyArgs>(args?: SelectSubset<T, username_file_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Username_file_config.
     * @param {username_file_configDeleteArgs} args - Arguments to delete one Username_file_config.
     * @example
     * // Delete one Username_file_config
     * const Username_file_config = await prisma.username_file_config.delete({
     *   where: {
     *     // ... filter to delete one Username_file_config
     *   }
     * })
     * 
     */
    delete<T extends username_file_configDeleteArgs>(args: SelectSubset<T, username_file_configDeleteArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Username_file_config.
     * @param {username_file_configUpdateArgs} args - Arguments to update one Username_file_config.
     * @example
     * // Update one Username_file_config
     * const username_file_config = await prisma.username_file_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends username_file_configUpdateArgs>(args: SelectSubset<T, username_file_configUpdateArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Username_file_configs.
     * @param {username_file_configDeleteManyArgs} args - Arguments to filter Username_file_configs to delete.
     * @example
     * // Delete a few Username_file_configs
     * const { count } = await prisma.username_file_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends username_file_configDeleteManyArgs>(args?: SelectSubset<T, username_file_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Username_file_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {username_file_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Username_file_configs
     * const username_file_config = await prisma.username_file_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends username_file_configUpdateManyArgs>(args: SelectSubset<T, username_file_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Username_file_config.
     * @param {username_file_configUpsertArgs} args - Arguments to update or create a Username_file_config.
     * @example
     * // Update or create a Username_file_config
     * const username_file_config = await prisma.username_file_config.upsert({
     *   create: {
     *     // ... data to create a Username_file_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Username_file_config we want to update
     *   }
     * })
     */
    upsert<T extends username_file_configUpsertArgs>(args: SelectSubset<T, username_file_configUpsertArgs<ExtArgs>>): Prisma__username_file_configClient<$Result.GetResult<Prisma.$username_file_configPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Username_file_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {username_file_configCountArgs} args - Arguments to filter Username_file_configs to count.
     * @example
     * // Count the number of Username_file_configs
     * const count = await prisma.username_file_config.count({
     *   where: {
     *     // ... the filter for the Username_file_configs we want to count
     *   }
     * })
    **/
    count<T extends username_file_configCountArgs>(
      args?: Subset<T, username_file_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Username_file_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Username_file_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Username_file_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Username_file_configAggregateArgs>(args: Subset<T, Username_file_configAggregateArgs>): Prisma.PrismaPromise<GetUsername_file_configAggregateType<T>>

    /**
     * Group by Username_file_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {username_file_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends username_file_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: username_file_configGroupByArgs['orderBy'] }
        : { orderBy?: username_file_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, username_file_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsername_file_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the username_file_config model
   */
  readonly fields: username_file_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for username_file_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__username_file_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the username_file_config model
   */
  interface username_file_configFieldRefs {
    readonly id: FieldRef<"username_file_config", 'Int'>
    readonly folder_slug: FieldRef<"username_file_config", 'String'>
    readonly path: FieldRef<"username_file_config", 'String'>
    readonly variable: FieldRef<"username_file_config", 'String'>
    readonly config_type: FieldRef<"username_file_config", 'String'>
  }
    

  // Custom InputTypes
  /**
   * username_file_config findUnique
   */
  export type username_file_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * Filter, which username_file_config to fetch.
     */
    where: username_file_configWhereUniqueInput
  }

  /**
   * username_file_config findUniqueOrThrow
   */
  export type username_file_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * Filter, which username_file_config to fetch.
     */
    where: username_file_configWhereUniqueInput
  }

  /**
   * username_file_config findFirst
   */
  export type username_file_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * Filter, which username_file_config to fetch.
     */
    where?: username_file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of username_file_configs to fetch.
     */
    orderBy?: username_file_configOrderByWithRelationInput | username_file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for username_file_configs.
     */
    cursor?: username_file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` username_file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` username_file_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of username_file_configs.
     */
    distinct?: Username_file_configScalarFieldEnum | Username_file_configScalarFieldEnum[]
  }

  /**
   * username_file_config findFirstOrThrow
   */
  export type username_file_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * Filter, which username_file_config to fetch.
     */
    where?: username_file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of username_file_configs to fetch.
     */
    orderBy?: username_file_configOrderByWithRelationInput | username_file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for username_file_configs.
     */
    cursor?: username_file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` username_file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` username_file_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of username_file_configs.
     */
    distinct?: Username_file_configScalarFieldEnum | Username_file_configScalarFieldEnum[]
  }

  /**
   * username_file_config findMany
   */
  export type username_file_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * Filter, which username_file_configs to fetch.
     */
    where?: username_file_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of username_file_configs to fetch.
     */
    orderBy?: username_file_configOrderByWithRelationInput | username_file_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing username_file_configs.
     */
    cursor?: username_file_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` username_file_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` username_file_configs.
     */
    skip?: number
    distinct?: Username_file_configScalarFieldEnum | Username_file_configScalarFieldEnum[]
  }

  /**
   * username_file_config create
   */
  export type username_file_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * The data needed to create a username_file_config.
     */
    data?: XOR<username_file_configCreateInput, username_file_configUncheckedCreateInput>
  }

  /**
   * username_file_config createMany
   */
  export type username_file_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many username_file_configs.
     */
    data: username_file_configCreateManyInput | username_file_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * username_file_config update
   */
  export type username_file_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * The data needed to update a username_file_config.
     */
    data: XOR<username_file_configUpdateInput, username_file_configUncheckedUpdateInput>
    /**
     * Choose, which username_file_config to update.
     */
    where: username_file_configWhereUniqueInput
  }

  /**
   * username_file_config updateMany
   */
  export type username_file_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update username_file_configs.
     */
    data: XOR<username_file_configUpdateManyMutationInput, username_file_configUncheckedUpdateManyInput>
    /**
     * Filter which username_file_configs to update
     */
    where?: username_file_configWhereInput
    /**
     * Limit how many username_file_configs to update.
     */
    limit?: number
  }

  /**
   * username_file_config upsert
   */
  export type username_file_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * The filter to search for the username_file_config to update in case it exists.
     */
    where: username_file_configWhereUniqueInput
    /**
     * In case the username_file_config found by the `where` argument doesn't exist, create a new username_file_config with this data.
     */
    create: XOR<username_file_configCreateInput, username_file_configUncheckedCreateInput>
    /**
     * In case the username_file_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<username_file_configUpdateInput, username_file_configUncheckedUpdateInput>
  }

  /**
   * username_file_config delete
   */
  export type username_file_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
    /**
     * Filter which username_file_config to delete.
     */
    where: username_file_configWhereUniqueInput
  }

  /**
   * username_file_config deleteMany
   */
  export type username_file_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which username_file_configs to delete
     */
    where?: username_file_configWhereInput
    /**
     * Limit how many username_file_configs to delete.
     */
    limit?: number
  }

  /**
   * username_file_config without action
   */
  export type username_file_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the username_file_config
     */
    select?: username_file_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the username_file_config
     */
    omit?: username_file_configOmit<ExtArgs> | null
  }


  /**
   * Model user_settings
   */

  export type AggregateUser_settings = {
    _count: User_settingsCountAggregateOutputType | null
    _avg: User_settingsAvgAggregateOutputType | null
    _sum: User_settingsSumAggregateOutputType | null
    _min: User_settingsMinAggregateOutputType | null
    _max: User_settingsMaxAggregateOutputType | null
  }

  export type User_settingsAvgAggregateOutputType = {
    id: number | null
  }

  export type User_settingsSumAggregateOutputType = {
    id: number | null
  }

  export type User_settingsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    local_games_dir: string | null
  }

  export type User_settingsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    local_games_dir: string | null
  }

  export type User_settingsCountAggregateOutputType = {
    id: number
    user_id: number
    local_games_dir: number
    _all: number
  }


  export type User_settingsAvgAggregateInputType = {
    id?: true
  }

  export type User_settingsSumAggregateInputType = {
    id?: true
  }

  export type User_settingsMinAggregateInputType = {
    id?: true
    user_id?: true
    local_games_dir?: true
  }

  export type User_settingsMaxAggregateInputType = {
    id?: true
    user_id?: true
    local_games_dir?: true
  }

  export type User_settingsCountAggregateInputType = {
    id?: true
    user_id?: true
    local_games_dir?: true
    _all?: true
  }

  export type User_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_settings to aggregate.
     */
    where?: user_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_settings to fetch.
     */
    orderBy?: user_settingsOrderByWithRelationInput | user_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_settings
    **/
    _count?: true | User_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_settingsMaxAggregateInputType
  }

  export type GetUser_settingsAggregateType<T extends User_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_settings[P]>
      : GetScalarType<T[P], AggregateUser_settings[P]>
  }




  export type user_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_settingsWhereInput
    orderBy?: user_settingsOrderByWithAggregationInput | user_settingsOrderByWithAggregationInput[]
    by: User_settingsScalarFieldEnum[] | User_settingsScalarFieldEnum
    having?: user_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_settingsCountAggregateInputType | true
    _avg?: User_settingsAvgAggregateInputType
    _sum?: User_settingsSumAggregateInputType
    _min?: User_settingsMinAggregateInputType
    _max?: User_settingsMaxAggregateInputType
  }

  export type User_settingsGroupByOutputType = {
    id: number
    user_id: string
    local_games_dir: string
    _count: User_settingsCountAggregateOutputType | null
    _avg: User_settingsAvgAggregateOutputType | null
    _sum: User_settingsSumAggregateOutputType | null
    _min: User_settingsMinAggregateOutputType | null
    _max: User_settingsMaxAggregateOutputType | null
  }

  type GetUser_settingsGroupByPayload<T extends user_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], User_settingsGroupByOutputType[P]>
        }
      >
    >


  export type user_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    local_games_dir?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_settings"]>



  export type user_settingsSelectScalar = {
    id?: boolean
    user_id?: boolean
    local_games_dir?: boolean
  }

  export type user_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "local_games_dir", ExtArgs["result"]["user_settings"]>
  export type user_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $user_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_settings"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      local_games_dir: string
    }, ExtArgs["result"]["user_settings"]>
    composites: {}
  }

  type user_settingsGetPayload<S extends boolean | null | undefined | user_settingsDefaultArgs> = $Result.GetResult<Prisma.$user_settingsPayload, S>

  type user_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_settingsCountAggregateInputType | true
    }

  export interface user_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_settings'], meta: { name: 'user_settings' } }
    /**
     * Find zero or one User_settings that matches the filter.
     * @param {user_settingsFindUniqueArgs} args - Arguments to find a User_settings
     * @example
     * // Get one User_settings
     * const user_settings = await prisma.user_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_settingsFindUniqueArgs>(args: SelectSubset<T, user_settingsFindUniqueArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_settingsFindUniqueOrThrowArgs} args - Arguments to find a User_settings
     * @example
     * // Get one User_settings
     * const user_settings = await prisma.user_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_settingsFindFirstArgs} args - Arguments to find a User_settings
     * @example
     * // Get one User_settings
     * const user_settings = await prisma.user_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_settingsFindFirstArgs>(args?: SelectSubset<T, user_settingsFindFirstArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_settingsFindFirstOrThrowArgs} args - Arguments to find a User_settings
     * @example
     * // Get one User_settings
     * const user_settings = await prisma.user_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_settings
     * const user_settings = await prisma.user_settings.findMany()
     * 
     * // Get first 10 User_settings
     * const user_settings = await prisma.user_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_settingsWithIdOnly = await prisma.user_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_settingsFindManyArgs>(args?: SelectSubset<T, user_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_settings.
     * @param {user_settingsCreateArgs} args - Arguments to create a User_settings.
     * @example
     * // Create one User_settings
     * const User_settings = await prisma.user_settings.create({
     *   data: {
     *     // ... data to create a User_settings
     *   }
     * })
     * 
     */
    create<T extends user_settingsCreateArgs>(args: SelectSubset<T, user_settingsCreateArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_settings.
     * @param {user_settingsCreateManyArgs} args - Arguments to create many User_settings.
     * @example
     * // Create many User_settings
     * const user_settings = await prisma.user_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_settingsCreateManyArgs>(args?: SelectSubset<T, user_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_settings.
     * @param {user_settingsDeleteArgs} args - Arguments to delete one User_settings.
     * @example
     * // Delete one User_settings
     * const User_settings = await prisma.user_settings.delete({
     *   where: {
     *     // ... filter to delete one User_settings
     *   }
     * })
     * 
     */
    delete<T extends user_settingsDeleteArgs>(args: SelectSubset<T, user_settingsDeleteArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_settings.
     * @param {user_settingsUpdateArgs} args - Arguments to update one User_settings.
     * @example
     * // Update one User_settings
     * const user_settings = await prisma.user_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_settingsUpdateArgs>(args: SelectSubset<T, user_settingsUpdateArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_settings.
     * @param {user_settingsDeleteManyArgs} args - Arguments to filter User_settings to delete.
     * @example
     * // Delete a few User_settings
     * const { count } = await prisma.user_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_settingsDeleteManyArgs>(args?: SelectSubset<T, user_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_settings
     * const user_settings = await prisma.user_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_settingsUpdateManyArgs>(args: SelectSubset<T, user_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_settings.
     * @param {user_settingsUpsertArgs} args - Arguments to update or create a User_settings.
     * @example
     * // Update or create a User_settings
     * const user_settings = await prisma.user_settings.upsert({
     *   create: {
     *     // ... data to create a User_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_settings we want to update
     *   }
     * })
     */
    upsert<T extends user_settingsUpsertArgs>(args: SelectSubset<T, user_settingsUpsertArgs<ExtArgs>>): Prisma__user_settingsClient<$Result.GetResult<Prisma.$user_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_settingsCountArgs} args - Arguments to filter User_settings to count.
     * @example
     * // Count the number of User_settings
     * const count = await prisma.user_settings.count({
     *   where: {
     *     // ... the filter for the User_settings we want to count
     *   }
     * })
    **/
    count<T extends user_settingsCountArgs>(
      args?: Subset<T, user_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_settingsAggregateArgs>(args: Subset<T, User_settingsAggregateArgs>): Prisma.PrismaPromise<GetUser_settingsAggregateType<T>>

    /**
     * Group by User_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_settingsGroupByArgs['orderBy'] }
        : { orderBy?: user_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_settings model
   */
  readonly fields: user_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_settings model
   */
  interface user_settingsFieldRefs {
    readonly id: FieldRef<"user_settings", 'Int'>
    readonly user_id: FieldRef<"user_settings", 'String'>
    readonly local_games_dir: FieldRef<"user_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_settings findUnique
   */
  export type user_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * Filter, which user_settings to fetch.
     */
    where: user_settingsWhereUniqueInput
  }

  /**
   * user_settings findUniqueOrThrow
   */
  export type user_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * Filter, which user_settings to fetch.
     */
    where: user_settingsWhereUniqueInput
  }

  /**
   * user_settings findFirst
   */
  export type user_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * Filter, which user_settings to fetch.
     */
    where?: user_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_settings to fetch.
     */
    orderBy?: user_settingsOrderByWithRelationInput | user_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_settings.
     */
    cursor?: user_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_settings.
     */
    distinct?: User_settingsScalarFieldEnum | User_settingsScalarFieldEnum[]
  }

  /**
   * user_settings findFirstOrThrow
   */
  export type user_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * Filter, which user_settings to fetch.
     */
    where?: user_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_settings to fetch.
     */
    orderBy?: user_settingsOrderByWithRelationInput | user_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_settings.
     */
    cursor?: user_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_settings.
     */
    distinct?: User_settingsScalarFieldEnum | User_settingsScalarFieldEnum[]
  }

  /**
   * user_settings findMany
   */
  export type user_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * Filter, which user_settings to fetch.
     */
    where?: user_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_settings to fetch.
     */
    orderBy?: user_settingsOrderByWithRelationInput | user_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_settings.
     */
    cursor?: user_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_settings.
     */
    skip?: number
    distinct?: User_settingsScalarFieldEnum | User_settingsScalarFieldEnum[]
  }

  /**
   * user_settings create
   */
  export type user_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_settings.
     */
    data: XOR<user_settingsCreateInput, user_settingsUncheckedCreateInput>
  }

  /**
   * user_settings createMany
   */
  export type user_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_settings.
     */
    data: user_settingsCreateManyInput | user_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_settings update
   */
  export type user_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_settings.
     */
    data: XOR<user_settingsUpdateInput, user_settingsUncheckedUpdateInput>
    /**
     * Choose, which user_settings to update.
     */
    where: user_settingsWhereUniqueInput
  }

  /**
   * user_settings updateMany
   */
  export type user_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_settings.
     */
    data: XOR<user_settingsUpdateManyMutationInput, user_settingsUncheckedUpdateManyInput>
    /**
     * Filter which user_settings to update
     */
    where?: user_settingsWhereInput
    /**
     * Limit how many user_settings to update.
     */
    limit?: number
  }

  /**
   * user_settings upsert
   */
  export type user_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_settings to update in case it exists.
     */
    where: user_settingsWhereUniqueInput
    /**
     * In case the user_settings found by the `where` argument doesn't exist, create a new user_settings with this data.
     */
    create: XOR<user_settingsCreateInput, user_settingsUncheckedCreateInput>
    /**
     * In case the user_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_settingsUpdateInput, user_settingsUncheckedUpdateInput>
  }

  /**
   * user_settings delete
   */
  export type user_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
    /**
     * Filter which user_settings to delete.
     */
    where: user_settingsWhereUniqueInput
  }

  /**
   * user_settings deleteMany
   */
  export type user_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_settings to delete
     */
    where?: user_settingsWhereInput
    /**
     * Limit how many user_settings to delete.
     */
    limit?: number
  }

  /**
   * user_settings without action
   */
  export type user_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_settings
     */
    select?: user_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_settings
     */
    omit?: user_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_settingsInclude<ExtArgs> | null
  }


  /**
   * Model game_session
   */

  export type AggregateGame_session = {
    _count: Game_sessionCountAggregateOutputType | null
    _avg: Game_sessionAvgAggregateOutputType | null
    _sum: Game_sessionSumAggregateOutputType | null
    _min: Game_sessionMinAggregateOutputType | null
    _max: Game_sessionMaxAggregateOutputType | null
  }

  export type Game_sessionAvgAggregateOutputType = {
    total_seconds: number | null
  }

  export type Game_sessionSumAggregateOutputType = {
    total_seconds: number | null
  }

  export type Game_sessionMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    game_slug: string | null
    start_time: Date | null
    end_time: Date | null
    total_seconds: number | null
  }

  export type Game_sessionMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    game_slug: string | null
    start_time: Date | null
    end_time: Date | null
    total_seconds: number | null
  }

  export type Game_sessionCountAggregateOutputType = {
    id: number
    user_id: number
    game_slug: number
    start_time: number
    end_time: number
    total_seconds: number
    _all: number
  }


  export type Game_sessionAvgAggregateInputType = {
    total_seconds?: true
  }

  export type Game_sessionSumAggregateInputType = {
    total_seconds?: true
  }

  export type Game_sessionMinAggregateInputType = {
    id?: true
    user_id?: true
    game_slug?: true
    start_time?: true
    end_time?: true
    total_seconds?: true
  }

  export type Game_sessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    game_slug?: true
    start_time?: true
    end_time?: true
    total_seconds?: true
  }

  export type Game_sessionCountAggregateInputType = {
    id?: true
    user_id?: true
    game_slug?: true
    start_time?: true
    end_time?: true
    total_seconds?: true
    _all?: true
  }

  export type Game_sessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_session to aggregate.
     */
    where?: game_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_sessions to fetch.
     */
    orderBy?: game_sessionOrderByWithRelationInput | game_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_sessions
    **/
    _count?: true | Game_sessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_sessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_sessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_sessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_sessionMaxAggregateInputType
  }

  export type GetGame_sessionAggregateType<T extends Game_sessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_session]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_session[P]>
      : GetScalarType<T[P], AggregateGame_session[P]>
  }




  export type game_sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_sessionWhereInput
    orderBy?: game_sessionOrderByWithAggregationInput | game_sessionOrderByWithAggregationInput[]
    by: Game_sessionScalarFieldEnum[] | Game_sessionScalarFieldEnum
    having?: game_sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_sessionCountAggregateInputType | true
    _avg?: Game_sessionAvgAggregateInputType
    _sum?: Game_sessionSumAggregateInputType
    _min?: Game_sessionMinAggregateInputType
    _max?: Game_sessionMaxAggregateInputType
  }

  export type Game_sessionGroupByOutputType = {
    id: string
    user_id: string
    game_slug: string
    start_time: Date
    end_time: Date | null
    total_seconds: number | null
    _count: Game_sessionCountAggregateOutputType | null
    _avg: Game_sessionAvgAggregateOutputType | null
    _sum: Game_sessionSumAggregateOutputType | null
    _min: Game_sessionMinAggregateOutputType | null
    _max: Game_sessionMaxAggregateOutputType | null
  }

  type GetGame_sessionGroupByPayload<T extends game_sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_sessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_sessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_sessionGroupByOutputType[P]>
            : GetScalarType<T[P], Game_sessionGroupByOutputType[P]>
        }
      >
    >


  export type game_sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    game_slug?: boolean
    start_time?: boolean
    end_time?: boolean
    total_seconds?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game_session"]>



  export type game_sessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    game_slug?: boolean
    start_time?: boolean
    end_time?: boolean
    total_seconds?: boolean
  }

  export type game_sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "game_slug" | "start_time" | "end_time" | "total_seconds", ExtArgs["result"]["game_session"]>
  export type game_sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $game_sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_session"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      game_slug: string
      start_time: Date
      end_time: Date | null
      total_seconds: number | null
    }, ExtArgs["result"]["game_session"]>
    composites: {}
  }

  type game_sessionGetPayload<S extends boolean | null | undefined | game_sessionDefaultArgs> = $Result.GetResult<Prisma.$game_sessionPayload, S>

  type game_sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<game_sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Game_sessionCountAggregateInputType | true
    }

  export interface game_sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_session'], meta: { name: 'game_session' } }
    /**
     * Find zero or one Game_session that matches the filter.
     * @param {game_sessionFindUniqueArgs} args - Arguments to find a Game_session
     * @example
     * // Get one Game_session
     * const game_session = await prisma.game_session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_sessionFindUniqueArgs>(args: SelectSubset<T, game_sessionFindUniqueArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game_session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {game_sessionFindUniqueOrThrowArgs} args - Arguments to find a Game_session
     * @example
     * // Get one Game_session
     * const game_session = await prisma.game_session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, game_sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_sessionFindFirstArgs} args - Arguments to find a Game_session
     * @example
     * // Get one Game_session
     * const game_session = await prisma.game_session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_sessionFindFirstArgs>(args?: SelectSubset<T, game_sessionFindFirstArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_sessionFindFirstOrThrowArgs} args - Arguments to find a Game_session
     * @example
     * // Get one Game_session
     * const game_session = await prisma.game_session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, game_sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Game_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_sessions
     * const game_sessions = await prisma.game_session.findMany()
     * 
     * // Get first 10 Game_sessions
     * const game_sessions = await prisma.game_session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_sessionWithIdOnly = await prisma.game_session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends game_sessionFindManyArgs>(args?: SelectSubset<T, game_sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game_session.
     * @param {game_sessionCreateArgs} args - Arguments to create a Game_session.
     * @example
     * // Create one Game_session
     * const Game_session = await prisma.game_session.create({
     *   data: {
     *     // ... data to create a Game_session
     *   }
     * })
     * 
     */
    create<T extends game_sessionCreateArgs>(args: SelectSubset<T, game_sessionCreateArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Game_sessions.
     * @param {game_sessionCreateManyArgs} args - Arguments to create many Game_sessions.
     * @example
     * // Create many Game_sessions
     * const game_session = await prisma.game_session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_sessionCreateManyArgs>(args?: SelectSubset<T, game_sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game_session.
     * @param {game_sessionDeleteArgs} args - Arguments to delete one Game_session.
     * @example
     * // Delete one Game_session
     * const Game_session = await prisma.game_session.delete({
     *   where: {
     *     // ... filter to delete one Game_session
     *   }
     * })
     * 
     */
    delete<T extends game_sessionDeleteArgs>(args: SelectSubset<T, game_sessionDeleteArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game_session.
     * @param {game_sessionUpdateArgs} args - Arguments to update one Game_session.
     * @example
     * // Update one Game_session
     * const game_session = await prisma.game_session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_sessionUpdateArgs>(args: SelectSubset<T, game_sessionUpdateArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Game_sessions.
     * @param {game_sessionDeleteManyArgs} args - Arguments to filter Game_sessions to delete.
     * @example
     * // Delete a few Game_sessions
     * const { count } = await prisma.game_session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_sessionDeleteManyArgs>(args?: SelectSubset<T, game_sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_sessions
     * const game_session = await prisma.game_session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_sessionUpdateManyArgs>(args: SelectSubset<T, game_sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_session.
     * @param {game_sessionUpsertArgs} args - Arguments to update or create a Game_session.
     * @example
     * // Update or create a Game_session
     * const game_session = await prisma.game_session.upsert({
     *   create: {
     *     // ... data to create a Game_session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_session we want to update
     *   }
     * })
     */
    upsert<T extends game_sessionUpsertArgs>(args: SelectSubset<T, game_sessionUpsertArgs<ExtArgs>>): Prisma__game_sessionClient<$Result.GetResult<Prisma.$game_sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Game_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_sessionCountArgs} args - Arguments to filter Game_sessions to count.
     * @example
     * // Count the number of Game_sessions
     * const count = await prisma.game_session.count({
     *   where: {
     *     // ... the filter for the Game_sessions we want to count
     *   }
     * })
    **/
    count<T extends game_sessionCountArgs>(
      args?: Subset<T, game_sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_sessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_sessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_sessionAggregateArgs>(args: Subset<T, Game_sessionAggregateArgs>): Prisma.PrismaPromise<GetGame_sessionAggregateType<T>>

    /**
     * Group by Game_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_sessionGroupByArgs['orderBy'] }
        : { orderBy?: game_sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_sessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_session model
   */
  readonly fields: game_sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_session model
   */
  interface game_sessionFieldRefs {
    readonly id: FieldRef<"game_session", 'String'>
    readonly user_id: FieldRef<"game_session", 'String'>
    readonly game_slug: FieldRef<"game_session", 'String'>
    readonly start_time: FieldRef<"game_session", 'DateTime'>
    readonly end_time: FieldRef<"game_session", 'DateTime'>
    readonly total_seconds: FieldRef<"game_session", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * game_session findUnique
   */
  export type game_sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * Filter, which game_session to fetch.
     */
    where: game_sessionWhereUniqueInput
  }

  /**
   * game_session findUniqueOrThrow
   */
  export type game_sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * Filter, which game_session to fetch.
     */
    where: game_sessionWhereUniqueInput
  }

  /**
   * game_session findFirst
   */
  export type game_sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * Filter, which game_session to fetch.
     */
    where?: game_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_sessions to fetch.
     */
    orderBy?: game_sessionOrderByWithRelationInput | game_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_sessions.
     */
    cursor?: game_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_sessions.
     */
    distinct?: Game_sessionScalarFieldEnum | Game_sessionScalarFieldEnum[]
  }

  /**
   * game_session findFirstOrThrow
   */
  export type game_sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * Filter, which game_session to fetch.
     */
    where?: game_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_sessions to fetch.
     */
    orderBy?: game_sessionOrderByWithRelationInput | game_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_sessions.
     */
    cursor?: game_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_sessions.
     */
    distinct?: Game_sessionScalarFieldEnum | Game_sessionScalarFieldEnum[]
  }

  /**
   * game_session findMany
   */
  export type game_sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * Filter, which game_sessions to fetch.
     */
    where?: game_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_sessions to fetch.
     */
    orderBy?: game_sessionOrderByWithRelationInput | game_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_sessions.
     */
    cursor?: game_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_sessions.
     */
    skip?: number
    distinct?: Game_sessionScalarFieldEnum | Game_sessionScalarFieldEnum[]
  }

  /**
   * game_session create
   */
  export type game_sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a game_session.
     */
    data: XOR<game_sessionCreateInput, game_sessionUncheckedCreateInput>
  }

  /**
   * game_session createMany
   */
  export type game_sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_sessions.
     */
    data: game_sessionCreateManyInput | game_sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_session update
   */
  export type game_sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a game_session.
     */
    data: XOR<game_sessionUpdateInput, game_sessionUncheckedUpdateInput>
    /**
     * Choose, which game_session to update.
     */
    where: game_sessionWhereUniqueInput
  }

  /**
   * game_session updateMany
   */
  export type game_sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_sessions.
     */
    data: XOR<game_sessionUpdateManyMutationInput, game_sessionUncheckedUpdateManyInput>
    /**
     * Filter which game_sessions to update
     */
    where?: game_sessionWhereInput
    /**
     * Limit how many game_sessions to update.
     */
    limit?: number
  }

  /**
   * game_session upsert
   */
  export type game_sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the game_session to update in case it exists.
     */
    where: game_sessionWhereUniqueInput
    /**
     * In case the game_session found by the `where` argument doesn't exist, create a new game_session with this data.
     */
    create: XOR<game_sessionCreateInput, game_sessionUncheckedCreateInput>
    /**
     * In case the game_session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_sessionUpdateInput, game_sessionUncheckedUpdateInput>
  }

  /**
   * game_session delete
   */
  export type game_sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
    /**
     * Filter which game_session to delete.
     */
    where: game_sessionWhereUniqueInput
  }

  /**
   * game_session deleteMany
   */
  export type game_sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_sessions to delete
     */
    where?: game_sessionWhereInput
    /**
     * Limit how many game_sessions to delete.
     */
    limit?: number
  }

  /**
   * game_session without action
   */
  export type game_sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_session
     */
    select?: game_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_session
     */
    omit?: game_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_sessionInclude<ExtArgs> | null
  }


  /**
   * Model event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    url: string | null
    start_time: Date | null
    end_time: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    location: string | null
    image_url: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    url: string | null
    start_time: Date | null
    end_time: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
    location: string | null
    image_url: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    description: number
    url: number
    start_time: number
    end_time: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    location: number
    image_url: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    location?: true
    image_url?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    location?: true
    image_url?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    location?: true
    image_url?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event to aggregate.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
    orderBy?: eventOrderByWithAggregationInput | eventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    description: string | null
    url: string | null
    start_time: Date
    end_time: Date
    created_at: Date
    updated_at: Date
    created_by: string
    updated_by: string
    location: string | null
    image_url: string | null
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    location?: boolean
    image_url?: boolean
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>



  export type eventSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    location?: boolean
    image_url?: boolean
  }

  export type eventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "url" | "start_time" | "end_time" | "created_at" | "updated_at" | "created_by" | "updated_by" | "location" | "image_url", ExtArgs["result"]["event"]>
  export type eventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event"
    objects: {
      creator: Prisma.$userPayload<ExtArgs>
      updater: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      url: string | null
      start_time: Date
      end_time: Date
      created_at: Date
      updated_at: Date
      created_by: string
      updated_by: string
      location: string | null
      image_url: string | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type eventGetPayload<S extends boolean | null | undefined | eventDefaultArgs> = $Result.GetResult<Prisma.$eventPayload, S>

  type eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<eventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event'], meta: { name: 'event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {eventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventFindUniqueArgs>(args: SelectSubset<T, eventFindUniqueArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {eventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventFindUniqueOrThrowArgs>(args: SelectSubset<T, eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventFindFirstArgs>(args?: SelectSubset<T, eventFindFirstArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventFindFirstOrThrowArgs>(args?: SelectSubset<T, eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventFindManyArgs>(args?: SelectSubset<T, eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {eventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends eventCreateArgs>(args: SelectSubset<T, eventCreateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {eventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventCreateManyArgs>(args?: SelectSubset<T, eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {eventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends eventDeleteArgs>(args: SelectSubset<T, eventDeleteArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {eventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventUpdateArgs>(args: SelectSubset<T, eventUpdateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {eventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventDeleteManyArgs>(args?: SelectSubset<T, eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventUpdateManyArgs>(args: SelectSubset<T, eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {eventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends eventUpsertArgs>(args: SelectSubset<T, eventUpsertArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventCountArgs>(
      args?: Subset<T, eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventGroupByArgs['orderBy'] }
        : { orderBy?: eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event model
   */
  readonly fields: eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updater<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the event model
   */
  interface eventFieldRefs {
    readonly id: FieldRef<"event", 'String'>
    readonly name: FieldRef<"event", 'String'>
    readonly description: FieldRef<"event", 'String'>
    readonly url: FieldRef<"event", 'String'>
    readonly start_time: FieldRef<"event", 'DateTime'>
    readonly end_time: FieldRef<"event", 'DateTime'>
    readonly created_at: FieldRef<"event", 'DateTime'>
    readonly updated_at: FieldRef<"event", 'DateTime'>
    readonly created_by: FieldRef<"event", 'String'>
    readonly updated_by: FieldRef<"event", 'String'>
    readonly location: FieldRef<"event", 'String'>
    readonly image_url: FieldRef<"event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * event findUnique
   */
  export type eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findUniqueOrThrow
   */
  export type eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findFirst
   */
  export type eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findFirstOrThrow
   */
  export type eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findMany
   */
  export type eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event create
   */
  export type eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to create a event.
     */
    data: XOR<eventCreateInput, eventUncheckedCreateInput>
  }

  /**
   * event createMany
   */
  export type eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event update
   */
  export type eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to update a event.
     */
    data: XOR<eventUpdateInput, eventUncheckedUpdateInput>
    /**
     * Choose, which event to update.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event updateMany
   */
  export type eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventWhereInput
    /**
     * Limit how many events to update.
     */
    limit?: number
  }

  /**
   * event upsert
   */
  export type eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The filter to search for the event to update in case it exists.
     */
    where: eventWhereUniqueInput
    /**
     * In case the event found by the `where` argument doesn't exist, create a new event with this data.
     */
    create: XOR<eventCreateInput, eventUncheckedCreateInput>
    /**
     * In case the event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventUpdateInput, eventUncheckedUpdateInput>
  }

  /**
   * event delete
   */
  export type eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter which event to delete.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event deleteMany
   */
  export type eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventWhereInput
    /**
     * Limit how many events to delete.
     */
    limit?: number
  }

  /**
   * event without action
   */
  export type eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
  }


  /**
   * Model global_settings
   */

  export type AggregateGlobal_settings = {
    _count: Global_settingsCountAggregateOutputType | null
    _avg: Global_settingsAvgAggregateOutputType | null
    _sum: Global_settingsSumAggregateOutputType | null
    _min: Global_settingsMinAggregateOutputType | null
    _max: Global_settingsMaxAggregateOutputType | null
  }

  export type Global_settingsAvgAggregateOutputType = {
    id: number | null
  }

  export type Global_settingsSumAggregateOutputType = {
    id: number | null
  }

  export type Global_settingsMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type Global_settingsMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type Global_settingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type Global_settingsAvgAggregateInputType = {
    id?: true
  }

  export type Global_settingsSumAggregateInputType = {
    id?: true
  }

  export type Global_settingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Global_settingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Global_settingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type Global_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which global_settings to aggregate.
     */
    where?: global_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of global_settings to fetch.
     */
    orderBy?: global_settingsOrderByWithRelationInput | global_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: global_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` global_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` global_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned global_settings
    **/
    _count?: true | Global_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Global_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Global_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Global_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Global_settingsMaxAggregateInputType
  }

  export type GetGlobal_settingsAggregateType<T extends Global_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobal_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobal_settings[P]>
      : GetScalarType<T[P], AggregateGlobal_settings[P]>
  }




  export type global_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: global_settingsWhereInput
    orderBy?: global_settingsOrderByWithAggregationInput | global_settingsOrderByWithAggregationInput[]
    by: Global_settingsScalarFieldEnum[] | Global_settingsScalarFieldEnum
    having?: global_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Global_settingsCountAggregateInputType | true
    _avg?: Global_settingsAvgAggregateInputType
    _sum?: Global_settingsSumAggregateInputType
    _min?: Global_settingsMinAggregateInputType
    _max?: Global_settingsMaxAggregateInputType
  }

  export type Global_settingsGroupByOutputType = {
    id: number
    key: string
    value: string | null
    created_at: Date
    updated_at: Date
    created_by: string
    updated_by: string
    _count: Global_settingsCountAggregateOutputType | null
    _avg: Global_settingsAvgAggregateOutputType | null
    _sum: Global_settingsSumAggregateOutputType | null
    _min: Global_settingsMinAggregateOutputType | null
    _max: Global_settingsMaxAggregateOutputType | null
  }

  type GetGlobal_settingsGroupByPayload<T extends global_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Global_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Global_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Global_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Global_settingsGroupByOutputType[P]>
        }
      >
    >


  export type global_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }, ExtArgs["result"]["global_settings"]>



  export type global_settingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type global_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["global_settings"]>

  export type $global_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "global_settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string | null
      created_at: Date
      updated_at: Date
      created_by: string
      updated_by: string
    }, ExtArgs["result"]["global_settings"]>
    composites: {}
  }

  type global_settingsGetPayload<S extends boolean | null | undefined | global_settingsDefaultArgs> = $Result.GetResult<Prisma.$global_settingsPayload, S>

  type global_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<global_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Global_settingsCountAggregateInputType | true
    }

  export interface global_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['global_settings'], meta: { name: 'global_settings' } }
    /**
     * Find zero or one Global_settings that matches the filter.
     * @param {global_settingsFindUniqueArgs} args - Arguments to find a Global_settings
     * @example
     * // Get one Global_settings
     * const global_settings = await prisma.global_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends global_settingsFindUniqueArgs>(args: SelectSubset<T, global_settingsFindUniqueArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Global_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {global_settingsFindUniqueOrThrowArgs} args - Arguments to find a Global_settings
     * @example
     * // Get one Global_settings
     * const global_settings = await prisma.global_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends global_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, global_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Global_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {global_settingsFindFirstArgs} args - Arguments to find a Global_settings
     * @example
     * // Get one Global_settings
     * const global_settings = await prisma.global_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends global_settingsFindFirstArgs>(args?: SelectSubset<T, global_settingsFindFirstArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Global_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {global_settingsFindFirstOrThrowArgs} args - Arguments to find a Global_settings
     * @example
     * // Get one Global_settings
     * const global_settings = await prisma.global_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends global_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, global_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Global_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {global_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Global_settings
     * const global_settings = await prisma.global_settings.findMany()
     * 
     * // Get first 10 Global_settings
     * const global_settings = await prisma.global_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const global_settingsWithIdOnly = await prisma.global_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends global_settingsFindManyArgs>(args?: SelectSubset<T, global_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Global_settings.
     * @param {global_settingsCreateArgs} args - Arguments to create a Global_settings.
     * @example
     * // Create one Global_settings
     * const Global_settings = await prisma.global_settings.create({
     *   data: {
     *     // ... data to create a Global_settings
     *   }
     * })
     * 
     */
    create<T extends global_settingsCreateArgs>(args: SelectSubset<T, global_settingsCreateArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Global_settings.
     * @param {global_settingsCreateManyArgs} args - Arguments to create many Global_settings.
     * @example
     * // Create many Global_settings
     * const global_settings = await prisma.global_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends global_settingsCreateManyArgs>(args?: SelectSubset<T, global_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Global_settings.
     * @param {global_settingsDeleteArgs} args - Arguments to delete one Global_settings.
     * @example
     * // Delete one Global_settings
     * const Global_settings = await prisma.global_settings.delete({
     *   where: {
     *     // ... filter to delete one Global_settings
     *   }
     * })
     * 
     */
    delete<T extends global_settingsDeleteArgs>(args: SelectSubset<T, global_settingsDeleteArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Global_settings.
     * @param {global_settingsUpdateArgs} args - Arguments to update one Global_settings.
     * @example
     * // Update one Global_settings
     * const global_settings = await prisma.global_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends global_settingsUpdateArgs>(args: SelectSubset<T, global_settingsUpdateArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Global_settings.
     * @param {global_settingsDeleteManyArgs} args - Arguments to filter Global_settings to delete.
     * @example
     * // Delete a few Global_settings
     * const { count } = await prisma.global_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends global_settingsDeleteManyArgs>(args?: SelectSubset<T, global_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Global_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {global_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Global_settings
     * const global_settings = await prisma.global_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends global_settingsUpdateManyArgs>(args: SelectSubset<T, global_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Global_settings.
     * @param {global_settingsUpsertArgs} args - Arguments to update or create a Global_settings.
     * @example
     * // Update or create a Global_settings
     * const global_settings = await prisma.global_settings.upsert({
     *   create: {
     *     // ... data to create a Global_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Global_settings we want to update
     *   }
     * })
     */
    upsert<T extends global_settingsUpsertArgs>(args: SelectSubset<T, global_settingsUpsertArgs<ExtArgs>>): Prisma__global_settingsClient<$Result.GetResult<Prisma.$global_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Global_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {global_settingsCountArgs} args - Arguments to filter Global_settings to count.
     * @example
     * // Count the number of Global_settings
     * const count = await prisma.global_settings.count({
     *   where: {
     *     // ... the filter for the Global_settings we want to count
     *   }
     * })
    **/
    count<T extends global_settingsCountArgs>(
      args?: Subset<T, global_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Global_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Global_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Global_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Global_settingsAggregateArgs>(args: Subset<T, Global_settingsAggregateArgs>): Prisma.PrismaPromise<GetGlobal_settingsAggregateType<T>>

    /**
     * Group by Global_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {global_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends global_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: global_settingsGroupByArgs['orderBy'] }
        : { orderBy?: global_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, global_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobal_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the global_settings model
   */
  readonly fields: global_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for global_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__global_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the global_settings model
   */
  interface global_settingsFieldRefs {
    readonly id: FieldRef<"global_settings", 'Int'>
    readonly key: FieldRef<"global_settings", 'String'>
    readonly value: FieldRef<"global_settings", 'String'>
    readonly created_at: FieldRef<"global_settings", 'DateTime'>
    readonly updated_at: FieldRef<"global_settings", 'DateTime'>
    readonly created_by: FieldRef<"global_settings", 'String'>
    readonly updated_by: FieldRef<"global_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * global_settings findUnique
   */
  export type global_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * Filter, which global_settings to fetch.
     */
    where: global_settingsWhereUniqueInput
  }

  /**
   * global_settings findUniqueOrThrow
   */
  export type global_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * Filter, which global_settings to fetch.
     */
    where: global_settingsWhereUniqueInput
  }

  /**
   * global_settings findFirst
   */
  export type global_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * Filter, which global_settings to fetch.
     */
    where?: global_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of global_settings to fetch.
     */
    orderBy?: global_settingsOrderByWithRelationInput | global_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for global_settings.
     */
    cursor?: global_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` global_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` global_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of global_settings.
     */
    distinct?: Global_settingsScalarFieldEnum | Global_settingsScalarFieldEnum[]
  }

  /**
   * global_settings findFirstOrThrow
   */
  export type global_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * Filter, which global_settings to fetch.
     */
    where?: global_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of global_settings to fetch.
     */
    orderBy?: global_settingsOrderByWithRelationInput | global_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for global_settings.
     */
    cursor?: global_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` global_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` global_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of global_settings.
     */
    distinct?: Global_settingsScalarFieldEnum | Global_settingsScalarFieldEnum[]
  }

  /**
   * global_settings findMany
   */
  export type global_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * Filter, which global_settings to fetch.
     */
    where?: global_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of global_settings to fetch.
     */
    orderBy?: global_settingsOrderByWithRelationInput | global_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing global_settings.
     */
    cursor?: global_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` global_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` global_settings.
     */
    skip?: number
    distinct?: Global_settingsScalarFieldEnum | Global_settingsScalarFieldEnum[]
  }

  /**
   * global_settings create
   */
  export type global_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * The data needed to create a global_settings.
     */
    data: XOR<global_settingsCreateInput, global_settingsUncheckedCreateInput>
  }

  /**
   * global_settings createMany
   */
  export type global_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many global_settings.
     */
    data: global_settingsCreateManyInput | global_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * global_settings update
   */
  export type global_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * The data needed to update a global_settings.
     */
    data: XOR<global_settingsUpdateInput, global_settingsUncheckedUpdateInput>
    /**
     * Choose, which global_settings to update.
     */
    where: global_settingsWhereUniqueInput
  }

  /**
   * global_settings updateMany
   */
  export type global_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update global_settings.
     */
    data: XOR<global_settingsUpdateManyMutationInput, global_settingsUncheckedUpdateManyInput>
    /**
     * Filter which global_settings to update
     */
    where?: global_settingsWhereInput
    /**
     * Limit how many global_settings to update.
     */
    limit?: number
  }

  /**
   * global_settings upsert
   */
  export type global_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * The filter to search for the global_settings to update in case it exists.
     */
    where: global_settingsWhereUniqueInput
    /**
     * In case the global_settings found by the `where` argument doesn't exist, create a new global_settings with this data.
     */
    create: XOR<global_settingsCreateInput, global_settingsUncheckedCreateInput>
    /**
     * In case the global_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<global_settingsUpdateInput, global_settingsUncheckedUpdateInput>
  }

  /**
   * global_settings delete
   */
  export type global_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
    /**
     * Filter which global_settings to delete.
     */
    where: global_settingsWhereUniqueInput
  }

  /**
   * global_settings deleteMany
   */
  export type global_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which global_settings to delete
     */
    where?: global_settingsWhereInput
    /**
     * Limit how many global_settings to delete.
     */
    limit?: number
  }

  /**
   * global_settings without action
   */
  export type global_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the global_settings
     */
    select?: global_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the global_settings
     */
    omit?: global_settingsOmit<ExtArgs> | null
  }


  /**
   * Model game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    size_gb: number | null
    max_players: number | null
  }

  export type GameSumAggregateOutputType = {
    size_gb: number | null
    max_players: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    size_gb: number | null
    title: string | null
    folder_slug: string | null
    version: string | null
    genres: string | null
    platforms: string | null
    game_modes: string | null
    is_featured: boolean | null
    date_updated: Date | null
    date_added: Date | null
    editor_name: string | null
    main_process_name: string | null
    cover: string | null
    logo: string | null
    screenshots: string | null
    description: string | null
    start_command: string | null
    max_players: number | null
    use_notifications: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    size_gb: number | null
    title: string | null
    folder_slug: string | null
    version: string | null
    genres: string | null
    platforms: string | null
    game_modes: string | null
    is_featured: boolean | null
    date_updated: Date | null
    date_added: Date | null
    editor_name: string | null
    main_process_name: string | null
    cover: string | null
    logo: string | null
    screenshots: string | null
    description: string | null
    start_command: string | null
    max_players: number | null
    use_notifications: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    size_gb: number
    title: number
    folder_slug: number
    version: number
    genres: number
    platforms: number
    game_modes: number
    is_featured: number
    date_updated: number
    date_added: number
    editor_name: number
    main_process_name: number
    cover: number
    logo: number
    screenshots: number
    description: number
    start_command: number
    max_players: number
    use_notifications: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    size_gb?: true
    max_players?: true
  }

  export type GameSumAggregateInputType = {
    size_gb?: true
    max_players?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    size_gb?: true
    title?: true
    folder_slug?: true
    version?: true
    genres?: true
    platforms?: true
    game_modes?: true
    is_featured?: true
    date_updated?: true
    date_added?: true
    editor_name?: true
    main_process_name?: true
    cover?: true
    logo?: true
    screenshots?: true
    description?: true
    start_command?: true
    max_players?: true
    use_notifications?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    size_gb?: true
    title?: true
    folder_slug?: true
    version?: true
    genres?: true
    platforms?: true
    game_modes?: true
    is_featured?: true
    date_updated?: true
    date_added?: true
    editor_name?: true
    main_process_name?: true
    cover?: true
    logo?: true
    screenshots?: true
    description?: true
    start_command?: true
    max_players?: true
    use_notifications?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    size_gb?: true
    title?: true
    folder_slug?: true
    version?: true
    genres?: true
    platforms?: true
    game_modes?: true
    is_featured?: true
    date_updated?: true
    date_added?: true
    editor_name?: true
    main_process_name?: true
    cover?: true
    logo?: true
    screenshots?: true
    description?: true
    start_command?: true
    max_players?: true
    use_notifications?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game to aggregate.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gameWhereInput
    orderBy?: gameOrderByWithAggregationInput | gameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    size_gb: number
    title: string
    folder_slug: string
    version: string | null
    genres: string
    platforms: string | null
    game_modes: string
    is_featured: boolean
    date_updated: Date | null
    date_added: Date | null
    editor_name: string | null
    main_process_name: string | null
    cover: string | null
    logo: string | null
    screenshots: string
    description: string | null
    start_command: string | null
    max_players: number
    use_notifications: boolean
    created_at: Date
    updated_at: Date
    created_by: string
    updated_by: string
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    size_gb?: boolean
    title?: boolean
    folder_slug?: boolean
    version?: boolean
    genres?: boolean
    platforms?: boolean
    game_modes?: boolean
    is_featured?: boolean
    date_updated?: boolean
    date_added?: boolean
    editor_name?: boolean
    main_process_name?: boolean
    cover?: boolean
    logo?: boolean
    screenshots?: boolean
    description?: boolean
    start_command?: boolean
    max_players?: boolean
    use_notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    createdBy?: boolean | userDefaultArgs<ExtArgs>
    updatedBy?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>



  export type gameSelectScalar = {
    id?: boolean
    size_gb?: boolean
    title?: boolean
    folder_slug?: boolean
    version?: boolean
    genres?: boolean
    platforms?: boolean
    game_modes?: boolean
    is_featured?: boolean
    date_updated?: boolean
    date_added?: boolean
    editor_name?: boolean
    main_process_name?: boolean
    cover?: boolean
    logo?: boolean
    screenshots?: boolean
    description?: boolean
    start_command?: boolean
    max_players?: boolean
    use_notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "size_gb" | "title" | "folder_slug" | "version" | "genres" | "platforms" | "game_modes" | "is_featured" | "date_updated" | "date_added" | "editor_name" | "main_process_name" | "cover" | "logo" | "screenshots" | "description" | "start_command" | "max_players" | "use_notifications" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["game"]>
  export type gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | userDefaultArgs<ExtArgs>
    updatedBy?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game"
    objects: {
      createdBy: Prisma.$userPayload<ExtArgs>
      updatedBy: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      size_gb: number
      title: string
      folder_slug: string
      version: string | null
      genres: string
      platforms: string | null
      game_modes: string
      is_featured: boolean
      date_updated: Date | null
      date_added: Date | null
      editor_name: string | null
      main_process_name: string | null
      cover: string | null
      logo: string | null
      screenshots: string
      description: string | null
      start_command: string | null
      max_players: number
      use_notifications: boolean
      created_at: Date
      updated_at: Date
      created_by: string
      updated_by: string
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type gameGetPayload<S extends boolean | null | undefined | gameDefaultArgs> = $Result.GetResult<Prisma.$gamePayload, S>

  type gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game'], meta: { name: 'game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {gameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gameFindUniqueArgs>(args: SelectSubset<T, gameFindUniqueArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gameFindUniqueOrThrowArgs>(args: SelectSubset<T, gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gameFindFirstArgs>(args?: SelectSubset<T, gameFindFirstArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gameFindFirstOrThrowArgs>(args?: SelectSubset<T, gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gameFindManyArgs>(args?: SelectSubset<T, gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {gameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends gameCreateArgs>(args: SelectSubset<T, gameCreateArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {gameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gameCreateManyArgs>(args?: SelectSubset<T, gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game.
     * @param {gameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends gameDeleteArgs>(args: SelectSubset<T, gameDeleteArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {gameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gameUpdateArgs>(args: SelectSubset<T, gameUpdateArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {gameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gameDeleteManyArgs>(args?: SelectSubset<T, gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gameUpdateManyArgs>(args: SelectSubset<T, gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {gameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends gameUpsertArgs>(args: SelectSubset<T, gameUpsertArgs<ExtArgs>>): Prisma__gameClient<$Result.GetResult<Prisma.$gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends gameCountArgs>(
      args?: Subset<T, gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gameGroupByArgs['orderBy'] }
        : { orderBy?: gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game model
   */
  readonly fields: gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game model
   */
  interface gameFieldRefs {
    readonly id: FieldRef<"game", 'String'>
    readonly size_gb: FieldRef<"game", 'Float'>
    readonly title: FieldRef<"game", 'String'>
    readonly folder_slug: FieldRef<"game", 'String'>
    readonly version: FieldRef<"game", 'String'>
    readonly genres: FieldRef<"game", 'String'>
    readonly platforms: FieldRef<"game", 'String'>
    readonly game_modes: FieldRef<"game", 'String'>
    readonly is_featured: FieldRef<"game", 'Boolean'>
    readonly date_updated: FieldRef<"game", 'DateTime'>
    readonly date_added: FieldRef<"game", 'DateTime'>
    readonly editor_name: FieldRef<"game", 'String'>
    readonly main_process_name: FieldRef<"game", 'String'>
    readonly cover: FieldRef<"game", 'String'>
    readonly logo: FieldRef<"game", 'String'>
    readonly screenshots: FieldRef<"game", 'String'>
    readonly description: FieldRef<"game", 'String'>
    readonly start_command: FieldRef<"game", 'String'>
    readonly max_players: FieldRef<"game", 'Int'>
    readonly use_notifications: FieldRef<"game", 'Boolean'>
    readonly created_at: FieldRef<"game", 'DateTime'>
    readonly updated_at: FieldRef<"game", 'DateTime'>
    readonly created_by: FieldRef<"game", 'String'>
    readonly updated_by: FieldRef<"game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * game findUnique
   */
  export type gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game findUniqueOrThrow
   */
  export type gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game findFirst
   */
  export type gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * game findFirstOrThrow
   */
  export type gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which game to fetch.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * game findMany
   */
  export type gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gameOrderByWithRelationInput | gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing games.
     */
    cursor?: gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * game create
   */
  export type gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * The data needed to create a game.
     */
    data: XOR<gameCreateInput, gameUncheckedCreateInput>
  }

  /**
   * game createMany
   */
  export type gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many games.
     */
    data: gameCreateManyInput | gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game update
   */
  export type gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * The data needed to update a game.
     */
    data: XOR<gameUpdateInput, gameUncheckedUpdateInput>
    /**
     * Choose, which game to update.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game updateMany
   */
  export type gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update games.
     */
    data: XOR<gameUpdateManyMutationInput, gameUncheckedUpdateManyInput>
    /**
     * Filter which games to update
     */
    where?: gameWhereInput
    /**
     * Limit how many games to update.
     */
    limit?: number
  }

  /**
   * game upsert
   */
  export type gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * The filter to search for the game to update in case it exists.
     */
    where: gameWhereUniqueInput
    /**
     * In case the game found by the `where` argument doesn't exist, create a new game with this data.
     */
    create: XOR<gameCreateInput, gameUncheckedCreateInput>
    /**
     * In case the game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gameUpdateInput, gameUncheckedUpdateInput>
  }

  /**
   * game delete
   */
  export type gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
    /**
     * Filter which game to delete.
     */
    where: gameWhereUniqueInput
  }

  /**
   * game deleteMany
   */
  export type gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which games to delete
     */
    where?: gameWhereInput
    /**
     * Limit how many games to delete.
     */
    limit?: number
  }

  /**
   * game without action
   */
  export type gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game
     */
    select?: gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game
     */
    omit?: gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gameInclude<ExtArgs> | null
  }


  /**
   * Model game_server
   */

  export type AggregateGame_server = {
    _count: Game_serverCountAggregateOutputType | null
    _avg: Game_serverAvgAggregateOutputType | null
    _sum: Game_serverSumAggregateOutputType | null
    _min: Game_serverMinAggregateOutputType | null
    _max: Game_serverMaxAggregateOutputType | null
  }

  export type Game_serverAvgAggregateOutputType = {
    id: number | null
    port: number | null
  }

  export type Game_serverSumAggregateOutputType = {
    id: number | null
    port: number | null
  }

  export type Game_serverMinAggregateOutputType = {
    id: number | null
    game_slug: string | null
    game_title: string | null
    type: string | null
    port: number | null
    description: string | null
    name: string | null
    monitor: boolean | null
    last_detection_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type Game_serverMaxAggregateOutputType = {
    id: number | null
    game_slug: string | null
    game_title: string | null
    type: string | null
    port: number | null
    description: string | null
    name: string | null
    monitor: boolean | null
    last_detection_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type Game_serverCountAggregateOutputType = {
    id: number
    game_slug: number
    game_title: number
    type: number
    port: number
    description: number
    name: number
    monitor: number
    last_detection_at: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type Game_serverAvgAggregateInputType = {
    id?: true
    port?: true
  }

  export type Game_serverSumAggregateInputType = {
    id?: true
    port?: true
  }

  export type Game_serverMinAggregateInputType = {
    id?: true
    game_slug?: true
    game_title?: true
    type?: true
    port?: true
    description?: true
    name?: true
    monitor?: true
    last_detection_at?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Game_serverMaxAggregateInputType = {
    id?: true
    game_slug?: true
    game_title?: true
    type?: true
    port?: true
    description?: true
    name?: true
    monitor?: true
    last_detection_at?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Game_serverCountAggregateInputType = {
    id?: true
    game_slug?: true
    game_title?: true
    type?: true
    port?: true
    description?: true
    name?: true
    monitor?: true
    last_detection_at?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type Game_serverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_server to aggregate.
     */
    where?: game_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_servers to fetch.
     */
    orderBy?: game_serverOrderByWithRelationInput | game_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_servers
    **/
    _count?: true | Game_serverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_serverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_serverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_serverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_serverMaxAggregateInputType
  }

  export type GetGame_serverAggregateType<T extends Game_serverAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_server]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_server[P]>
      : GetScalarType<T[P], AggregateGame_server[P]>
  }




  export type game_serverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_serverWhereInput
    orderBy?: game_serverOrderByWithAggregationInput | game_serverOrderByWithAggregationInput[]
    by: Game_serverScalarFieldEnum[] | Game_serverScalarFieldEnum
    having?: game_serverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_serverCountAggregateInputType | true
    _avg?: Game_serverAvgAggregateInputType
    _sum?: Game_serverSumAggregateInputType
    _min?: Game_serverMinAggregateInputType
    _max?: Game_serverMaxAggregateInputType
  }

  export type Game_serverGroupByOutputType = {
    id: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description: string | null
    name: string
    monitor: boolean
    last_detection_at: Date | null
    created_at: Date
    updated_at: Date
    created_by: string
    updated_by: string
    _count: Game_serverCountAggregateOutputType | null
    _avg: Game_serverAvgAggregateOutputType | null
    _sum: Game_serverSumAggregateOutputType | null
    _min: Game_serverMinAggregateOutputType | null
    _max: Game_serverMaxAggregateOutputType | null
  }

  type GetGame_serverGroupByPayload<T extends game_serverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_serverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_serverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_serverGroupByOutputType[P]>
            : GetScalarType<T[P], Game_serverGroupByOutputType[P]>
        }
      >
    >


  export type game_serverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    game_slug?: boolean
    game_title?: boolean
    type?: boolean
    port?: boolean
    description?: boolean
    name?: boolean
    monitor?: boolean
    last_detection_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game_server"]>



  export type game_serverSelectScalar = {
    id?: boolean
    game_slug?: boolean
    game_title?: boolean
    type?: boolean
    port?: boolean
    description?: boolean
    name?: boolean
    monitor?: boolean
    last_detection_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type game_serverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "game_slug" | "game_title" | "type" | "port" | "description" | "name" | "monitor" | "last_detection_at" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["game_server"]>
  export type game_serverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $game_serverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_server"
    objects: {
      creator: Prisma.$userPayload<ExtArgs>
      updater: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      game_slug: string
      game_title: string
      type: string
      port: number
      description: string | null
      name: string
      monitor: boolean
      last_detection_at: Date | null
      created_at: Date
      updated_at: Date
      created_by: string
      updated_by: string
    }, ExtArgs["result"]["game_server"]>
    composites: {}
  }

  type game_serverGetPayload<S extends boolean | null | undefined | game_serverDefaultArgs> = $Result.GetResult<Prisma.$game_serverPayload, S>

  type game_serverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<game_serverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Game_serverCountAggregateInputType | true
    }

  export interface game_serverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_server'], meta: { name: 'game_server' } }
    /**
     * Find zero or one Game_server that matches the filter.
     * @param {game_serverFindUniqueArgs} args - Arguments to find a Game_server
     * @example
     * // Get one Game_server
     * const game_server = await prisma.game_server.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_serverFindUniqueArgs>(args: SelectSubset<T, game_serverFindUniqueArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game_server that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {game_serverFindUniqueOrThrowArgs} args - Arguments to find a Game_server
     * @example
     * // Get one Game_server
     * const game_server = await prisma.game_server.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_serverFindUniqueOrThrowArgs>(args: SelectSubset<T, game_serverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_server that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_serverFindFirstArgs} args - Arguments to find a Game_server
     * @example
     * // Get one Game_server
     * const game_server = await prisma.game_server.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_serverFindFirstArgs>(args?: SelectSubset<T, game_serverFindFirstArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_server that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_serverFindFirstOrThrowArgs} args - Arguments to find a Game_server
     * @example
     * // Get one Game_server
     * const game_server = await prisma.game_server.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_serverFindFirstOrThrowArgs>(args?: SelectSubset<T, game_serverFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Game_servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_serverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_servers
     * const game_servers = await prisma.game_server.findMany()
     * 
     * // Get first 10 Game_servers
     * const game_servers = await prisma.game_server.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_serverWithIdOnly = await prisma.game_server.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends game_serverFindManyArgs>(args?: SelectSubset<T, game_serverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game_server.
     * @param {game_serverCreateArgs} args - Arguments to create a Game_server.
     * @example
     * // Create one Game_server
     * const Game_server = await prisma.game_server.create({
     *   data: {
     *     // ... data to create a Game_server
     *   }
     * })
     * 
     */
    create<T extends game_serverCreateArgs>(args: SelectSubset<T, game_serverCreateArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Game_servers.
     * @param {game_serverCreateManyArgs} args - Arguments to create many Game_servers.
     * @example
     * // Create many Game_servers
     * const game_server = await prisma.game_server.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_serverCreateManyArgs>(args?: SelectSubset<T, game_serverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game_server.
     * @param {game_serverDeleteArgs} args - Arguments to delete one Game_server.
     * @example
     * // Delete one Game_server
     * const Game_server = await prisma.game_server.delete({
     *   where: {
     *     // ... filter to delete one Game_server
     *   }
     * })
     * 
     */
    delete<T extends game_serverDeleteArgs>(args: SelectSubset<T, game_serverDeleteArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game_server.
     * @param {game_serverUpdateArgs} args - Arguments to update one Game_server.
     * @example
     * // Update one Game_server
     * const game_server = await prisma.game_server.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_serverUpdateArgs>(args: SelectSubset<T, game_serverUpdateArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Game_servers.
     * @param {game_serverDeleteManyArgs} args - Arguments to filter Game_servers to delete.
     * @example
     * // Delete a few Game_servers
     * const { count } = await prisma.game_server.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_serverDeleteManyArgs>(args?: SelectSubset<T, game_serverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_serverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_servers
     * const game_server = await prisma.game_server.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_serverUpdateManyArgs>(args: SelectSubset<T, game_serverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_server.
     * @param {game_serverUpsertArgs} args - Arguments to update or create a Game_server.
     * @example
     * // Update or create a Game_server
     * const game_server = await prisma.game_server.upsert({
     *   create: {
     *     // ... data to create a Game_server
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_server we want to update
     *   }
     * })
     */
    upsert<T extends game_serverUpsertArgs>(args: SelectSubset<T, game_serverUpsertArgs<ExtArgs>>): Prisma__game_serverClient<$Result.GetResult<Prisma.$game_serverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Game_servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_serverCountArgs} args - Arguments to filter Game_servers to count.
     * @example
     * // Count the number of Game_servers
     * const count = await prisma.game_server.count({
     *   where: {
     *     // ... the filter for the Game_servers we want to count
     *   }
     * })
    **/
    count<T extends game_serverCountArgs>(
      args?: Subset<T, game_serverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_serverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_serverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_serverAggregateArgs>(args: Subset<T, Game_serverAggregateArgs>): Prisma.PrismaPromise<GetGame_serverAggregateType<T>>

    /**
     * Group by Game_server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_serverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_serverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_serverGroupByArgs['orderBy'] }
        : { orderBy?: game_serverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_serverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_serverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_server model
   */
  readonly fields: game_serverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_server.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_serverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updater<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_server model
   */
  interface game_serverFieldRefs {
    readonly id: FieldRef<"game_server", 'Int'>
    readonly game_slug: FieldRef<"game_server", 'String'>
    readonly game_title: FieldRef<"game_server", 'String'>
    readonly type: FieldRef<"game_server", 'String'>
    readonly port: FieldRef<"game_server", 'Int'>
    readonly description: FieldRef<"game_server", 'String'>
    readonly name: FieldRef<"game_server", 'String'>
    readonly monitor: FieldRef<"game_server", 'Boolean'>
    readonly last_detection_at: FieldRef<"game_server", 'DateTime'>
    readonly created_at: FieldRef<"game_server", 'DateTime'>
    readonly updated_at: FieldRef<"game_server", 'DateTime'>
    readonly created_by: FieldRef<"game_server", 'String'>
    readonly updated_by: FieldRef<"game_server", 'String'>
  }
    

  // Custom InputTypes
  /**
   * game_server findUnique
   */
  export type game_serverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * Filter, which game_server to fetch.
     */
    where: game_serverWhereUniqueInput
  }

  /**
   * game_server findUniqueOrThrow
   */
  export type game_serverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * Filter, which game_server to fetch.
     */
    where: game_serverWhereUniqueInput
  }

  /**
   * game_server findFirst
   */
  export type game_serverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * Filter, which game_server to fetch.
     */
    where?: game_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_servers to fetch.
     */
    orderBy?: game_serverOrderByWithRelationInput | game_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_servers.
     */
    cursor?: game_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_servers.
     */
    distinct?: Game_serverScalarFieldEnum | Game_serverScalarFieldEnum[]
  }

  /**
   * game_server findFirstOrThrow
   */
  export type game_serverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * Filter, which game_server to fetch.
     */
    where?: game_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_servers to fetch.
     */
    orderBy?: game_serverOrderByWithRelationInput | game_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_servers.
     */
    cursor?: game_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_servers.
     */
    distinct?: Game_serverScalarFieldEnum | Game_serverScalarFieldEnum[]
  }

  /**
   * game_server findMany
   */
  export type game_serverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * Filter, which game_servers to fetch.
     */
    where?: game_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_servers to fetch.
     */
    orderBy?: game_serverOrderByWithRelationInput | game_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_servers.
     */
    cursor?: game_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_servers.
     */
    skip?: number
    distinct?: Game_serverScalarFieldEnum | Game_serverScalarFieldEnum[]
  }

  /**
   * game_server create
   */
  export type game_serverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * The data needed to create a game_server.
     */
    data: XOR<game_serverCreateInput, game_serverUncheckedCreateInput>
  }

  /**
   * game_server createMany
   */
  export type game_serverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_servers.
     */
    data: game_serverCreateManyInput | game_serverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_server update
   */
  export type game_serverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * The data needed to update a game_server.
     */
    data: XOR<game_serverUpdateInput, game_serverUncheckedUpdateInput>
    /**
     * Choose, which game_server to update.
     */
    where: game_serverWhereUniqueInput
  }

  /**
   * game_server updateMany
   */
  export type game_serverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_servers.
     */
    data: XOR<game_serverUpdateManyMutationInput, game_serverUncheckedUpdateManyInput>
    /**
     * Filter which game_servers to update
     */
    where?: game_serverWhereInput
    /**
     * Limit how many game_servers to update.
     */
    limit?: number
  }

  /**
   * game_server upsert
   */
  export type game_serverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * The filter to search for the game_server to update in case it exists.
     */
    where: game_serverWhereUniqueInput
    /**
     * In case the game_server found by the `where` argument doesn't exist, create a new game_server with this data.
     */
    create: XOR<game_serverCreateInput, game_serverUncheckedCreateInput>
    /**
     * In case the game_server was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_serverUpdateInput, game_serverUncheckedUpdateInput>
  }

  /**
   * game_server delete
   */
  export type game_serverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
    /**
     * Filter which game_server to delete.
     */
    where: game_serverWhereUniqueInput
  }

  /**
   * game_server deleteMany
   */
  export type game_serverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_servers to delete
     */
    where?: game_serverWhereInput
    /**
     * Limit how many game_servers to delete.
     */
    limit?: number
  }

  /**
   * game_server without action
   */
  export type game_serverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_server
     */
    select?: game_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_server
     */
    omit?: game_serverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_serverInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    name: string | null
    nameplate_decoration_animated: string | null
    nameplate_decoration_static: string | null
    avatar_decoration_animated: string | null
    avatar_decoration_static: string | null
  }

  export type RoleMaxAggregateOutputType = {
    name: string | null
    nameplate_decoration_animated: string | null
    nameplate_decoration_static: string | null
    avatar_decoration_animated: string | null
    avatar_decoration_static: string | null
  }

  export type RoleCountAggregateOutputType = {
    name: number
    nameplate_decoration_animated: number
    nameplate_decoration_static: number
    avatar_decoration_animated: number
    avatar_decoration_static: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    name?: true
    nameplate_decoration_animated?: true
    nameplate_decoration_static?: true
    avatar_decoration_animated?: true
    avatar_decoration_static?: true
  }

  export type RoleMaxAggregateInputType = {
    name?: true
    nameplate_decoration_animated?: true
    nameplate_decoration_static?: true
    avatar_decoration_animated?: true
    avatar_decoration_static?: true
  }

  export type RoleCountAggregateInputType = {
    name?: true
    nameplate_decoration_animated?: true
    nameplate_decoration_static?: true
    avatar_decoration_animated?: true
    avatar_decoration_static?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    name: string
    nameplate_decoration_animated: string | null
    nameplate_decoration_static: string | null
    avatar_decoration_animated: string | null
    avatar_decoration_static: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    nameplate_decoration_animated?: boolean
    nameplate_decoration_static?: boolean
    avatar_decoration_animated?: boolean
    avatar_decoration_static?: boolean
  }, ExtArgs["result"]["role"]>



  export type roleSelectScalar = {
    name?: boolean
    nameplate_decoration_animated?: boolean
    nameplate_decoration_static?: boolean
    avatar_decoration_animated?: boolean
    avatar_decoration_static?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "nameplate_decoration_animated" | "nameplate_decoration_static" | "avatar_decoration_animated" | "avatar_decoration_static", ExtArgs["result"]["role"]>

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      nameplate_decoration_animated: string | null
      nameplate_decoration_static: string | null
      avatar_decoration_animated: string | null
      avatar_decoration_static: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const roleWithNameOnly = await prisma.role.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly name: FieldRef<"role", 'String'>
    readonly nameplate_decoration_animated: FieldRef<"role", 'String'>
    readonly nameplate_decoration_static: FieldRef<"role", 'String'>
    readonly avatar_decoration_animated: FieldRef<"role", 'String'>
    readonly avatar_decoration_static: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
  }


  /**
   * Model user_game
   */

  export type AggregateUser_game = {
    _count: User_gameCountAggregateOutputType | null
    _min: User_gameMinAggregateOutputType | null
    _max: User_gameMaxAggregateOutputType | null
  }

  export type User_gameMinAggregateOutputType = {
    user_id: string | null
    game_slug: string | null
    installed_at: Date | null
  }

  export type User_gameMaxAggregateOutputType = {
    user_id: string | null
    game_slug: string | null
    installed_at: Date | null
  }

  export type User_gameCountAggregateOutputType = {
    user_id: number
    game_slug: number
    installed_at: number
    _all: number
  }


  export type User_gameMinAggregateInputType = {
    user_id?: true
    game_slug?: true
    installed_at?: true
  }

  export type User_gameMaxAggregateInputType = {
    user_id?: true
    game_slug?: true
    installed_at?: true
  }

  export type User_gameCountAggregateInputType = {
    user_id?: true
    game_slug?: true
    installed_at?: true
    _all?: true
  }

  export type User_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_game to aggregate.
     */
    where?: user_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_games to fetch.
     */
    orderBy?: user_gameOrderByWithRelationInput | user_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_games
    **/
    _count?: true | User_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_gameMaxAggregateInputType
  }

  export type GetUser_gameAggregateType<T extends User_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_game[P]>
      : GetScalarType<T[P], AggregateUser_game[P]>
  }




  export type user_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_gameWhereInput
    orderBy?: user_gameOrderByWithAggregationInput | user_gameOrderByWithAggregationInput[]
    by: User_gameScalarFieldEnum[] | User_gameScalarFieldEnum
    having?: user_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_gameCountAggregateInputType | true
    _min?: User_gameMinAggregateInputType
    _max?: User_gameMaxAggregateInputType
  }

  export type User_gameGroupByOutputType = {
    user_id: string
    game_slug: string
    installed_at: Date | null
    _count: User_gameCountAggregateOutputType | null
    _min: User_gameMinAggregateOutputType | null
    _max: User_gameMaxAggregateOutputType | null
  }

  type GetUser_gameGroupByPayload<T extends user_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_gameGroupByOutputType[P]>
            : GetScalarType<T[P], User_gameGroupByOutputType[P]>
        }
      >
    >


  export type user_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    game_slug?: boolean
    installed_at?: boolean
  }, ExtArgs["result"]["user_game"]>



  export type user_gameSelectScalar = {
    user_id?: boolean
    game_slug?: boolean
    installed_at?: boolean
  }

  export type user_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "game_slug" | "installed_at", ExtArgs["result"]["user_game"]>

  export type $user_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_game"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      game_slug: string
      installed_at: Date | null
    }, ExtArgs["result"]["user_game"]>
    composites: {}
  }

  type user_gameGetPayload<S extends boolean | null | undefined | user_gameDefaultArgs> = $Result.GetResult<Prisma.$user_gamePayload, S>

  type user_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_gameCountAggregateInputType | true
    }

  export interface user_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_game'], meta: { name: 'user_game' } }
    /**
     * Find zero or one User_game that matches the filter.
     * @param {user_gameFindUniqueArgs} args - Arguments to find a User_game
     * @example
     * // Get one User_game
     * const user_game = await prisma.user_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_gameFindUniqueArgs>(args: SelectSubset<T, user_gameFindUniqueArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_gameFindUniqueOrThrowArgs} args - Arguments to find a User_game
     * @example
     * // Get one User_game
     * const user_game = await prisma.user_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, user_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_gameFindFirstArgs} args - Arguments to find a User_game
     * @example
     * // Get one User_game
     * const user_game = await prisma.user_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_gameFindFirstArgs>(args?: SelectSubset<T, user_gameFindFirstArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_gameFindFirstOrThrowArgs} args - Arguments to find a User_game
     * @example
     * // Get one User_game
     * const user_game = await prisma.user_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, user_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_games
     * const user_games = await prisma.user_game.findMany()
     * 
     * // Get first 10 User_games
     * const user_games = await prisma.user_game.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_gameWithUser_idOnly = await prisma.user_game.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_gameFindManyArgs>(args?: SelectSubset<T, user_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_game.
     * @param {user_gameCreateArgs} args - Arguments to create a User_game.
     * @example
     * // Create one User_game
     * const User_game = await prisma.user_game.create({
     *   data: {
     *     // ... data to create a User_game
     *   }
     * })
     * 
     */
    create<T extends user_gameCreateArgs>(args: SelectSubset<T, user_gameCreateArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_games.
     * @param {user_gameCreateManyArgs} args - Arguments to create many User_games.
     * @example
     * // Create many User_games
     * const user_game = await prisma.user_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_gameCreateManyArgs>(args?: SelectSubset<T, user_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_game.
     * @param {user_gameDeleteArgs} args - Arguments to delete one User_game.
     * @example
     * // Delete one User_game
     * const User_game = await prisma.user_game.delete({
     *   where: {
     *     // ... filter to delete one User_game
     *   }
     * })
     * 
     */
    delete<T extends user_gameDeleteArgs>(args: SelectSubset<T, user_gameDeleteArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_game.
     * @param {user_gameUpdateArgs} args - Arguments to update one User_game.
     * @example
     * // Update one User_game
     * const user_game = await prisma.user_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_gameUpdateArgs>(args: SelectSubset<T, user_gameUpdateArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_games.
     * @param {user_gameDeleteManyArgs} args - Arguments to filter User_games to delete.
     * @example
     * // Delete a few User_games
     * const { count } = await prisma.user_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_gameDeleteManyArgs>(args?: SelectSubset<T, user_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_games
     * const user_game = await prisma.user_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_gameUpdateManyArgs>(args: SelectSubset<T, user_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_game.
     * @param {user_gameUpsertArgs} args - Arguments to update or create a User_game.
     * @example
     * // Update or create a User_game
     * const user_game = await prisma.user_game.upsert({
     *   create: {
     *     // ... data to create a User_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_game we want to update
     *   }
     * })
     */
    upsert<T extends user_gameUpsertArgs>(args: SelectSubset<T, user_gameUpsertArgs<ExtArgs>>): Prisma__user_gameClient<$Result.GetResult<Prisma.$user_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_gameCountArgs} args - Arguments to filter User_games to count.
     * @example
     * // Count the number of User_games
     * const count = await prisma.user_game.count({
     *   where: {
     *     // ... the filter for the User_games we want to count
     *   }
     * })
    **/
    count<T extends user_gameCountArgs>(
      args?: Subset<T, user_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_gameAggregateArgs>(args: Subset<T, User_gameAggregateArgs>): Prisma.PrismaPromise<GetUser_gameAggregateType<T>>

    /**
     * Group by User_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_gameGroupByArgs['orderBy'] }
        : { orderBy?: user_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_game model
   */
  readonly fields: user_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_game model
   */
  interface user_gameFieldRefs {
    readonly user_id: FieldRef<"user_game", 'String'>
    readonly game_slug: FieldRef<"user_game", 'String'>
    readonly installed_at: FieldRef<"user_game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_game findUnique
   */
  export type user_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * Filter, which user_game to fetch.
     */
    where: user_gameWhereUniqueInput
  }

  /**
   * user_game findUniqueOrThrow
   */
  export type user_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * Filter, which user_game to fetch.
     */
    where: user_gameWhereUniqueInput
  }

  /**
   * user_game findFirst
   */
  export type user_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * Filter, which user_game to fetch.
     */
    where?: user_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_games to fetch.
     */
    orderBy?: user_gameOrderByWithRelationInput | user_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_games.
     */
    cursor?: user_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_games.
     */
    distinct?: User_gameScalarFieldEnum | User_gameScalarFieldEnum[]
  }

  /**
   * user_game findFirstOrThrow
   */
  export type user_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * Filter, which user_game to fetch.
     */
    where?: user_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_games to fetch.
     */
    orderBy?: user_gameOrderByWithRelationInput | user_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_games.
     */
    cursor?: user_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_games.
     */
    distinct?: User_gameScalarFieldEnum | User_gameScalarFieldEnum[]
  }

  /**
   * user_game findMany
   */
  export type user_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * Filter, which user_games to fetch.
     */
    where?: user_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_games to fetch.
     */
    orderBy?: user_gameOrderByWithRelationInput | user_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_games.
     */
    cursor?: user_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_games.
     */
    skip?: number
    distinct?: User_gameScalarFieldEnum | User_gameScalarFieldEnum[]
  }

  /**
   * user_game create
   */
  export type user_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * The data needed to create a user_game.
     */
    data: XOR<user_gameCreateInput, user_gameUncheckedCreateInput>
  }

  /**
   * user_game createMany
   */
  export type user_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_games.
     */
    data: user_gameCreateManyInput | user_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_game update
   */
  export type user_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * The data needed to update a user_game.
     */
    data: XOR<user_gameUpdateInput, user_gameUncheckedUpdateInput>
    /**
     * Choose, which user_game to update.
     */
    where: user_gameWhereUniqueInput
  }

  /**
   * user_game updateMany
   */
  export type user_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_games.
     */
    data: XOR<user_gameUpdateManyMutationInput, user_gameUncheckedUpdateManyInput>
    /**
     * Filter which user_games to update
     */
    where?: user_gameWhereInput
    /**
     * Limit how many user_games to update.
     */
    limit?: number
  }

  /**
   * user_game upsert
   */
  export type user_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * The filter to search for the user_game to update in case it exists.
     */
    where: user_gameWhereUniqueInput
    /**
     * In case the user_game found by the `where` argument doesn't exist, create a new user_game with this data.
     */
    create: XOR<user_gameCreateInput, user_gameUncheckedCreateInput>
    /**
     * In case the user_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_gameUpdateInput, user_gameUncheckedUpdateInput>
  }

  /**
   * user_game delete
   */
  export type user_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
    /**
     * Filter which user_game to delete.
     */
    where: user_gameWhereUniqueInput
  }

  /**
   * user_game deleteMany
   */
  export type user_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_games to delete
     */
    where?: user_gameWhereInput
    /**
     * Limit how many user_games to delete.
     */
    limit?: number
  }

  /**
   * user_game without action
   */
  export type user_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game
     */
    select?: user_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game
     */
    omit?: user_gameOmit<ExtArgs> | null
  }


  /**
   * Model user_game_favorite
   */

  export type AggregateUser_game_favorite = {
    _count: User_game_favoriteCountAggregateOutputType | null
    _min: User_game_favoriteMinAggregateOutputType | null
    _max: User_game_favoriteMaxAggregateOutputType | null
  }

  export type User_game_favoriteMinAggregateOutputType = {
    user_id: string | null
    game_slug: string | null
    addedAt: Date | null
  }

  export type User_game_favoriteMaxAggregateOutputType = {
    user_id: string | null
    game_slug: string | null
    addedAt: Date | null
  }

  export type User_game_favoriteCountAggregateOutputType = {
    user_id: number
    game_slug: number
    addedAt: number
    _all: number
  }


  export type User_game_favoriteMinAggregateInputType = {
    user_id?: true
    game_slug?: true
    addedAt?: true
  }

  export type User_game_favoriteMaxAggregateInputType = {
    user_id?: true
    game_slug?: true
    addedAt?: true
  }

  export type User_game_favoriteCountAggregateInputType = {
    user_id?: true
    game_slug?: true
    addedAt?: true
    _all?: true
  }

  export type User_game_favoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_game_favorite to aggregate.
     */
    where?: user_game_favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_game_favorites to fetch.
     */
    orderBy?: user_game_favoriteOrderByWithRelationInput | user_game_favoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_game_favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_game_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_game_favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_game_favorites
    **/
    _count?: true | User_game_favoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_game_favoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_game_favoriteMaxAggregateInputType
  }

  export type GetUser_game_favoriteAggregateType<T extends User_game_favoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_game_favorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_game_favorite[P]>
      : GetScalarType<T[P], AggregateUser_game_favorite[P]>
  }




  export type user_game_favoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_game_favoriteWhereInput
    orderBy?: user_game_favoriteOrderByWithAggregationInput | user_game_favoriteOrderByWithAggregationInput[]
    by: User_game_favoriteScalarFieldEnum[] | User_game_favoriteScalarFieldEnum
    having?: user_game_favoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_game_favoriteCountAggregateInputType | true
    _min?: User_game_favoriteMinAggregateInputType
    _max?: User_game_favoriteMaxAggregateInputType
  }

  export type User_game_favoriteGroupByOutputType = {
    user_id: string
    game_slug: string
    addedAt: Date
    _count: User_game_favoriteCountAggregateOutputType | null
    _min: User_game_favoriteMinAggregateOutputType | null
    _max: User_game_favoriteMaxAggregateOutputType | null
  }

  type GetUser_game_favoriteGroupByPayload<T extends user_game_favoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_game_favoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_game_favoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_game_favoriteGroupByOutputType[P]>
            : GetScalarType<T[P], User_game_favoriteGroupByOutputType[P]>
        }
      >
    >


  export type user_game_favoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    game_slug?: boolean
    addedAt?: boolean
  }, ExtArgs["result"]["user_game_favorite"]>



  export type user_game_favoriteSelectScalar = {
    user_id?: boolean
    game_slug?: boolean
    addedAt?: boolean
  }

  export type user_game_favoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "game_slug" | "addedAt", ExtArgs["result"]["user_game_favorite"]>

  export type $user_game_favoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_game_favorite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      game_slug: string
      addedAt: Date
    }, ExtArgs["result"]["user_game_favorite"]>
    composites: {}
  }

  type user_game_favoriteGetPayload<S extends boolean | null | undefined | user_game_favoriteDefaultArgs> = $Result.GetResult<Prisma.$user_game_favoritePayload, S>

  type user_game_favoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_game_favoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_game_favoriteCountAggregateInputType | true
    }

  export interface user_game_favoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_game_favorite'], meta: { name: 'user_game_favorite' } }
    /**
     * Find zero or one User_game_favorite that matches the filter.
     * @param {user_game_favoriteFindUniqueArgs} args - Arguments to find a User_game_favorite
     * @example
     * // Get one User_game_favorite
     * const user_game_favorite = await prisma.user_game_favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_game_favoriteFindUniqueArgs>(args: SelectSubset<T, user_game_favoriteFindUniqueArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_game_favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_game_favoriteFindUniqueOrThrowArgs} args - Arguments to find a User_game_favorite
     * @example
     * // Get one User_game_favorite
     * const user_game_favorite = await prisma.user_game_favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_game_favoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, user_game_favoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_game_favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_game_favoriteFindFirstArgs} args - Arguments to find a User_game_favorite
     * @example
     * // Get one User_game_favorite
     * const user_game_favorite = await prisma.user_game_favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_game_favoriteFindFirstArgs>(args?: SelectSubset<T, user_game_favoriteFindFirstArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_game_favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_game_favoriteFindFirstOrThrowArgs} args - Arguments to find a User_game_favorite
     * @example
     * // Get one User_game_favorite
     * const user_game_favorite = await prisma.user_game_favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_game_favoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, user_game_favoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_game_favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_game_favoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_game_favorites
     * const user_game_favorites = await prisma.user_game_favorite.findMany()
     * 
     * // Get first 10 User_game_favorites
     * const user_game_favorites = await prisma.user_game_favorite.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_game_favoriteWithUser_idOnly = await prisma.user_game_favorite.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_game_favoriteFindManyArgs>(args?: SelectSubset<T, user_game_favoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_game_favorite.
     * @param {user_game_favoriteCreateArgs} args - Arguments to create a User_game_favorite.
     * @example
     * // Create one User_game_favorite
     * const User_game_favorite = await prisma.user_game_favorite.create({
     *   data: {
     *     // ... data to create a User_game_favorite
     *   }
     * })
     * 
     */
    create<T extends user_game_favoriteCreateArgs>(args: SelectSubset<T, user_game_favoriteCreateArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_game_favorites.
     * @param {user_game_favoriteCreateManyArgs} args - Arguments to create many User_game_favorites.
     * @example
     * // Create many User_game_favorites
     * const user_game_favorite = await prisma.user_game_favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_game_favoriteCreateManyArgs>(args?: SelectSubset<T, user_game_favoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_game_favorite.
     * @param {user_game_favoriteDeleteArgs} args - Arguments to delete one User_game_favorite.
     * @example
     * // Delete one User_game_favorite
     * const User_game_favorite = await prisma.user_game_favorite.delete({
     *   where: {
     *     // ... filter to delete one User_game_favorite
     *   }
     * })
     * 
     */
    delete<T extends user_game_favoriteDeleteArgs>(args: SelectSubset<T, user_game_favoriteDeleteArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_game_favorite.
     * @param {user_game_favoriteUpdateArgs} args - Arguments to update one User_game_favorite.
     * @example
     * // Update one User_game_favorite
     * const user_game_favorite = await prisma.user_game_favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_game_favoriteUpdateArgs>(args: SelectSubset<T, user_game_favoriteUpdateArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_game_favorites.
     * @param {user_game_favoriteDeleteManyArgs} args - Arguments to filter User_game_favorites to delete.
     * @example
     * // Delete a few User_game_favorites
     * const { count } = await prisma.user_game_favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_game_favoriteDeleteManyArgs>(args?: SelectSubset<T, user_game_favoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_game_favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_game_favoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_game_favorites
     * const user_game_favorite = await prisma.user_game_favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_game_favoriteUpdateManyArgs>(args: SelectSubset<T, user_game_favoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_game_favorite.
     * @param {user_game_favoriteUpsertArgs} args - Arguments to update or create a User_game_favorite.
     * @example
     * // Update or create a User_game_favorite
     * const user_game_favorite = await prisma.user_game_favorite.upsert({
     *   create: {
     *     // ... data to create a User_game_favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_game_favorite we want to update
     *   }
     * })
     */
    upsert<T extends user_game_favoriteUpsertArgs>(args: SelectSubset<T, user_game_favoriteUpsertArgs<ExtArgs>>): Prisma__user_game_favoriteClient<$Result.GetResult<Prisma.$user_game_favoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_game_favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_game_favoriteCountArgs} args - Arguments to filter User_game_favorites to count.
     * @example
     * // Count the number of User_game_favorites
     * const count = await prisma.user_game_favorite.count({
     *   where: {
     *     // ... the filter for the User_game_favorites we want to count
     *   }
     * })
    **/
    count<T extends user_game_favoriteCountArgs>(
      args?: Subset<T, user_game_favoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_game_favoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_game_favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_game_favoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_game_favoriteAggregateArgs>(args: Subset<T, User_game_favoriteAggregateArgs>): Prisma.PrismaPromise<GetUser_game_favoriteAggregateType<T>>

    /**
     * Group by User_game_favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_game_favoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_game_favoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_game_favoriteGroupByArgs['orderBy'] }
        : { orderBy?: user_game_favoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_game_favoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_game_favoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_game_favorite model
   */
  readonly fields: user_game_favoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_game_favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_game_favoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_game_favorite model
   */
  interface user_game_favoriteFieldRefs {
    readonly user_id: FieldRef<"user_game_favorite", 'String'>
    readonly game_slug: FieldRef<"user_game_favorite", 'String'>
    readonly addedAt: FieldRef<"user_game_favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_game_favorite findUnique
   */
  export type user_game_favoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * Filter, which user_game_favorite to fetch.
     */
    where: user_game_favoriteWhereUniqueInput
  }

  /**
   * user_game_favorite findUniqueOrThrow
   */
  export type user_game_favoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * Filter, which user_game_favorite to fetch.
     */
    where: user_game_favoriteWhereUniqueInput
  }

  /**
   * user_game_favorite findFirst
   */
  export type user_game_favoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * Filter, which user_game_favorite to fetch.
     */
    where?: user_game_favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_game_favorites to fetch.
     */
    orderBy?: user_game_favoriteOrderByWithRelationInput | user_game_favoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_game_favorites.
     */
    cursor?: user_game_favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_game_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_game_favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_game_favorites.
     */
    distinct?: User_game_favoriteScalarFieldEnum | User_game_favoriteScalarFieldEnum[]
  }

  /**
   * user_game_favorite findFirstOrThrow
   */
  export type user_game_favoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * Filter, which user_game_favorite to fetch.
     */
    where?: user_game_favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_game_favorites to fetch.
     */
    orderBy?: user_game_favoriteOrderByWithRelationInput | user_game_favoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_game_favorites.
     */
    cursor?: user_game_favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_game_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_game_favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_game_favorites.
     */
    distinct?: User_game_favoriteScalarFieldEnum | User_game_favoriteScalarFieldEnum[]
  }

  /**
   * user_game_favorite findMany
   */
  export type user_game_favoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * Filter, which user_game_favorites to fetch.
     */
    where?: user_game_favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_game_favorites to fetch.
     */
    orderBy?: user_game_favoriteOrderByWithRelationInput | user_game_favoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_game_favorites.
     */
    cursor?: user_game_favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_game_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_game_favorites.
     */
    skip?: number
    distinct?: User_game_favoriteScalarFieldEnum | User_game_favoriteScalarFieldEnum[]
  }

  /**
   * user_game_favorite create
   */
  export type user_game_favoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * The data needed to create a user_game_favorite.
     */
    data: XOR<user_game_favoriteCreateInput, user_game_favoriteUncheckedCreateInput>
  }

  /**
   * user_game_favorite createMany
   */
  export type user_game_favoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_game_favorites.
     */
    data: user_game_favoriteCreateManyInput | user_game_favoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_game_favorite update
   */
  export type user_game_favoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * The data needed to update a user_game_favorite.
     */
    data: XOR<user_game_favoriteUpdateInput, user_game_favoriteUncheckedUpdateInput>
    /**
     * Choose, which user_game_favorite to update.
     */
    where: user_game_favoriteWhereUniqueInput
  }

  /**
   * user_game_favorite updateMany
   */
  export type user_game_favoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_game_favorites.
     */
    data: XOR<user_game_favoriteUpdateManyMutationInput, user_game_favoriteUncheckedUpdateManyInput>
    /**
     * Filter which user_game_favorites to update
     */
    where?: user_game_favoriteWhereInput
    /**
     * Limit how many user_game_favorites to update.
     */
    limit?: number
  }

  /**
   * user_game_favorite upsert
   */
  export type user_game_favoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * The filter to search for the user_game_favorite to update in case it exists.
     */
    where: user_game_favoriteWhereUniqueInput
    /**
     * In case the user_game_favorite found by the `where` argument doesn't exist, create a new user_game_favorite with this data.
     */
    create: XOR<user_game_favoriteCreateInput, user_game_favoriteUncheckedCreateInput>
    /**
     * In case the user_game_favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_game_favoriteUpdateInput, user_game_favoriteUncheckedUpdateInput>
  }

  /**
   * user_game_favorite delete
   */
  export type user_game_favoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
    /**
     * Filter which user_game_favorite to delete.
     */
    where: user_game_favoriteWhereUniqueInput
  }

  /**
   * user_game_favorite deleteMany
   */
  export type user_game_favoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_game_favorites to delete
     */
    where?: user_game_favoriteWhereInput
    /**
     * Limit how many user_game_favorites to delete.
     */
    limit?: number
  }

  /**
   * user_game_favorite without action
   */
  export type user_game_favoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_game_favorite
     */
    select?: user_game_favoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_game_favorite
     */
    omit?: user_game_favoriteOmit<ExtArgs> | null
  }


  /**
   * Model faq
   */

  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqAvgAggregateOutputType = {
    id: number | null
    position: number | null
  }

  export type FaqSumAggregateOutputType = {
    id: number | null
    position: number | null
  }

  export type FaqMinAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    published: boolean | null
    position: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type FaqMaxAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    published: boolean | null
    position: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    updated_by: string | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    published: number
    position: number
    created_at: number
    updated_at: number
    created_by: number
    updated_by: number
    _all: number
  }


  export type FaqAvgAggregateInputType = {
    id?: true
    position?: true
  }

  export type FaqSumAggregateInputType = {
    id?: true
    position?: true
  }

  export type FaqMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    published?: true
    position?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    published?: true
    position?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    published?: true
    position?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type FaqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faq to aggregate.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type faqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqWhereInput
    orderBy?: faqOrderByWithAggregationInput | faqOrderByWithAggregationInput[]
    by: FaqScalarFieldEnum[] | FaqScalarFieldEnum
    having?: faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _avg?: FaqAvgAggregateInputType
    _sum?: FaqSumAggregateInputType
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }

  export type FaqGroupByOutputType = {
    id: number
    question: string
    answer: string
    published: boolean
    position: number
    created_at: Date
    updated_at: Date
    created_by: string
    updated_by: string
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends faqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type faqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    published?: boolean
    position?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faq"]>



  export type faqSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    published?: boolean
    position?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
  }

  export type faqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "published" | "position" | "created_at" | "updated_at" | "created_by" | "updated_by", ExtArgs["result"]["faq"]>
  export type faqInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $faqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faq"
    objects: {
      creator: Prisma.$userPayload<ExtArgs>
      updater: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      answer: string
      published: boolean
      position: number
      created_at: Date
      updated_at: Date
      created_by: string
      updated_by: string
    }, ExtArgs["result"]["faq"]>
    composites: {}
  }

  type faqGetPayload<S extends boolean | null | undefined | faqDefaultArgs> = $Result.GetResult<Prisma.$faqPayload, S>

  type faqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<faqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqCountAggregateInputType | true
    }

  export interface faqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faq'], meta: { name: 'faq' } }
    /**
     * Find zero or one Faq that matches the filter.
     * @param {faqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faqFindUniqueArgs>(args: SelectSubset<T, faqFindUniqueArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faqFindUniqueOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faqFindUniqueOrThrowArgs>(args: SelectSubset<T, faqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faqFindFirstArgs>(args?: SelectSubset<T, faqFindFirstArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindFirstOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faqFindFirstOrThrowArgs>(args?: SelectSubset<T, faqFindFirstOrThrowArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends faqFindManyArgs>(args?: SelectSubset<T, faqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faq.
     * @param {faqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
     */
    create<T extends faqCreateArgs>(args: SelectSubset<T, faqCreateArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {faqCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faq = await prisma.faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends faqCreateManyArgs>(args?: SelectSubset<T, faqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {faqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
     */
    delete<T extends faqDeleteArgs>(args: SelectSubset<T, faqDeleteArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faq.
     * @param {faqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends faqUpdateArgs>(args: SelectSubset<T, faqUpdateArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {faqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends faqDeleteManyArgs>(args?: SelectSubset<T, faqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends faqUpdateManyArgs>(args: SelectSubset<T, faqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {faqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
     */
    upsert<T extends faqUpsertArgs>(args: SelectSubset<T, faqUpsertArgs<ExtArgs>>): Prisma__faqClient<$Result.GetResult<Prisma.$faqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends faqCountArgs>(
      args?: Subset<T, faqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): Prisma.PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faqGroupByArgs['orderBy'] }
        : { orderBy?: faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faq model
   */
  readonly fields: faqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updater<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the faq model
   */
  interface faqFieldRefs {
    readonly id: FieldRef<"faq", 'Int'>
    readonly question: FieldRef<"faq", 'String'>
    readonly answer: FieldRef<"faq", 'String'>
    readonly published: FieldRef<"faq", 'Boolean'>
    readonly position: FieldRef<"faq", 'Int'>
    readonly created_at: FieldRef<"faq", 'DateTime'>
    readonly updated_at: FieldRef<"faq", 'DateTime'>
    readonly created_by: FieldRef<"faq", 'String'>
    readonly updated_by: FieldRef<"faq", 'String'>
  }
    

  // Custom InputTypes
  /**
   * faq findUnique
   */
  export type faqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq findUniqueOrThrow
   */
  export type faqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq findFirst
   */
  export type faqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * faq findFirstOrThrow
   */
  export type faqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * Filter, which faq to fetch.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * faq findMany
   */
  export type faqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqOrderByWithRelationInput | faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faqs.
     */
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * faq create
   */
  export type faqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * The data needed to create a faq.
     */
    data: XOR<faqCreateInput, faqUncheckedCreateInput>
  }

  /**
   * faq createMany
   */
  export type faqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faqs.
     */
    data: faqCreateManyInput | faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * faq update
   */
  export type faqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * The data needed to update a faq.
     */
    data: XOR<faqUpdateInput, faqUncheckedUpdateInput>
    /**
     * Choose, which faq to update.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq updateMany
   */
  export type faqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faqs.
     */
    data: XOR<faqUpdateManyMutationInput, faqUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     */
    where?: faqWhereInput
    /**
     * Limit how many faqs to update.
     */
    limit?: number
  }

  /**
   * faq upsert
   */
  export type faqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * The filter to search for the faq to update in case it exists.
     */
    where: faqWhereUniqueInput
    /**
     * In case the faq found by the `where` argument doesn't exist, create a new faq with this data.
     */
    create: XOR<faqCreateInput, faqUncheckedCreateInput>
    /**
     * In case the faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faqUpdateInput, faqUncheckedUpdateInput>
  }

  /**
   * faq delete
   */
  export type faqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
    /**
     * Filter which faq to delete.
     */
    where: faqWhereUniqueInput
  }

  /**
   * faq deleteMany
   */
  export type faqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to delete
     */
    where?: faqWhereInput
    /**
     * Limit how many faqs to delete.
     */
    limit?: number
  }

  /**
   * faq without action
   */
  export type faqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faq
     */
    select?: faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faq
     */
    omit?: faqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faqInclude<ExtArgs> | null
  }


  /**
   * Model guild
   */

  export type AggregateGuild = {
    _count: GuildCountAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  export type GuildMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuildMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuildCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    icon: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuildMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuildMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuildCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild to aggregate.
     */
    where?: guildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildOrderByWithRelationInput | guildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guilds
    **/
    _count?: true | GuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMaxAggregateInputType
  }

  export type GetGuildAggregateType<T extends GuildAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild[P]>
      : GetScalarType<T[P], AggregateGuild[P]>
  }




  export type guildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildWhereInput
    orderBy?: guildOrderByWithAggregationInput | guildOrderByWithAggregationInput[]
    by: GuildScalarFieldEnum[] | GuildScalarFieldEnum
    having?: guildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildCountAggregateInputType | true
    _min?: GuildMinAggregateInputType
    _max?: GuildMaxAggregateInputType
  }

  export type GuildGroupByOutputType = {
    id: string
    name: string
    slug: string
    icon: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: GuildCountAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  type GetGuildGroupByPayload<T extends guildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildGroupByOutputType[P]>
            : GetScalarType<T[P], GuildGroupByOutputType[P]>
        }
      >
    >


  export type guildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channels?: boolean | guild$channelsArgs<ExtArgs>
    owner?: boolean | userDefaultArgs<ExtArgs>
    members?: boolean | guild$membersArgs<ExtArgs>
    room?: boolean | guild$roomArgs<ExtArgs>
    _count?: boolean | GuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guild"]>



  export type guildSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type guildOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "icon" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["guild"]>
  export type guildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | guild$channelsArgs<ExtArgs>
    owner?: boolean | userDefaultArgs<ExtArgs>
    members?: boolean | guild$membersArgs<ExtArgs>
    room?: boolean | guild$roomArgs<ExtArgs>
    _count?: boolean | GuildCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $guildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guild"
    objects: {
      channels: Prisma.$channelPayload<ExtArgs>[]
      owner: Prisma.$userPayload<ExtArgs>
      members: Prisma.$guild_memberPayload<ExtArgs>[]
      room: Prisma.$roomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      icon: string | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guild"]>
    composites: {}
  }

  type guildGetPayload<S extends boolean | null | undefined | guildDefaultArgs> = $Result.GetResult<Prisma.$guildPayload, S>

  type guildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<guildFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildCountAggregateInputType | true
    }

  export interface guildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guild'], meta: { name: 'guild' } }
    /**
     * Find zero or one Guild that matches the filter.
     * @param {guildFindUniqueArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guildFindUniqueArgs>(args: SelectSubset<T, guildFindUniqueArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guild that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {guildFindUniqueOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guildFindUniqueOrThrowArgs>(args: SelectSubset<T, guildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildFindFirstArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guildFindFirstArgs>(args?: SelectSubset<T, guildFindFirstArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildFindFirstOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guildFindFirstOrThrowArgs>(args?: SelectSubset<T, guildFindFirstOrThrowArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guild.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildWithIdOnly = await prisma.guild.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guildFindManyArgs>(args?: SelectSubset<T, guildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guild.
     * @param {guildCreateArgs} args - Arguments to create a Guild.
     * @example
     * // Create one Guild
     * const Guild = await prisma.guild.create({
     *   data: {
     *     // ... data to create a Guild
     *   }
     * })
     * 
     */
    create<T extends guildCreateArgs>(args: SelectSubset<T, guildCreateArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guilds.
     * @param {guildCreateManyArgs} args - Arguments to create many Guilds.
     * @example
     * // Create many Guilds
     * const guild = await prisma.guild.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guildCreateManyArgs>(args?: SelectSubset<T, guildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild.
     * @param {guildDeleteArgs} args - Arguments to delete one Guild.
     * @example
     * // Delete one Guild
     * const Guild = await prisma.guild.delete({
     *   where: {
     *     // ... filter to delete one Guild
     *   }
     * })
     * 
     */
    delete<T extends guildDeleteArgs>(args: SelectSubset<T, guildDeleteArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guild.
     * @param {guildUpdateArgs} args - Arguments to update one Guild.
     * @example
     * // Update one Guild
     * const guild = await prisma.guild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guildUpdateArgs>(args: SelectSubset<T, guildUpdateArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guilds.
     * @param {guildDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guildDeleteManyArgs>(args?: SelectSubset<T, guildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guildUpdateManyArgs>(args: SelectSubset<T, guildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild.
     * @param {guildUpsertArgs} args - Arguments to update or create a Guild.
     * @example
     * // Update or create a Guild
     * const guild = await prisma.guild.upsert({
     *   create: {
     *     // ... data to create a Guild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild we want to update
     *   }
     * })
     */
    upsert<T extends guildUpsertArgs>(args: SelectSubset<T, guildUpsertArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guild.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends guildCountArgs>(
      args?: Subset<T, guildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildAggregateArgs>(args: Subset<T, GuildAggregateArgs>): Prisma.PrismaPromise<GetGuildAggregateType<T>>

    /**
     * Group by Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guildGroupByArgs['orderBy'] }
        : { orderBy?: guildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guild model
   */
  readonly fields: guildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channels<T extends guild$channelsArgs<ExtArgs> = {}>(args?: Subset<T, guild$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owner<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends guild$membersArgs<ExtArgs> = {}>(args?: Subset<T, guild$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room<T extends guild$roomArgs<ExtArgs> = {}>(args?: Subset<T, guild$roomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guild model
   */
  interface guildFieldRefs {
    readonly id: FieldRef<"guild", 'String'>
    readonly name: FieldRef<"guild", 'String'>
    readonly slug: FieldRef<"guild", 'String'>
    readonly icon: FieldRef<"guild", 'String'>
    readonly ownerId: FieldRef<"guild", 'String'>
    readonly createdAt: FieldRef<"guild", 'DateTime'>
    readonly updatedAt: FieldRef<"guild", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * guild findUnique
   */
  export type guildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * Filter, which guild to fetch.
     */
    where: guildWhereUniqueInput
  }

  /**
   * guild findUniqueOrThrow
   */
  export type guildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * Filter, which guild to fetch.
     */
    where: guildWhereUniqueInput
  }

  /**
   * guild findFirst
   */
  export type guildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * Filter, which guild to fetch.
     */
    where?: guildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildOrderByWithRelationInput | guildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
     */
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * guild findFirstOrThrow
   */
  export type guildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * Filter, which guild to fetch.
     */
    where?: guildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildOrderByWithRelationInput | guildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
     */
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * guild findMany
   */
  export type guildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildOrderByWithRelationInput | guildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guilds.
     */
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * guild create
   */
  export type guildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * The data needed to create a guild.
     */
    data: XOR<guildCreateInput, guildUncheckedCreateInput>
  }

  /**
   * guild createMany
   */
  export type guildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guilds.
     */
    data: guildCreateManyInput | guildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guild update
   */
  export type guildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * The data needed to update a guild.
     */
    data: XOR<guildUpdateInput, guildUncheckedUpdateInput>
    /**
     * Choose, which guild to update.
     */
    where: guildWhereUniqueInput
  }

  /**
   * guild updateMany
   */
  export type guildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guilds.
     */
    data: XOR<guildUpdateManyMutationInput, guildUncheckedUpdateManyInput>
    /**
     * Filter which guilds to update
     */
    where?: guildWhereInput
    /**
     * Limit how many guilds to update.
     */
    limit?: number
  }

  /**
   * guild upsert
   */
  export type guildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * The filter to search for the guild to update in case it exists.
     */
    where: guildWhereUniqueInput
    /**
     * In case the guild found by the `where` argument doesn't exist, create a new guild with this data.
     */
    create: XOR<guildCreateInput, guildUncheckedCreateInput>
    /**
     * In case the guild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildUpdateInput, guildUncheckedUpdateInput>
  }

  /**
   * guild delete
   */
  export type guildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    /**
     * Filter which guild to delete.
     */
    where: guildWhereUniqueInput
  }

  /**
   * guild deleteMany
   */
  export type guildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guilds to delete
     */
    where?: guildWhereInput
    /**
     * Limit how many guilds to delete.
     */
    limit?: number
  }

  /**
   * guild.channels
   */
  export type guild$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    cursor?: channelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * guild.members
   */
  export type guild$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    where?: guild_memberWhereInput
    orderBy?: guild_memberOrderByWithRelationInput | guild_memberOrderByWithRelationInput[]
    cursor?: guild_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Guild_memberScalarFieldEnum | Guild_memberScalarFieldEnum[]
  }

  /**
   * guild.room
   */
  export type guild$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    where?: roomWhereInput
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    cursor?: roomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * guild without action
   */
  export type guildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
  }


  /**
   * Model guild_member
   */

  export type AggregateGuild_member = {
    _count: Guild_memberCountAggregateOutputType | null
    _min: Guild_memberMinAggregateOutputType | null
    _max: Guild_memberMaxAggregateOutputType | null
  }

  export type Guild_memberMinAggregateOutputType = {
    id: string | null
    guildId: string | null
    userId: string | null
    nickname: string | null
    roles: string | null
    joinedAt: Date | null
  }

  export type Guild_memberMaxAggregateOutputType = {
    id: string | null
    guildId: string | null
    userId: string | null
    nickname: string | null
    roles: string | null
    joinedAt: Date | null
  }

  export type Guild_memberCountAggregateOutputType = {
    id: number
    guildId: number
    userId: number
    nickname: number
    roles: number
    joinedAt: number
    _all: number
  }


  export type Guild_memberMinAggregateInputType = {
    id?: true
    guildId?: true
    userId?: true
    nickname?: true
    roles?: true
    joinedAt?: true
  }

  export type Guild_memberMaxAggregateInputType = {
    id?: true
    guildId?: true
    userId?: true
    nickname?: true
    roles?: true
    joinedAt?: true
  }

  export type Guild_memberCountAggregateInputType = {
    id?: true
    guildId?: true
    userId?: true
    nickname?: true
    roles?: true
    joinedAt?: true
    _all?: true
  }

  export type Guild_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_member to aggregate.
     */
    where?: guild_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_members to fetch.
     */
    orderBy?: guild_memberOrderByWithRelationInput | guild_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guild_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guild_members
    **/
    _count?: true | Guild_memberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Guild_memberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Guild_memberMaxAggregateInputType
  }

  export type GetGuild_memberAggregateType<T extends Guild_memberAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild_member]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild_member[P]>
      : GetScalarType<T[P], AggregateGuild_member[P]>
  }




  export type guild_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guild_memberWhereInput
    orderBy?: guild_memberOrderByWithAggregationInput | guild_memberOrderByWithAggregationInput[]
    by: Guild_memberScalarFieldEnum[] | Guild_memberScalarFieldEnum
    having?: guild_memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Guild_memberCountAggregateInputType | true
    _min?: Guild_memberMinAggregateInputType
    _max?: Guild_memberMaxAggregateInputType
  }

  export type Guild_memberGroupByOutputType = {
    id: string
    guildId: string
    userId: string
    nickname: string | null
    roles: string | null
    joinedAt: Date
    _count: Guild_memberCountAggregateOutputType | null
    _min: Guild_memberMinAggregateOutputType | null
    _max: Guild_memberMaxAggregateOutputType | null
  }

  type GetGuild_memberGroupByPayload<T extends guild_memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Guild_memberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Guild_memberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Guild_memberGroupByOutputType[P]>
            : GetScalarType<T[P], Guild_memberGroupByOutputType[P]>
        }
      >
    >


  export type guild_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    userId?: boolean
    nickname?: boolean
    roles?: boolean
    joinedAt?: boolean
    guild?: boolean | guildDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guild_member"]>



  export type guild_memberSelectScalar = {
    id?: boolean
    guildId?: boolean
    userId?: boolean
    nickname?: boolean
    roles?: boolean
    joinedAt?: boolean
  }

  export type guild_memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guildId" | "userId" | "nickname" | "roles" | "joinedAt", ExtArgs["result"]["guild_member"]>
  export type guild_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | guildDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $guild_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guild_member"
    objects: {
      guild: Prisma.$guildPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guildId: string
      userId: string
      nickname: string | null
      roles: string | null
      joinedAt: Date
    }, ExtArgs["result"]["guild_member"]>
    composites: {}
  }

  type guild_memberGetPayload<S extends boolean | null | undefined | guild_memberDefaultArgs> = $Result.GetResult<Prisma.$guild_memberPayload, S>

  type guild_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<guild_memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Guild_memberCountAggregateInputType | true
    }

  export interface guild_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guild_member'], meta: { name: 'guild_member' } }
    /**
     * Find zero or one Guild_member that matches the filter.
     * @param {guild_memberFindUniqueArgs} args - Arguments to find a Guild_member
     * @example
     * // Get one Guild_member
     * const guild_member = await prisma.guild_member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guild_memberFindUniqueArgs>(args: SelectSubset<T, guild_memberFindUniqueArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guild_member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {guild_memberFindUniqueOrThrowArgs} args - Arguments to find a Guild_member
     * @example
     * // Get one Guild_member
     * const guild_member = await prisma.guild_member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guild_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, guild_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guild_member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_memberFindFirstArgs} args - Arguments to find a Guild_member
     * @example
     * // Get one Guild_member
     * const guild_member = await prisma.guild_member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guild_memberFindFirstArgs>(args?: SelectSubset<T, guild_memberFindFirstArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guild_member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_memberFindFirstOrThrowArgs} args - Arguments to find a Guild_member
     * @example
     * // Get one Guild_member
     * const guild_member = await prisma.guild_member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guild_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, guild_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guild_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guild_members
     * const guild_members = await prisma.guild_member.findMany()
     * 
     * // Get first 10 Guild_members
     * const guild_members = await prisma.guild_member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guild_memberWithIdOnly = await prisma.guild_member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guild_memberFindManyArgs>(args?: SelectSubset<T, guild_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guild_member.
     * @param {guild_memberCreateArgs} args - Arguments to create a Guild_member.
     * @example
     * // Create one Guild_member
     * const Guild_member = await prisma.guild_member.create({
     *   data: {
     *     // ... data to create a Guild_member
     *   }
     * })
     * 
     */
    create<T extends guild_memberCreateArgs>(args: SelectSubset<T, guild_memberCreateArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guild_members.
     * @param {guild_memberCreateManyArgs} args - Arguments to create many Guild_members.
     * @example
     * // Create many Guild_members
     * const guild_member = await prisma.guild_member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guild_memberCreateManyArgs>(args?: SelectSubset<T, guild_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild_member.
     * @param {guild_memberDeleteArgs} args - Arguments to delete one Guild_member.
     * @example
     * // Delete one Guild_member
     * const Guild_member = await prisma.guild_member.delete({
     *   where: {
     *     // ... filter to delete one Guild_member
     *   }
     * })
     * 
     */
    delete<T extends guild_memberDeleteArgs>(args: SelectSubset<T, guild_memberDeleteArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guild_member.
     * @param {guild_memberUpdateArgs} args - Arguments to update one Guild_member.
     * @example
     * // Update one Guild_member
     * const guild_member = await prisma.guild_member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guild_memberUpdateArgs>(args: SelectSubset<T, guild_memberUpdateArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guild_members.
     * @param {guild_memberDeleteManyArgs} args - Arguments to filter Guild_members to delete.
     * @example
     * // Delete a few Guild_members
     * const { count } = await prisma.guild_member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guild_memberDeleteManyArgs>(args?: SelectSubset<T, guild_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guild_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guild_members
     * const guild_member = await prisma.guild_member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guild_memberUpdateManyArgs>(args: SelectSubset<T, guild_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild_member.
     * @param {guild_memberUpsertArgs} args - Arguments to update or create a Guild_member.
     * @example
     * // Update or create a Guild_member
     * const guild_member = await prisma.guild_member.upsert({
     *   create: {
     *     // ... data to create a Guild_member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild_member we want to update
     *   }
     * })
     */
    upsert<T extends guild_memberUpsertArgs>(args: SelectSubset<T, guild_memberUpsertArgs<ExtArgs>>): Prisma__guild_memberClient<$Result.GetResult<Prisma.$guild_memberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guild_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_memberCountArgs} args - Arguments to filter Guild_members to count.
     * @example
     * // Count the number of Guild_members
     * const count = await prisma.guild_member.count({
     *   where: {
     *     // ... the filter for the Guild_members we want to count
     *   }
     * })
    **/
    count<T extends guild_memberCountArgs>(
      args?: Subset<T, guild_memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Guild_memberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Guild_memberAggregateArgs>(args: Subset<T, Guild_memberAggregateArgs>): Prisma.PrismaPromise<GetGuild_memberAggregateType<T>>

    /**
     * Group by Guild_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guild_memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guild_memberGroupByArgs['orderBy'] }
        : { orderBy?: guild_memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guild_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuild_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guild_member model
   */
  readonly fields: guild_memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guild_member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guild_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guild<T extends guildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, guildDefaultArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guild_member model
   */
  interface guild_memberFieldRefs {
    readonly id: FieldRef<"guild_member", 'String'>
    readonly guildId: FieldRef<"guild_member", 'String'>
    readonly userId: FieldRef<"guild_member", 'String'>
    readonly nickname: FieldRef<"guild_member", 'String'>
    readonly roles: FieldRef<"guild_member", 'String'>
    readonly joinedAt: FieldRef<"guild_member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * guild_member findUnique
   */
  export type guild_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * Filter, which guild_member to fetch.
     */
    where: guild_memberWhereUniqueInput
  }

  /**
   * guild_member findUniqueOrThrow
   */
  export type guild_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * Filter, which guild_member to fetch.
     */
    where: guild_memberWhereUniqueInput
  }

  /**
   * guild_member findFirst
   */
  export type guild_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * Filter, which guild_member to fetch.
     */
    where?: guild_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_members to fetch.
     */
    orderBy?: guild_memberOrderByWithRelationInput | guild_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_members.
     */
    cursor?: guild_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_members.
     */
    distinct?: Guild_memberScalarFieldEnum | Guild_memberScalarFieldEnum[]
  }

  /**
   * guild_member findFirstOrThrow
   */
  export type guild_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * Filter, which guild_member to fetch.
     */
    where?: guild_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_members to fetch.
     */
    orderBy?: guild_memberOrderByWithRelationInput | guild_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_members.
     */
    cursor?: guild_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_members.
     */
    distinct?: Guild_memberScalarFieldEnum | Guild_memberScalarFieldEnum[]
  }

  /**
   * guild_member findMany
   */
  export type guild_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * Filter, which guild_members to fetch.
     */
    where?: guild_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_members to fetch.
     */
    orderBy?: guild_memberOrderByWithRelationInput | guild_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guild_members.
     */
    cursor?: guild_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_members.
     */
    skip?: number
    distinct?: Guild_memberScalarFieldEnum | Guild_memberScalarFieldEnum[]
  }

  /**
   * guild_member create
   */
  export type guild_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * The data needed to create a guild_member.
     */
    data: XOR<guild_memberCreateInput, guild_memberUncheckedCreateInput>
  }

  /**
   * guild_member createMany
   */
  export type guild_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guild_members.
     */
    data: guild_memberCreateManyInput | guild_memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guild_member update
   */
  export type guild_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * The data needed to update a guild_member.
     */
    data: XOR<guild_memberUpdateInput, guild_memberUncheckedUpdateInput>
    /**
     * Choose, which guild_member to update.
     */
    where: guild_memberWhereUniqueInput
  }

  /**
   * guild_member updateMany
   */
  export type guild_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guild_members.
     */
    data: XOR<guild_memberUpdateManyMutationInput, guild_memberUncheckedUpdateManyInput>
    /**
     * Filter which guild_members to update
     */
    where?: guild_memberWhereInput
    /**
     * Limit how many guild_members to update.
     */
    limit?: number
  }

  /**
   * guild_member upsert
   */
  export type guild_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * The filter to search for the guild_member to update in case it exists.
     */
    where: guild_memberWhereUniqueInput
    /**
     * In case the guild_member found by the `where` argument doesn't exist, create a new guild_member with this data.
     */
    create: XOR<guild_memberCreateInput, guild_memberUncheckedCreateInput>
    /**
     * In case the guild_member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guild_memberUpdateInput, guild_memberUncheckedUpdateInput>
  }

  /**
   * guild_member delete
   */
  export type guild_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
    /**
     * Filter which guild_member to delete.
     */
    where: guild_memberWhereUniqueInput
  }

  /**
   * guild_member deleteMany
   */
  export type guild_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_members to delete
     */
    where?: guild_memberWhereInput
    /**
     * Limit how many guild_members to delete.
     */
    limit?: number
  }

  /**
   * guild_member without action
   */
  export type guild_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_member
     */
    select?: guild_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild_member
     */
    omit?: guild_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guild_memberInclude<ExtArgs> | null
  }


  /**
   * Model channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelAvgAggregateOutputType = {
    position: number | null
  }

  export type ChannelSumAggregateOutputType = {
    position: number | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    guildId: string | null
    name: string | null
    slug: string | null
    type: $Enums.channel_type | null
    topic: string | null
    position: number | null
    isPrivate: boolean | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    guildId: string | null
    name: string | null
    slug: string | null
    type: $Enums.channel_type | null
    topic: string | null
    position: number | null
    isPrivate: boolean | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    guildId: number
    name: number
    slug: number
    type: number
    topic: number
    position: number
    isPrivate: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChannelAvgAggregateInputType = {
    position?: true
  }

  export type ChannelSumAggregateInputType = {
    position?: true
  }

  export type ChannelMinAggregateInputType = {
    id?: true
    guildId?: true
    name?: true
    slug?: true
    type?: true
    topic?: true
    position?: true
    isPrivate?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    guildId?: true
    name?: true
    slug?: true
    type?: true
    topic?: true
    position?: true
    isPrivate?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    guildId?: true
    name?: true
    slug?: true
    type?: true
    topic?: true
    position?: true
    isPrivate?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channel to aggregate.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type channelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
    orderBy?: channelOrderByWithAggregationInput | channelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: channelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _avg?: ChannelAvgAggregateInputType
    _sum?: ChannelSumAggregateInputType
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    guildId: string
    name: string
    slug: string
    type: $Enums.channel_type
    topic: string | null
    position: number
    isPrivate: boolean
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends channelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type channelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    topic?: boolean
    position?: boolean
    isPrivate?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    guild?: boolean | guildDefaultArgs<ExtArgs>
    parent?: boolean | channel$parentArgs<ExtArgs>
    children?: boolean | channel$childrenArgs<ExtArgs>
    members?: boolean | channel$membersArgs<ExtArgs>
    room?: boolean | channel$roomArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>



  export type channelSelectScalar = {
    id?: boolean
    guildId?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    topic?: boolean
    position?: boolean
    isPrivate?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type channelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guildId" | "name" | "slug" | "type" | "topic" | "position" | "isPrivate" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["channel"]>
  export type channelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | guildDefaultArgs<ExtArgs>
    parent?: boolean | channel$parentArgs<ExtArgs>
    children?: boolean | channel$childrenArgs<ExtArgs>
    members?: boolean | channel$membersArgs<ExtArgs>
    room?: boolean | channel$roomArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $channelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "channel"
    objects: {
      guild: Prisma.$guildPayload<ExtArgs>
      parent: Prisma.$channelPayload<ExtArgs> | null
      children: Prisma.$channelPayload<ExtArgs>[]
      members: Prisma.$channel_memberPayload<ExtArgs>[]
      room: Prisma.$roomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guildId: string
      name: string
      slug: string
      type: $Enums.channel_type
      topic: string | null
      position: number
      isPrivate: boolean
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type channelGetPayload<S extends boolean | null | undefined | channelDefaultArgs> = $Result.GetResult<Prisma.$channelPayload, S>

  type channelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<channelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface channelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['channel'], meta: { name: 'channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {channelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends channelFindUniqueArgs>(args: SelectSubset<T, channelFindUniqueArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {channelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends channelFindUniqueOrThrowArgs>(args: SelectSubset<T, channelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends channelFindFirstArgs>(args?: SelectSubset<T, channelFindFirstArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends channelFindFirstOrThrowArgs>(args?: SelectSubset<T, channelFindFirstOrThrowArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends channelFindManyArgs>(args?: SelectSubset<T, channelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channel.
     * @param {channelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends channelCreateArgs>(args: SelectSubset<T, channelCreateArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channels.
     * @param {channelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends channelCreateManyArgs>(args?: SelectSubset<T, channelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Channel.
     * @param {channelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends channelDeleteArgs>(args: SelectSubset<T, channelDeleteArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channel.
     * @param {channelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends channelUpdateArgs>(args: SelectSubset<T, channelUpdateArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channels.
     * @param {channelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends channelDeleteManyArgs>(args?: SelectSubset<T, channelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends channelUpdateManyArgs>(args: SelectSubset<T, channelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {channelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends channelUpsertArgs>(args: SelectSubset<T, channelUpsertArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends channelCountArgs>(
      args?: Subset<T, channelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends channelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: channelGroupByArgs['orderBy'] }
        : { orderBy?: channelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, channelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the channel model
   */
  readonly fields: channelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__channelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guild<T extends guildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, guildDefaultArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends channel$parentArgs<ExtArgs> = {}>(args?: Subset<T, channel$parentArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends channel$childrenArgs<ExtArgs> = {}>(args?: Subset<T, channel$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends channel$membersArgs<ExtArgs> = {}>(args?: Subset<T, channel$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room<T extends channel$roomArgs<ExtArgs> = {}>(args?: Subset<T, channel$roomArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the channel model
   */
  interface channelFieldRefs {
    readonly id: FieldRef<"channel", 'String'>
    readonly guildId: FieldRef<"channel", 'String'>
    readonly name: FieldRef<"channel", 'String'>
    readonly slug: FieldRef<"channel", 'String'>
    readonly type: FieldRef<"channel", 'channel_type'>
    readonly topic: FieldRef<"channel", 'String'>
    readonly position: FieldRef<"channel", 'Int'>
    readonly isPrivate: FieldRef<"channel", 'Boolean'>
    readonly parentId: FieldRef<"channel", 'String'>
    readonly createdAt: FieldRef<"channel", 'DateTime'>
    readonly updatedAt: FieldRef<"channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * channel findUnique
   */
  export type channelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel findUniqueOrThrow
   */
  export type channelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel findFirst
   */
  export type channelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel findFirstOrThrow
   */
  export type channelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel findMany
   */
  export type channelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel create
   */
  export type channelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The data needed to create a channel.
     */
    data: XOR<channelCreateInput, channelUncheckedCreateInput>
  }

  /**
   * channel createMany
   */
  export type channelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many channels.
     */
    data: channelCreateManyInput | channelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * channel update
   */
  export type channelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The data needed to update a channel.
     */
    data: XOR<channelUpdateInput, channelUncheckedUpdateInput>
    /**
     * Choose, which channel to update.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel updateMany
   */
  export type channelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update channels.
     */
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
  }

  /**
   * channel upsert
   */
  export type channelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The filter to search for the channel to update in case it exists.
     */
    where: channelWhereUniqueInput
    /**
     * In case the channel found by the `where` argument doesn't exist, create a new channel with this data.
     */
    create: XOR<channelCreateInput, channelUncheckedCreateInput>
    /**
     * In case the channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<channelUpdateInput, channelUncheckedUpdateInput>
  }

  /**
   * channel delete
   */
  export type channelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter which channel to delete.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel deleteMany
   */
  export type channelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channels to delete
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to delete.
     */
    limit?: number
  }

  /**
   * channel.parent
   */
  export type channel$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
  }

  /**
   * channel.children
   */
  export type channel$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    cursor?: channelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel.members
   */
  export type channel$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    where?: channel_memberWhereInput
    orderBy?: channel_memberOrderByWithRelationInput | channel_memberOrderByWithRelationInput[]
    cursor?: channel_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Channel_memberScalarFieldEnum | Channel_memberScalarFieldEnum[]
  }

  /**
   * channel.room
   */
  export type channel$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    where?: roomWhereInput
  }

  /**
   * channel without action
   */
  export type channelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
  }


  /**
   * Model channel_member
   */

  export type AggregateChannel_member = {
    _count: Channel_memberCountAggregateOutputType | null
    _min: Channel_memberMinAggregateOutputType | null
    _max: Channel_memberMaxAggregateOutputType | null
  }

  export type Channel_memberMinAggregateOutputType = {
    channelId: string | null
    userId: string | null
    addedAt: Date | null
  }

  export type Channel_memberMaxAggregateOutputType = {
    channelId: string | null
    userId: string | null
    addedAt: Date | null
  }

  export type Channel_memberCountAggregateOutputType = {
    channelId: number
    userId: number
    addedAt: number
    _all: number
  }


  export type Channel_memberMinAggregateInputType = {
    channelId?: true
    userId?: true
    addedAt?: true
  }

  export type Channel_memberMaxAggregateInputType = {
    channelId?: true
    userId?: true
    addedAt?: true
  }

  export type Channel_memberCountAggregateInputType = {
    channelId?: true
    userId?: true
    addedAt?: true
    _all?: true
  }

  export type Channel_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channel_member to aggregate.
     */
    where?: channel_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channel_members to fetch.
     */
    orderBy?: channel_memberOrderByWithRelationInput | channel_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: channel_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channel_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channel_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned channel_members
    **/
    _count?: true | Channel_memberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Channel_memberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Channel_memberMaxAggregateInputType
  }

  export type GetChannel_memberAggregateType<T extends Channel_memberAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel_member]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel_member[P]>
      : GetScalarType<T[P], AggregateChannel_member[P]>
  }




  export type channel_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channel_memberWhereInput
    orderBy?: channel_memberOrderByWithAggregationInput | channel_memberOrderByWithAggregationInput[]
    by: Channel_memberScalarFieldEnum[] | Channel_memberScalarFieldEnum
    having?: channel_memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Channel_memberCountAggregateInputType | true
    _min?: Channel_memberMinAggregateInputType
    _max?: Channel_memberMaxAggregateInputType
  }

  export type Channel_memberGroupByOutputType = {
    channelId: string
    userId: string
    addedAt: Date
    _count: Channel_memberCountAggregateOutputType | null
    _min: Channel_memberMinAggregateOutputType | null
    _max: Channel_memberMaxAggregateOutputType | null
  }

  type GetChannel_memberGroupByPayload<T extends channel_memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Channel_memberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Channel_memberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Channel_memberGroupByOutputType[P]>
            : GetScalarType<T[P], Channel_memberGroupByOutputType[P]>
        }
      >
    >


  export type channel_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    channelId?: boolean
    userId?: boolean
    addedAt?: boolean
    channel?: boolean | channelDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel_member"]>



  export type channel_memberSelectScalar = {
    channelId?: boolean
    userId?: boolean
    addedAt?: boolean
  }

  export type channel_memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"channelId" | "userId" | "addedAt", ExtArgs["result"]["channel_member"]>
  export type channel_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | channelDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $channel_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "channel_member"
    objects: {
      channel: Prisma.$channelPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      channelId: string
      userId: string
      addedAt: Date
    }, ExtArgs["result"]["channel_member"]>
    composites: {}
  }

  type channel_memberGetPayload<S extends boolean | null | undefined | channel_memberDefaultArgs> = $Result.GetResult<Prisma.$channel_memberPayload, S>

  type channel_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<channel_memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Channel_memberCountAggregateInputType | true
    }

  export interface channel_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['channel_member'], meta: { name: 'channel_member' } }
    /**
     * Find zero or one Channel_member that matches the filter.
     * @param {channel_memberFindUniqueArgs} args - Arguments to find a Channel_member
     * @example
     * // Get one Channel_member
     * const channel_member = await prisma.channel_member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends channel_memberFindUniqueArgs>(args: SelectSubset<T, channel_memberFindUniqueArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channel_member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {channel_memberFindUniqueOrThrowArgs} args - Arguments to find a Channel_member
     * @example
     * // Get one Channel_member
     * const channel_member = await prisma.channel_member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends channel_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, channel_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel_member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channel_memberFindFirstArgs} args - Arguments to find a Channel_member
     * @example
     * // Get one Channel_member
     * const channel_member = await prisma.channel_member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends channel_memberFindFirstArgs>(args?: SelectSubset<T, channel_memberFindFirstArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel_member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channel_memberFindFirstOrThrowArgs} args - Arguments to find a Channel_member
     * @example
     * // Get one Channel_member
     * const channel_member = await prisma.channel_member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends channel_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, channel_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channel_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channel_memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channel_members
     * const channel_members = await prisma.channel_member.findMany()
     * 
     * // Get first 10 Channel_members
     * const channel_members = await prisma.channel_member.findMany({ take: 10 })
     * 
     * // Only select the `channelId`
     * const channel_memberWithChannelIdOnly = await prisma.channel_member.findMany({ select: { channelId: true } })
     * 
     */
    findMany<T extends channel_memberFindManyArgs>(args?: SelectSubset<T, channel_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channel_member.
     * @param {channel_memberCreateArgs} args - Arguments to create a Channel_member.
     * @example
     * // Create one Channel_member
     * const Channel_member = await prisma.channel_member.create({
     *   data: {
     *     // ... data to create a Channel_member
     *   }
     * })
     * 
     */
    create<T extends channel_memberCreateArgs>(args: SelectSubset<T, channel_memberCreateArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channel_members.
     * @param {channel_memberCreateManyArgs} args - Arguments to create many Channel_members.
     * @example
     * // Create many Channel_members
     * const channel_member = await prisma.channel_member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends channel_memberCreateManyArgs>(args?: SelectSubset<T, channel_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Channel_member.
     * @param {channel_memberDeleteArgs} args - Arguments to delete one Channel_member.
     * @example
     * // Delete one Channel_member
     * const Channel_member = await prisma.channel_member.delete({
     *   where: {
     *     // ... filter to delete one Channel_member
     *   }
     * })
     * 
     */
    delete<T extends channel_memberDeleteArgs>(args: SelectSubset<T, channel_memberDeleteArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channel_member.
     * @param {channel_memberUpdateArgs} args - Arguments to update one Channel_member.
     * @example
     * // Update one Channel_member
     * const channel_member = await prisma.channel_member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends channel_memberUpdateArgs>(args: SelectSubset<T, channel_memberUpdateArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channel_members.
     * @param {channel_memberDeleteManyArgs} args - Arguments to filter Channel_members to delete.
     * @example
     * // Delete a few Channel_members
     * const { count } = await prisma.channel_member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends channel_memberDeleteManyArgs>(args?: SelectSubset<T, channel_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channel_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channel_memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channel_members
     * const channel_member = await prisma.channel_member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends channel_memberUpdateManyArgs>(args: SelectSubset<T, channel_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel_member.
     * @param {channel_memberUpsertArgs} args - Arguments to update or create a Channel_member.
     * @example
     * // Update or create a Channel_member
     * const channel_member = await prisma.channel_member.upsert({
     *   create: {
     *     // ... data to create a Channel_member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel_member we want to update
     *   }
     * })
     */
    upsert<T extends channel_memberUpsertArgs>(args: SelectSubset<T, channel_memberUpsertArgs<ExtArgs>>): Prisma__channel_memberClient<$Result.GetResult<Prisma.$channel_memberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channel_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channel_memberCountArgs} args - Arguments to filter Channel_members to count.
     * @example
     * // Count the number of Channel_members
     * const count = await prisma.channel_member.count({
     *   where: {
     *     // ... the filter for the Channel_members we want to count
     *   }
     * })
    **/
    count<T extends channel_memberCountArgs>(
      args?: Subset<T, channel_memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Channel_memberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Channel_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Channel_memberAggregateArgs>(args: Subset<T, Channel_memberAggregateArgs>): Prisma.PrismaPromise<GetChannel_memberAggregateType<T>>

    /**
     * Group by Channel_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channel_memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends channel_memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: channel_memberGroupByArgs['orderBy'] }
        : { orderBy?: channel_memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, channel_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannel_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the channel_member model
   */
  readonly fields: channel_memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for channel_member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__channel_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends channelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, channelDefaultArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the channel_member model
   */
  interface channel_memberFieldRefs {
    readonly channelId: FieldRef<"channel_member", 'String'>
    readonly userId: FieldRef<"channel_member", 'String'>
    readonly addedAt: FieldRef<"channel_member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * channel_member findUnique
   */
  export type channel_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * Filter, which channel_member to fetch.
     */
    where: channel_memberWhereUniqueInput
  }

  /**
   * channel_member findUniqueOrThrow
   */
  export type channel_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * Filter, which channel_member to fetch.
     */
    where: channel_memberWhereUniqueInput
  }

  /**
   * channel_member findFirst
   */
  export type channel_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * Filter, which channel_member to fetch.
     */
    where?: channel_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channel_members to fetch.
     */
    orderBy?: channel_memberOrderByWithRelationInput | channel_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channel_members.
     */
    cursor?: channel_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channel_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channel_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channel_members.
     */
    distinct?: Channel_memberScalarFieldEnum | Channel_memberScalarFieldEnum[]
  }

  /**
   * channel_member findFirstOrThrow
   */
  export type channel_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * Filter, which channel_member to fetch.
     */
    where?: channel_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channel_members to fetch.
     */
    orderBy?: channel_memberOrderByWithRelationInput | channel_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channel_members.
     */
    cursor?: channel_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channel_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channel_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channel_members.
     */
    distinct?: Channel_memberScalarFieldEnum | Channel_memberScalarFieldEnum[]
  }

  /**
   * channel_member findMany
   */
  export type channel_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * Filter, which channel_members to fetch.
     */
    where?: channel_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channel_members to fetch.
     */
    orderBy?: channel_memberOrderByWithRelationInput | channel_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing channel_members.
     */
    cursor?: channel_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channel_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channel_members.
     */
    skip?: number
    distinct?: Channel_memberScalarFieldEnum | Channel_memberScalarFieldEnum[]
  }

  /**
   * channel_member create
   */
  export type channel_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * The data needed to create a channel_member.
     */
    data: XOR<channel_memberCreateInput, channel_memberUncheckedCreateInput>
  }

  /**
   * channel_member createMany
   */
  export type channel_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many channel_members.
     */
    data: channel_memberCreateManyInput | channel_memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * channel_member update
   */
  export type channel_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * The data needed to update a channel_member.
     */
    data: XOR<channel_memberUpdateInput, channel_memberUncheckedUpdateInput>
    /**
     * Choose, which channel_member to update.
     */
    where: channel_memberWhereUniqueInput
  }

  /**
   * channel_member updateMany
   */
  export type channel_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update channel_members.
     */
    data: XOR<channel_memberUpdateManyMutationInput, channel_memberUncheckedUpdateManyInput>
    /**
     * Filter which channel_members to update
     */
    where?: channel_memberWhereInput
    /**
     * Limit how many channel_members to update.
     */
    limit?: number
  }

  /**
   * channel_member upsert
   */
  export type channel_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * The filter to search for the channel_member to update in case it exists.
     */
    where: channel_memberWhereUniqueInput
    /**
     * In case the channel_member found by the `where` argument doesn't exist, create a new channel_member with this data.
     */
    create: XOR<channel_memberCreateInput, channel_memberUncheckedCreateInput>
    /**
     * In case the channel_member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<channel_memberUpdateInput, channel_memberUncheckedUpdateInput>
  }

  /**
   * channel_member delete
   */
  export type channel_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
    /**
     * Filter which channel_member to delete.
     */
    where: channel_memberWhereUniqueInput
  }

  /**
   * channel_member deleteMany
   */
  export type channel_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channel_members to delete
     */
    where?: channel_memberWhereInput
    /**
     * Limit how many channel_members to delete.
     */
    limit?: number
  }

  /**
   * channel_member without action
   */
  export type channel_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel_member
     */
    select?: channel_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel_member
     */
    omit?: channel_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channel_memberInclude<ExtArgs> | null
  }


  /**
   * Model room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    type: $Enums.room_type | null
    name: string | null
    ownerId: string | null
    guildId: string | null
    channelId: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    type: $Enums.room_type | null
    name: string | null
    ownerId: string | null
    guildId: string | null
    channelId: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    type: number
    name: number
    ownerId: number
    guildId: number
    channelId: number
    lastMessageAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    ownerId?: true
    guildId?: true
    channelId?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    ownerId?: true
    guildId?: true
    channelId?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    ownerId?: true
    guildId?: true
    channelId?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room to aggregate.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roomWhereInput
    orderBy?: roomOrderByWithAggregationInput | roomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    type: $Enums.room_type
    name: string | null
    ownerId: string | null
    guildId: string | null
    channelId: string | null
    lastMessageAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    ownerId?: boolean
    guildId?: boolean
    channelId?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dm_pair_unique?: boolean | room$dm_pair_uniqueArgs<ExtArgs>
    messages?: boolean | room$messagesArgs<ExtArgs>
    channel?: boolean | room$channelArgs<ExtArgs>
    guild?: boolean | room$guildArgs<ExtArgs>
    owner?: boolean | room$ownerArgs<ExtArgs>
    participants?: boolean | room$participantsArgs<ExtArgs>
    room_view?: boolean | room$room_viewArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>



  export type roomSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    ownerId?: boolean
    guildId?: boolean
    channelId?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "ownerId" | "guildId" | "channelId" | "lastMessageAt" | "createdAt" | "updatedAt", ExtArgs["result"]["room"]>
  export type roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dm_pair_unique?: boolean | room$dm_pair_uniqueArgs<ExtArgs>
    messages?: boolean | room$messagesArgs<ExtArgs>
    channel?: boolean | room$channelArgs<ExtArgs>
    guild?: boolean | room$guildArgs<ExtArgs>
    owner?: boolean | room$ownerArgs<ExtArgs>
    participants?: boolean | room$participantsArgs<ExtArgs>
    room_view?: boolean | room$room_viewArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "room"
    objects: {
      dm_pair_unique: Prisma.$dm_pair_uniquePayload<ExtArgs>[]
      messages: Prisma.$messagePayload<ExtArgs>[]
      channel: Prisma.$channelPayload<ExtArgs> | null
      guild: Prisma.$guildPayload<ExtArgs> | null
      owner: Prisma.$userPayload<ExtArgs> | null
      participants: Prisma.$room_participantPayload<ExtArgs>[]
      room_view: Prisma.$room_viewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.room_type
      name: string | null
      ownerId: string | null
      guildId: string | null
      channelId: string | null
      lastMessageAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type roomGetPayload<S extends boolean | null | undefined | roomDefaultArgs> = $Result.GetResult<Prisma.$roomPayload, S>

  type roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['room'], meta: { name: 'room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {roomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roomFindUniqueArgs>(args: SelectSubset<T, roomFindUniqueArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roomFindUniqueOrThrowArgs>(args: SelectSubset<T, roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roomFindFirstArgs>(args?: SelectSubset<T, roomFindFirstArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roomFindFirstOrThrowArgs>(args?: SelectSubset<T, roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roomFindManyArgs>(args?: SelectSubset<T, roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {roomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends roomCreateArgs>(args: SelectSubset<T, roomCreateArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {roomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roomCreateManyArgs>(args?: SelectSubset<T, roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {roomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends roomDeleteArgs>(args: SelectSubset<T, roomDeleteArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {roomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roomUpdateArgs>(args: SelectSubset<T, roomUpdateArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {roomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roomDeleteManyArgs>(args?: SelectSubset<T, roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roomUpdateManyArgs>(args: SelectSubset<T, roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {roomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends roomUpsertArgs>(args: SelectSubset<T, roomUpsertArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends roomCountArgs>(
      args?: Subset<T, roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roomGroupByArgs['orderBy'] }
        : { orderBy?: roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the room model
   */
  readonly fields: roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dm_pair_unique<T extends room$dm_pair_uniqueArgs<ExtArgs> = {}>(args?: Subset<T, room$dm_pair_uniqueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends room$messagesArgs<ExtArgs> = {}>(args?: Subset<T, room$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channel<T extends room$channelArgs<ExtArgs> = {}>(args?: Subset<T, room$channelArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guild<T extends room$guildArgs<ExtArgs> = {}>(args?: Subset<T, room$guildArgs<ExtArgs>>): Prisma__guildClient<$Result.GetResult<Prisma.$guildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owner<T extends room$ownerArgs<ExtArgs> = {}>(args?: Subset<T, room$ownerArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends room$participantsArgs<ExtArgs> = {}>(args?: Subset<T, room$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    room_view<T extends room$room_viewArgs<ExtArgs> = {}>(args?: Subset<T, room$room_viewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the room model
   */
  interface roomFieldRefs {
    readonly id: FieldRef<"room", 'String'>
    readonly type: FieldRef<"room", 'room_type'>
    readonly name: FieldRef<"room", 'String'>
    readonly ownerId: FieldRef<"room", 'String'>
    readonly guildId: FieldRef<"room", 'String'>
    readonly channelId: FieldRef<"room", 'String'>
    readonly lastMessageAt: FieldRef<"room", 'DateTime'>
    readonly createdAt: FieldRef<"room", 'DateTime'>
    readonly updatedAt: FieldRef<"room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * room findUnique
   */
  export type roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room findUniqueOrThrow
   */
  export type roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room findFirst
   */
  export type roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rooms.
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * room findFirstOrThrow
   */
  export type roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which room to fetch.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rooms.
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * room findMany
   */
  export type roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter, which rooms to fetch.
     */
    where?: roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rooms to fetch.
     */
    orderBy?: roomOrderByWithRelationInput | roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rooms.
     */
    cursor?: roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * room create
   */
  export type roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * The data needed to create a room.
     */
    data: XOR<roomCreateInput, roomUncheckedCreateInput>
  }

  /**
   * room createMany
   */
  export type roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rooms.
     */
    data: roomCreateManyInput | roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * room update
   */
  export type roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * The data needed to update a room.
     */
    data: XOR<roomUpdateInput, roomUncheckedUpdateInput>
    /**
     * Choose, which room to update.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room updateMany
   */
  export type roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rooms.
     */
    data: XOR<roomUpdateManyMutationInput, roomUncheckedUpdateManyInput>
    /**
     * Filter which rooms to update
     */
    where?: roomWhereInput
    /**
     * Limit how many rooms to update.
     */
    limit?: number
  }

  /**
   * room upsert
   */
  export type roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * The filter to search for the room to update in case it exists.
     */
    where: roomWhereUniqueInput
    /**
     * In case the room found by the `where` argument doesn't exist, create a new room with this data.
     */
    create: XOR<roomCreateInput, roomUncheckedCreateInput>
    /**
     * In case the room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roomUpdateInput, roomUncheckedUpdateInput>
  }

  /**
   * room delete
   */
  export type roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
    /**
     * Filter which room to delete.
     */
    where: roomWhereUniqueInput
  }

  /**
   * room deleteMany
   */
  export type roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rooms to delete
     */
    where?: roomWhereInput
    /**
     * Limit how many rooms to delete.
     */
    limit?: number
  }

  /**
   * room.dm_pair_unique
   */
  export type room$dm_pair_uniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    where?: dm_pair_uniqueWhereInput
    orderBy?: dm_pair_uniqueOrderByWithRelationInput | dm_pair_uniqueOrderByWithRelationInput[]
    cursor?: dm_pair_uniqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Dm_pair_uniqueScalarFieldEnum | Dm_pair_uniqueScalarFieldEnum[]
  }

  /**
   * room.messages
   */
  export type room$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * room.channel
   */
  export type room$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
  }

  /**
   * room.guild
   */
  export type room$guildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild
     */
    select?: guildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guild
     */
    omit?: guildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guildInclude<ExtArgs> | null
    where?: guildWhereInput
  }

  /**
   * room.owner
   */
  export type room$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * room.participants
   */
  export type room$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    where?: room_participantWhereInput
    orderBy?: room_participantOrderByWithRelationInput | room_participantOrderByWithRelationInput[]
    cursor?: room_participantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Room_participantScalarFieldEnum | Room_participantScalarFieldEnum[]
  }

  /**
   * room.room_view
   */
  export type room$room_viewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    where?: room_viewWhereInput
    orderBy?: room_viewOrderByWithRelationInput | room_viewOrderByWithRelationInput[]
    cursor?: room_viewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Room_viewScalarFieldEnum | Room_viewScalarFieldEnum[]
  }

  /**
   * room without action
   */
  export type roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room
     */
    select?: roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room
     */
    omit?: roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roomInclude<ExtArgs> | null
  }


  /**
   * Model room_participant
   */

  export type AggregateRoom_participant = {
    _count: Room_participantCountAggregateOutputType | null
    _min: Room_participantMinAggregateOutputType | null
    _max: Room_participantMaxAggregateOutputType | null
  }

  export type Room_participantMinAggregateOutputType = {
    roomId: string | null
    userId: string | null
    joinedAt: Date | null
    isMuted: boolean | null
    isPinned: boolean | null
  }

  export type Room_participantMaxAggregateOutputType = {
    roomId: string | null
    userId: string | null
    joinedAt: Date | null
    isMuted: boolean | null
    isPinned: boolean | null
  }

  export type Room_participantCountAggregateOutputType = {
    roomId: number
    userId: number
    joinedAt: number
    isMuted: number
    isPinned: number
    _all: number
  }


  export type Room_participantMinAggregateInputType = {
    roomId?: true
    userId?: true
    joinedAt?: true
    isMuted?: true
    isPinned?: true
  }

  export type Room_participantMaxAggregateInputType = {
    roomId?: true
    userId?: true
    joinedAt?: true
    isMuted?: true
    isPinned?: true
  }

  export type Room_participantCountAggregateInputType = {
    roomId?: true
    userId?: true
    joinedAt?: true
    isMuted?: true
    isPinned?: true
    _all?: true
  }

  export type Room_participantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room_participant to aggregate.
     */
    where?: room_participantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_participants to fetch.
     */
    orderBy?: room_participantOrderByWithRelationInput | room_participantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: room_participantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned room_participants
    **/
    _count?: true | Room_participantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Room_participantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Room_participantMaxAggregateInputType
  }

  export type GetRoom_participantAggregateType<T extends Room_participantAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom_participant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom_participant[P]>
      : GetScalarType<T[P], AggregateRoom_participant[P]>
  }




  export type room_participantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_participantWhereInput
    orderBy?: room_participantOrderByWithAggregationInput | room_participantOrderByWithAggregationInput[]
    by: Room_participantScalarFieldEnum[] | Room_participantScalarFieldEnum
    having?: room_participantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Room_participantCountAggregateInputType | true
    _min?: Room_participantMinAggregateInputType
    _max?: Room_participantMaxAggregateInputType
  }

  export type Room_participantGroupByOutputType = {
    roomId: string
    userId: string
    joinedAt: Date
    isMuted: boolean
    isPinned: boolean
    _count: Room_participantCountAggregateOutputType | null
    _min: Room_participantMinAggregateOutputType | null
    _max: Room_participantMaxAggregateOutputType | null
  }

  type GetRoom_participantGroupByPayload<T extends room_participantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Room_participantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Room_participantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Room_participantGroupByOutputType[P]>
            : GetScalarType<T[P], Room_participantGroupByOutputType[P]>
        }
      >
    >


  export type room_participantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    userId?: boolean
    joinedAt?: boolean
    isMuted?: boolean
    isPinned?: boolean
    room?: boolean | roomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room_participant"]>



  export type room_participantSelectScalar = {
    roomId?: boolean
    userId?: boolean
    joinedAt?: boolean
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_participantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roomId" | "userId" | "joinedAt" | "isMuted" | "isPinned", ExtArgs["result"]["room_participant"]>
  export type room_participantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | roomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $room_participantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "room_participant"
    objects: {
      room: Prisma.$roomPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roomId: string
      userId: string
      joinedAt: Date
      isMuted: boolean
      isPinned: boolean
    }, ExtArgs["result"]["room_participant"]>
    composites: {}
  }

  type room_participantGetPayload<S extends boolean | null | undefined | room_participantDefaultArgs> = $Result.GetResult<Prisma.$room_participantPayload, S>

  type room_participantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<room_participantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Room_participantCountAggregateInputType | true
    }

  export interface room_participantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['room_participant'], meta: { name: 'room_participant' } }
    /**
     * Find zero or one Room_participant that matches the filter.
     * @param {room_participantFindUniqueArgs} args - Arguments to find a Room_participant
     * @example
     * // Get one Room_participant
     * const room_participant = await prisma.room_participant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends room_participantFindUniqueArgs>(args: SelectSubset<T, room_participantFindUniqueArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room_participant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {room_participantFindUniqueOrThrowArgs} args - Arguments to find a Room_participant
     * @example
     * // Get one Room_participant
     * const room_participant = await prisma.room_participant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends room_participantFindUniqueOrThrowArgs>(args: SelectSubset<T, room_participantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room_participant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_participantFindFirstArgs} args - Arguments to find a Room_participant
     * @example
     * // Get one Room_participant
     * const room_participant = await prisma.room_participant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends room_participantFindFirstArgs>(args?: SelectSubset<T, room_participantFindFirstArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room_participant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_participantFindFirstOrThrowArgs} args - Arguments to find a Room_participant
     * @example
     * // Get one Room_participant
     * const room_participant = await prisma.room_participant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends room_participantFindFirstOrThrowArgs>(args?: SelectSubset<T, room_participantFindFirstOrThrowArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Room_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_participantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Room_participants
     * const room_participants = await prisma.room_participant.findMany()
     * 
     * // Get first 10 Room_participants
     * const room_participants = await prisma.room_participant.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const room_participantWithRoomIdOnly = await prisma.room_participant.findMany({ select: { roomId: true } })
     * 
     */
    findMany<T extends room_participantFindManyArgs>(args?: SelectSubset<T, room_participantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room_participant.
     * @param {room_participantCreateArgs} args - Arguments to create a Room_participant.
     * @example
     * // Create one Room_participant
     * const Room_participant = await prisma.room_participant.create({
     *   data: {
     *     // ... data to create a Room_participant
     *   }
     * })
     * 
     */
    create<T extends room_participantCreateArgs>(args: SelectSubset<T, room_participantCreateArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Room_participants.
     * @param {room_participantCreateManyArgs} args - Arguments to create many Room_participants.
     * @example
     * // Create many Room_participants
     * const room_participant = await prisma.room_participant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends room_participantCreateManyArgs>(args?: SelectSubset<T, room_participantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room_participant.
     * @param {room_participantDeleteArgs} args - Arguments to delete one Room_participant.
     * @example
     * // Delete one Room_participant
     * const Room_participant = await prisma.room_participant.delete({
     *   where: {
     *     // ... filter to delete one Room_participant
     *   }
     * })
     * 
     */
    delete<T extends room_participantDeleteArgs>(args: SelectSubset<T, room_participantDeleteArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room_participant.
     * @param {room_participantUpdateArgs} args - Arguments to update one Room_participant.
     * @example
     * // Update one Room_participant
     * const room_participant = await prisma.room_participant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends room_participantUpdateArgs>(args: SelectSubset<T, room_participantUpdateArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Room_participants.
     * @param {room_participantDeleteManyArgs} args - Arguments to filter Room_participants to delete.
     * @example
     * // Delete a few Room_participants
     * const { count } = await prisma.room_participant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends room_participantDeleteManyArgs>(args?: SelectSubset<T, room_participantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Room_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_participantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Room_participants
     * const room_participant = await prisma.room_participant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends room_participantUpdateManyArgs>(args: SelectSubset<T, room_participantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room_participant.
     * @param {room_participantUpsertArgs} args - Arguments to update or create a Room_participant.
     * @example
     * // Update or create a Room_participant
     * const room_participant = await prisma.room_participant.upsert({
     *   create: {
     *     // ... data to create a Room_participant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room_participant we want to update
     *   }
     * })
     */
    upsert<T extends room_participantUpsertArgs>(args: SelectSubset<T, room_participantUpsertArgs<ExtArgs>>): Prisma__room_participantClient<$Result.GetResult<Prisma.$room_participantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Room_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_participantCountArgs} args - Arguments to filter Room_participants to count.
     * @example
     * // Count the number of Room_participants
     * const count = await prisma.room_participant.count({
     *   where: {
     *     // ... the filter for the Room_participants we want to count
     *   }
     * })
    **/
    count<T extends room_participantCountArgs>(
      args?: Subset<T, room_participantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Room_participantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room_participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Room_participantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Room_participantAggregateArgs>(args: Subset<T, Room_participantAggregateArgs>): Prisma.PrismaPromise<GetRoom_participantAggregateType<T>>

    /**
     * Group by Room_participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_participantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends room_participantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: room_participantGroupByArgs['orderBy'] }
        : { orderBy?: room_participantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, room_participantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoom_participantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the room_participant model
   */
  readonly fields: room_participantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for room_participant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__room_participantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the room_participant model
   */
  interface room_participantFieldRefs {
    readonly roomId: FieldRef<"room_participant", 'String'>
    readonly userId: FieldRef<"room_participant", 'String'>
    readonly joinedAt: FieldRef<"room_participant", 'DateTime'>
    readonly isMuted: FieldRef<"room_participant", 'Boolean'>
    readonly isPinned: FieldRef<"room_participant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * room_participant findUnique
   */
  export type room_participantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * Filter, which room_participant to fetch.
     */
    where: room_participantWhereUniqueInput
  }

  /**
   * room_participant findUniqueOrThrow
   */
  export type room_participantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * Filter, which room_participant to fetch.
     */
    where: room_participantWhereUniqueInput
  }

  /**
   * room_participant findFirst
   */
  export type room_participantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * Filter, which room_participant to fetch.
     */
    where?: room_participantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_participants to fetch.
     */
    orderBy?: room_participantOrderByWithRelationInput | room_participantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for room_participants.
     */
    cursor?: room_participantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of room_participants.
     */
    distinct?: Room_participantScalarFieldEnum | Room_participantScalarFieldEnum[]
  }

  /**
   * room_participant findFirstOrThrow
   */
  export type room_participantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * Filter, which room_participant to fetch.
     */
    where?: room_participantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_participants to fetch.
     */
    orderBy?: room_participantOrderByWithRelationInput | room_participantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for room_participants.
     */
    cursor?: room_participantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of room_participants.
     */
    distinct?: Room_participantScalarFieldEnum | Room_participantScalarFieldEnum[]
  }

  /**
   * room_participant findMany
   */
  export type room_participantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * Filter, which room_participants to fetch.
     */
    where?: room_participantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_participants to fetch.
     */
    orderBy?: room_participantOrderByWithRelationInput | room_participantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing room_participants.
     */
    cursor?: room_participantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_participants.
     */
    skip?: number
    distinct?: Room_participantScalarFieldEnum | Room_participantScalarFieldEnum[]
  }

  /**
   * room_participant create
   */
  export type room_participantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * The data needed to create a room_participant.
     */
    data: XOR<room_participantCreateInput, room_participantUncheckedCreateInput>
  }

  /**
   * room_participant createMany
   */
  export type room_participantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many room_participants.
     */
    data: room_participantCreateManyInput | room_participantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * room_participant update
   */
  export type room_participantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * The data needed to update a room_participant.
     */
    data: XOR<room_participantUpdateInput, room_participantUncheckedUpdateInput>
    /**
     * Choose, which room_participant to update.
     */
    where: room_participantWhereUniqueInput
  }

  /**
   * room_participant updateMany
   */
  export type room_participantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update room_participants.
     */
    data: XOR<room_participantUpdateManyMutationInput, room_participantUncheckedUpdateManyInput>
    /**
     * Filter which room_participants to update
     */
    where?: room_participantWhereInput
    /**
     * Limit how many room_participants to update.
     */
    limit?: number
  }

  /**
   * room_participant upsert
   */
  export type room_participantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * The filter to search for the room_participant to update in case it exists.
     */
    where: room_participantWhereUniqueInput
    /**
     * In case the room_participant found by the `where` argument doesn't exist, create a new room_participant with this data.
     */
    create: XOR<room_participantCreateInput, room_participantUncheckedCreateInput>
    /**
     * In case the room_participant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<room_participantUpdateInput, room_participantUncheckedUpdateInput>
  }

  /**
   * room_participant delete
   */
  export type room_participantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
    /**
     * Filter which room_participant to delete.
     */
    where: room_participantWhereUniqueInput
  }

  /**
   * room_participant deleteMany
   */
  export type room_participantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room_participants to delete
     */
    where?: room_participantWhereInput
    /**
     * Limit how many room_participants to delete.
     */
    limit?: number
  }

  /**
   * room_participant without action
   */
  export type room_participantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_participant
     */
    select?: room_participantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_participant
     */
    omit?: room_participantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_participantInclude<ExtArgs> | null
  }


  /**
   * Model dm_pair_unique
   */

  export type AggregateDm_pair_unique = {
    _count: Dm_pair_uniqueCountAggregateOutputType | null
    _min: Dm_pair_uniqueMinAggregateOutputType | null
    _max: Dm_pair_uniqueMaxAggregateOutputType | null
  }

  export type Dm_pair_uniqueMinAggregateOutputType = {
    id: string | null
    userA: string | null
    userB: string | null
    roomId: string | null
  }

  export type Dm_pair_uniqueMaxAggregateOutputType = {
    id: string | null
    userA: string | null
    userB: string | null
    roomId: string | null
  }

  export type Dm_pair_uniqueCountAggregateOutputType = {
    id: number
    userA: number
    userB: number
    roomId: number
    _all: number
  }


  export type Dm_pair_uniqueMinAggregateInputType = {
    id?: true
    userA?: true
    userB?: true
    roomId?: true
  }

  export type Dm_pair_uniqueMaxAggregateInputType = {
    id?: true
    userA?: true
    userB?: true
    roomId?: true
  }

  export type Dm_pair_uniqueCountAggregateInputType = {
    id?: true
    userA?: true
    userB?: true
    roomId?: true
    _all?: true
  }

  export type Dm_pair_uniqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dm_pair_unique to aggregate.
     */
    where?: dm_pair_uniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dm_pair_uniques to fetch.
     */
    orderBy?: dm_pair_uniqueOrderByWithRelationInput | dm_pair_uniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dm_pair_uniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dm_pair_uniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dm_pair_uniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dm_pair_uniques
    **/
    _count?: true | Dm_pair_uniqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dm_pair_uniqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dm_pair_uniqueMaxAggregateInputType
  }

  export type GetDm_pair_uniqueAggregateType<T extends Dm_pair_uniqueAggregateArgs> = {
        [P in keyof T & keyof AggregateDm_pair_unique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDm_pair_unique[P]>
      : GetScalarType<T[P], AggregateDm_pair_unique[P]>
  }




  export type dm_pair_uniqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dm_pair_uniqueWhereInput
    orderBy?: dm_pair_uniqueOrderByWithAggregationInput | dm_pair_uniqueOrderByWithAggregationInput[]
    by: Dm_pair_uniqueScalarFieldEnum[] | Dm_pair_uniqueScalarFieldEnum
    having?: dm_pair_uniqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dm_pair_uniqueCountAggregateInputType | true
    _min?: Dm_pair_uniqueMinAggregateInputType
    _max?: Dm_pair_uniqueMaxAggregateInputType
  }

  export type Dm_pair_uniqueGroupByOutputType = {
    id: string
    userA: string
    userB: string
    roomId: string
    _count: Dm_pair_uniqueCountAggregateOutputType | null
    _min: Dm_pair_uniqueMinAggregateOutputType | null
    _max: Dm_pair_uniqueMaxAggregateOutputType | null
  }

  type GetDm_pair_uniqueGroupByPayload<T extends dm_pair_uniqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dm_pair_uniqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dm_pair_uniqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dm_pair_uniqueGroupByOutputType[P]>
            : GetScalarType<T[P], Dm_pair_uniqueGroupByOutputType[P]>
        }
      >
    >


  export type dm_pair_uniqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userA?: boolean
    userB?: boolean
    roomId?: boolean
    room?: boolean | roomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dm_pair_unique"]>



  export type dm_pair_uniqueSelectScalar = {
    id?: boolean
    userA?: boolean
    userB?: boolean
    roomId?: boolean
  }

  export type dm_pair_uniqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userA" | "userB" | "roomId", ExtArgs["result"]["dm_pair_unique"]>
  export type dm_pair_uniqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | roomDefaultArgs<ExtArgs>
  }

  export type $dm_pair_uniquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dm_pair_unique"
    objects: {
      room: Prisma.$roomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userA: string
      userB: string
      roomId: string
    }, ExtArgs["result"]["dm_pair_unique"]>
    composites: {}
  }

  type dm_pair_uniqueGetPayload<S extends boolean | null | undefined | dm_pair_uniqueDefaultArgs> = $Result.GetResult<Prisma.$dm_pair_uniquePayload, S>

  type dm_pair_uniqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dm_pair_uniqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Dm_pair_uniqueCountAggregateInputType | true
    }

  export interface dm_pair_uniqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dm_pair_unique'], meta: { name: 'dm_pair_unique' } }
    /**
     * Find zero or one Dm_pair_unique that matches the filter.
     * @param {dm_pair_uniqueFindUniqueArgs} args - Arguments to find a Dm_pair_unique
     * @example
     * // Get one Dm_pair_unique
     * const dm_pair_unique = await prisma.dm_pair_unique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dm_pair_uniqueFindUniqueArgs>(args: SelectSubset<T, dm_pair_uniqueFindUniqueArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dm_pair_unique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dm_pair_uniqueFindUniqueOrThrowArgs} args - Arguments to find a Dm_pair_unique
     * @example
     * // Get one Dm_pair_unique
     * const dm_pair_unique = await prisma.dm_pair_unique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dm_pair_uniqueFindUniqueOrThrowArgs>(args: SelectSubset<T, dm_pair_uniqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dm_pair_unique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dm_pair_uniqueFindFirstArgs} args - Arguments to find a Dm_pair_unique
     * @example
     * // Get one Dm_pair_unique
     * const dm_pair_unique = await prisma.dm_pair_unique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dm_pair_uniqueFindFirstArgs>(args?: SelectSubset<T, dm_pair_uniqueFindFirstArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dm_pair_unique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dm_pair_uniqueFindFirstOrThrowArgs} args - Arguments to find a Dm_pair_unique
     * @example
     * // Get one Dm_pair_unique
     * const dm_pair_unique = await prisma.dm_pair_unique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dm_pair_uniqueFindFirstOrThrowArgs>(args?: SelectSubset<T, dm_pair_uniqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dm_pair_uniques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dm_pair_uniqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dm_pair_uniques
     * const dm_pair_uniques = await prisma.dm_pair_unique.findMany()
     * 
     * // Get first 10 Dm_pair_uniques
     * const dm_pair_uniques = await prisma.dm_pair_unique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dm_pair_uniqueWithIdOnly = await prisma.dm_pair_unique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dm_pair_uniqueFindManyArgs>(args?: SelectSubset<T, dm_pair_uniqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dm_pair_unique.
     * @param {dm_pair_uniqueCreateArgs} args - Arguments to create a Dm_pair_unique.
     * @example
     * // Create one Dm_pair_unique
     * const Dm_pair_unique = await prisma.dm_pair_unique.create({
     *   data: {
     *     // ... data to create a Dm_pair_unique
     *   }
     * })
     * 
     */
    create<T extends dm_pair_uniqueCreateArgs>(args: SelectSubset<T, dm_pair_uniqueCreateArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dm_pair_uniques.
     * @param {dm_pair_uniqueCreateManyArgs} args - Arguments to create many Dm_pair_uniques.
     * @example
     * // Create many Dm_pair_uniques
     * const dm_pair_unique = await prisma.dm_pair_unique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dm_pair_uniqueCreateManyArgs>(args?: SelectSubset<T, dm_pair_uniqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dm_pair_unique.
     * @param {dm_pair_uniqueDeleteArgs} args - Arguments to delete one Dm_pair_unique.
     * @example
     * // Delete one Dm_pair_unique
     * const Dm_pair_unique = await prisma.dm_pair_unique.delete({
     *   where: {
     *     // ... filter to delete one Dm_pair_unique
     *   }
     * })
     * 
     */
    delete<T extends dm_pair_uniqueDeleteArgs>(args: SelectSubset<T, dm_pair_uniqueDeleteArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dm_pair_unique.
     * @param {dm_pair_uniqueUpdateArgs} args - Arguments to update one Dm_pair_unique.
     * @example
     * // Update one Dm_pair_unique
     * const dm_pair_unique = await prisma.dm_pair_unique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dm_pair_uniqueUpdateArgs>(args: SelectSubset<T, dm_pair_uniqueUpdateArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dm_pair_uniques.
     * @param {dm_pair_uniqueDeleteManyArgs} args - Arguments to filter Dm_pair_uniques to delete.
     * @example
     * // Delete a few Dm_pair_uniques
     * const { count } = await prisma.dm_pair_unique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dm_pair_uniqueDeleteManyArgs>(args?: SelectSubset<T, dm_pair_uniqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dm_pair_uniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dm_pair_uniqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dm_pair_uniques
     * const dm_pair_unique = await prisma.dm_pair_unique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dm_pair_uniqueUpdateManyArgs>(args: SelectSubset<T, dm_pair_uniqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dm_pair_unique.
     * @param {dm_pair_uniqueUpsertArgs} args - Arguments to update or create a Dm_pair_unique.
     * @example
     * // Update or create a Dm_pair_unique
     * const dm_pair_unique = await prisma.dm_pair_unique.upsert({
     *   create: {
     *     // ... data to create a Dm_pair_unique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dm_pair_unique we want to update
     *   }
     * })
     */
    upsert<T extends dm_pair_uniqueUpsertArgs>(args: SelectSubset<T, dm_pair_uniqueUpsertArgs<ExtArgs>>): Prisma__dm_pair_uniqueClient<$Result.GetResult<Prisma.$dm_pair_uniquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dm_pair_uniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dm_pair_uniqueCountArgs} args - Arguments to filter Dm_pair_uniques to count.
     * @example
     * // Count the number of Dm_pair_uniques
     * const count = await prisma.dm_pair_unique.count({
     *   where: {
     *     // ... the filter for the Dm_pair_uniques we want to count
     *   }
     * })
    **/
    count<T extends dm_pair_uniqueCountArgs>(
      args?: Subset<T, dm_pair_uniqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dm_pair_uniqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dm_pair_unique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dm_pair_uniqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dm_pair_uniqueAggregateArgs>(args: Subset<T, Dm_pair_uniqueAggregateArgs>): Prisma.PrismaPromise<GetDm_pair_uniqueAggregateType<T>>

    /**
     * Group by Dm_pair_unique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dm_pair_uniqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dm_pair_uniqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dm_pair_uniqueGroupByArgs['orderBy'] }
        : { orderBy?: dm_pair_uniqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dm_pair_uniqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDm_pair_uniqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dm_pair_unique model
   */
  readonly fields: dm_pair_uniqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dm_pair_unique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dm_pair_uniqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dm_pair_unique model
   */
  interface dm_pair_uniqueFieldRefs {
    readonly id: FieldRef<"dm_pair_unique", 'String'>
    readonly userA: FieldRef<"dm_pair_unique", 'String'>
    readonly userB: FieldRef<"dm_pair_unique", 'String'>
    readonly roomId: FieldRef<"dm_pair_unique", 'String'>
  }
    

  // Custom InputTypes
  /**
   * dm_pair_unique findUnique
   */
  export type dm_pair_uniqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * Filter, which dm_pair_unique to fetch.
     */
    where: dm_pair_uniqueWhereUniqueInput
  }

  /**
   * dm_pair_unique findUniqueOrThrow
   */
  export type dm_pair_uniqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * Filter, which dm_pair_unique to fetch.
     */
    where: dm_pair_uniqueWhereUniqueInput
  }

  /**
   * dm_pair_unique findFirst
   */
  export type dm_pair_uniqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * Filter, which dm_pair_unique to fetch.
     */
    where?: dm_pair_uniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dm_pair_uniques to fetch.
     */
    orderBy?: dm_pair_uniqueOrderByWithRelationInput | dm_pair_uniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dm_pair_uniques.
     */
    cursor?: dm_pair_uniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dm_pair_uniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dm_pair_uniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dm_pair_uniques.
     */
    distinct?: Dm_pair_uniqueScalarFieldEnum | Dm_pair_uniqueScalarFieldEnum[]
  }

  /**
   * dm_pair_unique findFirstOrThrow
   */
  export type dm_pair_uniqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * Filter, which dm_pair_unique to fetch.
     */
    where?: dm_pair_uniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dm_pair_uniques to fetch.
     */
    orderBy?: dm_pair_uniqueOrderByWithRelationInput | dm_pair_uniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dm_pair_uniques.
     */
    cursor?: dm_pair_uniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dm_pair_uniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dm_pair_uniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dm_pair_uniques.
     */
    distinct?: Dm_pair_uniqueScalarFieldEnum | Dm_pair_uniqueScalarFieldEnum[]
  }

  /**
   * dm_pair_unique findMany
   */
  export type dm_pair_uniqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * Filter, which dm_pair_uniques to fetch.
     */
    where?: dm_pair_uniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dm_pair_uniques to fetch.
     */
    orderBy?: dm_pair_uniqueOrderByWithRelationInput | dm_pair_uniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dm_pair_uniques.
     */
    cursor?: dm_pair_uniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dm_pair_uniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dm_pair_uniques.
     */
    skip?: number
    distinct?: Dm_pair_uniqueScalarFieldEnum | Dm_pair_uniqueScalarFieldEnum[]
  }

  /**
   * dm_pair_unique create
   */
  export type dm_pair_uniqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * The data needed to create a dm_pair_unique.
     */
    data: XOR<dm_pair_uniqueCreateInput, dm_pair_uniqueUncheckedCreateInput>
  }

  /**
   * dm_pair_unique createMany
   */
  export type dm_pair_uniqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dm_pair_uniques.
     */
    data: dm_pair_uniqueCreateManyInput | dm_pair_uniqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dm_pair_unique update
   */
  export type dm_pair_uniqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * The data needed to update a dm_pair_unique.
     */
    data: XOR<dm_pair_uniqueUpdateInput, dm_pair_uniqueUncheckedUpdateInput>
    /**
     * Choose, which dm_pair_unique to update.
     */
    where: dm_pair_uniqueWhereUniqueInput
  }

  /**
   * dm_pair_unique updateMany
   */
  export type dm_pair_uniqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dm_pair_uniques.
     */
    data: XOR<dm_pair_uniqueUpdateManyMutationInput, dm_pair_uniqueUncheckedUpdateManyInput>
    /**
     * Filter which dm_pair_uniques to update
     */
    where?: dm_pair_uniqueWhereInput
    /**
     * Limit how many dm_pair_uniques to update.
     */
    limit?: number
  }

  /**
   * dm_pair_unique upsert
   */
  export type dm_pair_uniqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * The filter to search for the dm_pair_unique to update in case it exists.
     */
    where: dm_pair_uniqueWhereUniqueInput
    /**
     * In case the dm_pair_unique found by the `where` argument doesn't exist, create a new dm_pair_unique with this data.
     */
    create: XOR<dm_pair_uniqueCreateInput, dm_pair_uniqueUncheckedCreateInput>
    /**
     * In case the dm_pair_unique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dm_pair_uniqueUpdateInput, dm_pair_uniqueUncheckedUpdateInput>
  }

  /**
   * dm_pair_unique delete
   */
  export type dm_pair_uniqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
    /**
     * Filter which dm_pair_unique to delete.
     */
    where: dm_pair_uniqueWhereUniqueInput
  }

  /**
   * dm_pair_unique deleteMany
   */
  export type dm_pair_uniqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dm_pair_uniques to delete
     */
    where?: dm_pair_uniqueWhereInput
    /**
     * Limit how many dm_pair_uniques to delete.
     */
    limit?: number
  }

  /**
   * dm_pair_unique without action
   */
  export type dm_pair_uniqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dm_pair_unique
     */
    select?: dm_pair_uniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dm_pair_unique
     */
    omit?: dm_pair_uniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dm_pair_uniqueInclude<ExtArgs> | null
  }


  /**
   * Model message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    authorId: string | null
    type: $Enums.message_type | null
    content: string | null
    attachments: string | null
    createdAt: Date | null
    editedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    authorId: string | null
    type: $Enums.message_type | null
    content: string | null
    attachments: string | null
    createdAt: Date | null
    editedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    roomId: number
    authorId: number
    type: number
    content: number
    attachments: number
    createdAt: number
    editedAt: number
    deletedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    roomId?: true
    authorId?: true
    type?: true
    content?: true
    attachments?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    roomId?: true
    authorId?: true
    type?: true
    content?: true
    attachments?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    roomId?: true
    authorId?: true
    type?: true
    content?: true
    attachments?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: messageOrderByWithAggregationInput | messageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    roomId: string
    authorId: string
    type: $Enums.message_type
    content: string | null
    attachments: string | null
    createdAt: Date
    editedAt: Date | null
    deletedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    authorId?: boolean
    type?: boolean
    content?: boolean
    attachments?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
    author?: boolean | userDefaultArgs<ExtArgs>
    room?: boolean | roomDefaultArgs<ExtArgs>
    reactions?: boolean | message$reactionsArgs<ExtArgs>
    reads?: boolean | message$readsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type messageSelectScalar = {
    id?: boolean
    roomId?: boolean
    authorId?: boolean
    type?: boolean
    content?: boolean
    attachments?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
  }

  export type messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "authorId" | "type" | "content" | "attachments" | "createdAt" | "editedAt" | "deletedAt", ExtArgs["result"]["message"]>
  export type messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | userDefaultArgs<ExtArgs>
    room?: boolean | roomDefaultArgs<ExtArgs>
    reactions?: boolean | message$reactionsArgs<ExtArgs>
    reads?: boolean | message$readsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message"
    objects: {
      author: Prisma.$userPayload<ExtArgs>
      room: Prisma.$roomPayload<ExtArgs>
      reactions: Prisma.$message_reactionPayload<ExtArgs>[]
      reads: Prisma.$message_readPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      authorId: string
      type: $Enums.message_type
      content: string | null
      attachments: string | null
      createdAt: Date
      editedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type messageGetPayload<S extends boolean | null | undefined | messageDefaultArgs> = $Result.GetResult<Prisma.$messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messageFindUniqueArgs>(args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs>(args: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messageFindFirstArgs>(args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs>(args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messageFindManyArgs>(args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends messageCreateArgs>(args: SelectSubset<T, messageCreateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messageCreateManyArgs>(args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends messageDeleteArgs>(args: SelectSubset<T, messageDeleteArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messageUpdateArgs>(args: SelectSubset<T, messageUpdateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messageDeleteManyArgs>(args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messageUpdateManyArgs>(args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends messageUpsertArgs>(args: SelectSubset<T, messageUpsertArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageGroupByArgs['orderBy'] }
        : { orderBy?: messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message model
   */
  readonly fields: messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reactions<T extends message$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, message$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reads<T extends message$readsArgs<ExtArgs> = {}>(args?: Subset<T, message$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message model
   */
  interface messageFieldRefs {
    readonly id: FieldRef<"message", 'String'>
    readonly roomId: FieldRef<"message", 'String'>
    readonly authorId: FieldRef<"message", 'String'>
    readonly type: FieldRef<"message", 'message_type'>
    readonly content: FieldRef<"message", 'String'>
    readonly attachments: FieldRef<"message", 'String'>
    readonly createdAt: FieldRef<"message", 'DateTime'>
    readonly editedAt: FieldRef<"message", 'DateTime'>
    readonly deletedAt: FieldRef<"message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * message findUnique
   */
  export type messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findFirst
   */
  export type messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data: XOR<messageCreateInput, messageUncheckedCreateInput>
  }

  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }

  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * message.reactions
   */
  export type message$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    where?: message_reactionWhereInput
    orderBy?: message_reactionOrderByWithRelationInput | message_reactionOrderByWithRelationInput[]
    cursor?: message_reactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Message_reactionScalarFieldEnum | Message_reactionScalarFieldEnum[]
  }

  /**
   * message.reads
   */
  export type message$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    where?: message_readWhereInput
    orderBy?: message_readOrderByWithRelationInput | message_readOrderByWithRelationInput[]
    cursor?: message_readWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Message_readScalarFieldEnum | Message_readScalarFieldEnum[]
  }

  /**
   * message without action
   */
  export type messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
  }


  /**
   * Model message_read
   */

  export type AggregateMessage_read = {
    _count: Message_readCountAggregateOutputType | null
    _min: Message_readMinAggregateOutputType | null
    _max: Message_readMaxAggregateOutputType | null
  }

  export type Message_readMinAggregateOutputType = {
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type Message_readMaxAggregateOutputType = {
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type Message_readCountAggregateOutputType = {
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type Message_readMinAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type Message_readMaxAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type Message_readCountAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type Message_readAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_read to aggregate.
     */
    where?: message_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reads to fetch.
     */
    orderBy?: message_readOrderByWithRelationInput | message_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: message_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned message_reads
    **/
    _count?: true | Message_readCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Message_readMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Message_readMaxAggregateInputType
  }

  export type GetMessage_readAggregateType<T extends Message_readAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage_read]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage_read[P]>
      : GetScalarType<T[P], AggregateMessage_read[P]>
  }




  export type message_readGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_readWhereInput
    orderBy?: message_readOrderByWithAggregationInput | message_readOrderByWithAggregationInput[]
    by: Message_readScalarFieldEnum[] | Message_readScalarFieldEnum
    having?: message_readScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Message_readCountAggregateInputType | true
    _min?: Message_readMinAggregateInputType
    _max?: Message_readMaxAggregateInputType
  }

  export type Message_readGroupByOutputType = {
    messageId: string
    userId: string
    readAt: Date
    _count: Message_readCountAggregateOutputType | null
    _min: Message_readMinAggregateOutputType | null
    _max: Message_readMaxAggregateOutputType | null
  }

  type GetMessage_readGroupByPayload<T extends message_readGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Message_readGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Message_readGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Message_readGroupByOutputType[P]>
            : GetScalarType<T[P], Message_readGroupByOutputType[P]>
        }
      >
    >


  export type message_readSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | messageDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_read"]>



  export type message_readSelectScalar = {
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type message_readOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"messageId" | "userId" | "readAt", ExtArgs["result"]["message_read"]>
  export type message_readInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | messageDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $message_readPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message_read"
    objects: {
      message: Prisma.$messagePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["message_read"]>
    composites: {}
  }

  type message_readGetPayload<S extends boolean | null | undefined | message_readDefaultArgs> = $Result.GetResult<Prisma.$message_readPayload, S>

  type message_readCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<message_readFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Message_readCountAggregateInputType | true
    }

  export interface message_readDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message_read'], meta: { name: 'message_read' } }
    /**
     * Find zero or one Message_read that matches the filter.
     * @param {message_readFindUniqueArgs} args - Arguments to find a Message_read
     * @example
     * // Get one Message_read
     * const message_read = await prisma.message_read.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends message_readFindUniqueArgs>(args: SelectSubset<T, message_readFindUniqueArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message_read that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {message_readFindUniqueOrThrowArgs} args - Arguments to find a Message_read
     * @example
     * // Get one Message_read
     * const message_read = await prisma.message_read.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends message_readFindUniqueOrThrowArgs>(args: SelectSubset<T, message_readFindUniqueOrThrowArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message_read that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_readFindFirstArgs} args - Arguments to find a Message_read
     * @example
     * // Get one Message_read
     * const message_read = await prisma.message_read.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends message_readFindFirstArgs>(args?: SelectSubset<T, message_readFindFirstArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message_read that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_readFindFirstOrThrowArgs} args - Arguments to find a Message_read
     * @example
     * // Get one Message_read
     * const message_read = await prisma.message_read.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends message_readFindFirstOrThrowArgs>(args?: SelectSubset<T, message_readFindFirstOrThrowArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Message_reads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_readFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Message_reads
     * const message_reads = await prisma.message_read.findMany()
     * 
     * // Get first 10 Message_reads
     * const message_reads = await prisma.message_read.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const message_readWithMessageIdOnly = await prisma.message_read.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends message_readFindManyArgs>(args?: SelectSubset<T, message_readFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message_read.
     * @param {message_readCreateArgs} args - Arguments to create a Message_read.
     * @example
     * // Create one Message_read
     * const Message_read = await prisma.message_read.create({
     *   data: {
     *     // ... data to create a Message_read
     *   }
     * })
     * 
     */
    create<T extends message_readCreateArgs>(args: SelectSubset<T, message_readCreateArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Message_reads.
     * @param {message_readCreateManyArgs} args - Arguments to create many Message_reads.
     * @example
     * // Create many Message_reads
     * const message_read = await prisma.message_read.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends message_readCreateManyArgs>(args?: SelectSubset<T, message_readCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message_read.
     * @param {message_readDeleteArgs} args - Arguments to delete one Message_read.
     * @example
     * // Delete one Message_read
     * const Message_read = await prisma.message_read.delete({
     *   where: {
     *     // ... filter to delete one Message_read
     *   }
     * })
     * 
     */
    delete<T extends message_readDeleteArgs>(args: SelectSubset<T, message_readDeleteArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message_read.
     * @param {message_readUpdateArgs} args - Arguments to update one Message_read.
     * @example
     * // Update one Message_read
     * const message_read = await prisma.message_read.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends message_readUpdateArgs>(args: SelectSubset<T, message_readUpdateArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Message_reads.
     * @param {message_readDeleteManyArgs} args - Arguments to filter Message_reads to delete.
     * @example
     * // Delete a few Message_reads
     * const { count } = await prisma.message_read.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends message_readDeleteManyArgs>(args?: SelectSubset<T, message_readDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_reads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_readUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Message_reads
     * const message_read = await prisma.message_read.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends message_readUpdateManyArgs>(args: SelectSubset<T, message_readUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message_read.
     * @param {message_readUpsertArgs} args - Arguments to update or create a Message_read.
     * @example
     * // Update or create a Message_read
     * const message_read = await prisma.message_read.upsert({
     *   create: {
     *     // ... data to create a Message_read
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message_read we want to update
     *   }
     * })
     */
    upsert<T extends message_readUpsertArgs>(args: SelectSubset<T, message_readUpsertArgs<ExtArgs>>): Prisma__message_readClient<$Result.GetResult<Prisma.$message_readPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Message_reads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_readCountArgs} args - Arguments to filter Message_reads to count.
     * @example
     * // Count the number of Message_reads
     * const count = await prisma.message_read.count({
     *   where: {
     *     // ... the filter for the Message_reads we want to count
     *   }
     * })
    **/
    count<T extends message_readCountArgs>(
      args?: Subset<T, message_readCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Message_readCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message_read.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_readAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Message_readAggregateArgs>(args: Subset<T, Message_readAggregateArgs>): Prisma.PrismaPromise<GetMessage_readAggregateType<T>>

    /**
     * Group by Message_read.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_readGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends message_readGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: message_readGroupByArgs['orderBy'] }
        : { orderBy?: message_readGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, message_readGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessage_readGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message_read model
   */
  readonly fields: message_readFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message_read.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__message_readClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends messageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, messageDefaultArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message_read model
   */
  interface message_readFieldRefs {
    readonly messageId: FieldRef<"message_read", 'String'>
    readonly userId: FieldRef<"message_read", 'String'>
    readonly readAt: FieldRef<"message_read", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * message_read findUnique
   */
  export type message_readFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * Filter, which message_read to fetch.
     */
    where: message_readWhereUniqueInput
  }

  /**
   * message_read findUniqueOrThrow
   */
  export type message_readFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * Filter, which message_read to fetch.
     */
    where: message_readWhereUniqueInput
  }

  /**
   * message_read findFirst
   */
  export type message_readFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * Filter, which message_read to fetch.
     */
    where?: message_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reads to fetch.
     */
    orderBy?: message_readOrderByWithRelationInput | message_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_reads.
     */
    cursor?: message_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_reads.
     */
    distinct?: Message_readScalarFieldEnum | Message_readScalarFieldEnum[]
  }

  /**
   * message_read findFirstOrThrow
   */
  export type message_readFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * Filter, which message_read to fetch.
     */
    where?: message_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reads to fetch.
     */
    orderBy?: message_readOrderByWithRelationInput | message_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_reads.
     */
    cursor?: message_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_reads.
     */
    distinct?: Message_readScalarFieldEnum | Message_readScalarFieldEnum[]
  }

  /**
   * message_read findMany
   */
  export type message_readFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * Filter, which message_reads to fetch.
     */
    where?: message_readWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reads to fetch.
     */
    orderBy?: message_readOrderByWithRelationInput | message_readOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing message_reads.
     */
    cursor?: message_readWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reads.
     */
    skip?: number
    distinct?: Message_readScalarFieldEnum | Message_readScalarFieldEnum[]
  }

  /**
   * message_read create
   */
  export type message_readCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * The data needed to create a message_read.
     */
    data: XOR<message_readCreateInput, message_readUncheckedCreateInput>
  }

  /**
   * message_read createMany
   */
  export type message_readCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many message_reads.
     */
    data: message_readCreateManyInput | message_readCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message_read update
   */
  export type message_readUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * The data needed to update a message_read.
     */
    data: XOR<message_readUpdateInput, message_readUncheckedUpdateInput>
    /**
     * Choose, which message_read to update.
     */
    where: message_readWhereUniqueInput
  }

  /**
   * message_read updateMany
   */
  export type message_readUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update message_reads.
     */
    data: XOR<message_readUpdateManyMutationInput, message_readUncheckedUpdateManyInput>
    /**
     * Filter which message_reads to update
     */
    where?: message_readWhereInput
    /**
     * Limit how many message_reads to update.
     */
    limit?: number
  }

  /**
   * message_read upsert
   */
  export type message_readUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * The filter to search for the message_read to update in case it exists.
     */
    where: message_readWhereUniqueInput
    /**
     * In case the message_read found by the `where` argument doesn't exist, create a new message_read with this data.
     */
    create: XOR<message_readCreateInput, message_readUncheckedCreateInput>
    /**
     * In case the message_read was found with the provided `where` argument, update it with this data.
     */
    update: XOR<message_readUpdateInput, message_readUncheckedUpdateInput>
  }

  /**
   * message_read delete
   */
  export type message_readDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
    /**
     * Filter which message_read to delete.
     */
    where: message_readWhereUniqueInput
  }

  /**
   * message_read deleteMany
   */
  export type message_readDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_reads to delete
     */
    where?: message_readWhereInput
    /**
     * Limit how many message_reads to delete.
     */
    limit?: number
  }

  /**
   * message_read without action
   */
  export type message_readDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_read
     */
    select?: message_readSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_read
     */
    omit?: message_readOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_readInclude<ExtArgs> | null
  }


  /**
   * Model message_reaction
   */

  export type AggregateMessage_reaction = {
    _count: Message_reactionCountAggregateOutputType | null
    _min: Message_reactionMinAggregateOutputType | null
    _max: Message_reactionMaxAggregateOutputType | null
  }

  export type Message_reactionMinAggregateOutputType = {
    messageId: string | null
    userId: string | null
    emoji: string | null
    createdAt: Date | null
  }

  export type Message_reactionMaxAggregateOutputType = {
    messageId: string | null
    userId: string | null
    emoji: string | null
    createdAt: Date | null
  }

  export type Message_reactionCountAggregateOutputType = {
    messageId: number
    userId: number
    emoji: number
    createdAt: number
    _all: number
  }


  export type Message_reactionMinAggregateInputType = {
    messageId?: true
    userId?: true
    emoji?: true
    createdAt?: true
  }

  export type Message_reactionMaxAggregateInputType = {
    messageId?: true
    userId?: true
    emoji?: true
    createdAt?: true
  }

  export type Message_reactionCountAggregateInputType = {
    messageId?: true
    userId?: true
    emoji?: true
    createdAt?: true
    _all?: true
  }

  export type Message_reactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_reaction to aggregate.
     */
    where?: message_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionOrderByWithRelationInput | message_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: message_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned message_reactions
    **/
    _count?: true | Message_reactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Message_reactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Message_reactionMaxAggregateInputType
  }

  export type GetMessage_reactionAggregateType<T extends Message_reactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage_reaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage_reaction[P]>
      : GetScalarType<T[P], AggregateMessage_reaction[P]>
  }




  export type message_reactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_reactionWhereInput
    orderBy?: message_reactionOrderByWithAggregationInput | message_reactionOrderByWithAggregationInput[]
    by: Message_reactionScalarFieldEnum[] | Message_reactionScalarFieldEnum
    having?: message_reactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Message_reactionCountAggregateInputType | true
    _min?: Message_reactionMinAggregateInputType
    _max?: Message_reactionMaxAggregateInputType
  }

  export type Message_reactionGroupByOutputType = {
    messageId: string
    userId: string
    emoji: string
    createdAt: Date
    _count: Message_reactionCountAggregateOutputType | null
    _min: Message_reactionMinAggregateOutputType | null
    _max: Message_reactionMaxAggregateOutputType | null
  }

  type GetMessage_reactionGroupByPayload<T extends message_reactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Message_reactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Message_reactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Message_reactionGroupByOutputType[P]>
            : GetScalarType<T[P], Message_reactionGroupByOutputType[P]>
        }
      >
    >


  export type message_reactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    createdAt?: boolean
    message?: boolean | messageDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_reaction"]>



  export type message_reactionSelectScalar = {
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    createdAt?: boolean
  }

  export type message_reactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"messageId" | "userId" | "emoji" | "createdAt", ExtArgs["result"]["message_reaction"]>
  export type message_reactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | messageDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $message_reactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message_reaction"
    objects: {
      message: Prisma.$messagePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: string
      userId: string
      emoji: string
      createdAt: Date
    }, ExtArgs["result"]["message_reaction"]>
    composites: {}
  }

  type message_reactionGetPayload<S extends boolean | null | undefined | message_reactionDefaultArgs> = $Result.GetResult<Prisma.$message_reactionPayload, S>

  type message_reactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<message_reactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Message_reactionCountAggregateInputType | true
    }

  export interface message_reactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message_reaction'], meta: { name: 'message_reaction' } }
    /**
     * Find zero or one Message_reaction that matches the filter.
     * @param {message_reactionFindUniqueArgs} args - Arguments to find a Message_reaction
     * @example
     * // Get one Message_reaction
     * const message_reaction = await prisma.message_reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends message_reactionFindUniqueArgs>(args: SelectSubset<T, message_reactionFindUniqueArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message_reaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {message_reactionFindUniqueOrThrowArgs} args - Arguments to find a Message_reaction
     * @example
     * // Get one Message_reaction
     * const message_reaction = await prisma.message_reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends message_reactionFindUniqueOrThrowArgs>(args: SelectSubset<T, message_reactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message_reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionFindFirstArgs} args - Arguments to find a Message_reaction
     * @example
     * // Get one Message_reaction
     * const message_reaction = await prisma.message_reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends message_reactionFindFirstArgs>(args?: SelectSubset<T, message_reactionFindFirstArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message_reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionFindFirstOrThrowArgs} args - Arguments to find a Message_reaction
     * @example
     * // Get one Message_reaction
     * const message_reaction = await prisma.message_reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends message_reactionFindFirstOrThrowArgs>(args?: SelectSubset<T, message_reactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Message_reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Message_reactions
     * const message_reactions = await prisma.message_reaction.findMany()
     * 
     * // Get first 10 Message_reactions
     * const message_reactions = await prisma.message_reaction.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const message_reactionWithMessageIdOnly = await prisma.message_reaction.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends message_reactionFindManyArgs>(args?: SelectSubset<T, message_reactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message_reaction.
     * @param {message_reactionCreateArgs} args - Arguments to create a Message_reaction.
     * @example
     * // Create one Message_reaction
     * const Message_reaction = await prisma.message_reaction.create({
     *   data: {
     *     // ... data to create a Message_reaction
     *   }
     * })
     * 
     */
    create<T extends message_reactionCreateArgs>(args: SelectSubset<T, message_reactionCreateArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Message_reactions.
     * @param {message_reactionCreateManyArgs} args - Arguments to create many Message_reactions.
     * @example
     * // Create many Message_reactions
     * const message_reaction = await prisma.message_reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends message_reactionCreateManyArgs>(args?: SelectSubset<T, message_reactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message_reaction.
     * @param {message_reactionDeleteArgs} args - Arguments to delete one Message_reaction.
     * @example
     * // Delete one Message_reaction
     * const Message_reaction = await prisma.message_reaction.delete({
     *   where: {
     *     // ... filter to delete one Message_reaction
     *   }
     * })
     * 
     */
    delete<T extends message_reactionDeleteArgs>(args: SelectSubset<T, message_reactionDeleteArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message_reaction.
     * @param {message_reactionUpdateArgs} args - Arguments to update one Message_reaction.
     * @example
     * // Update one Message_reaction
     * const message_reaction = await prisma.message_reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends message_reactionUpdateArgs>(args: SelectSubset<T, message_reactionUpdateArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Message_reactions.
     * @param {message_reactionDeleteManyArgs} args - Arguments to filter Message_reactions to delete.
     * @example
     * // Delete a few Message_reactions
     * const { count } = await prisma.message_reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends message_reactionDeleteManyArgs>(args?: SelectSubset<T, message_reactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Message_reactions
     * const message_reaction = await prisma.message_reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends message_reactionUpdateManyArgs>(args: SelectSubset<T, message_reactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message_reaction.
     * @param {message_reactionUpsertArgs} args - Arguments to update or create a Message_reaction.
     * @example
     * // Update or create a Message_reaction
     * const message_reaction = await prisma.message_reaction.upsert({
     *   create: {
     *     // ... data to create a Message_reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message_reaction we want to update
     *   }
     * })
     */
    upsert<T extends message_reactionUpsertArgs>(args: SelectSubset<T, message_reactionUpsertArgs<ExtArgs>>): Prisma__message_reactionClient<$Result.GetResult<Prisma.$message_reactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Message_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionCountArgs} args - Arguments to filter Message_reactions to count.
     * @example
     * // Count the number of Message_reactions
     * const count = await prisma.message_reaction.count({
     *   where: {
     *     // ... the filter for the Message_reactions we want to count
     *   }
     * })
    **/
    count<T extends message_reactionCountArgs>(
      args?: Subset<T, message_reactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Message_reactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message_reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_reactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Message_reactionAggregateArgs>(args: Subset<T, Message_reactionAggregateArgs>): Prisma.PrismaPromise<GetMessage_reactionAggregateType<T>>

    /**
     * Group by Message_reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends message_reactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: message_reactionGroupByArgs['orderBy'] }
        : { orderBy?: message_reactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, message_reactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessage_reactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message_reaction model
   */
  readonly fields: message_reactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message_reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__message_reactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends messageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, messageDefaultArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message_reaction model
   */
  interface message_reactionFieldRefs {
    readonly messageId: FieldRef<"message_reaction", 'String'>
    readonly userId: FieldRef<"message_reaction", 'String'>
    readonly emoji: FieldRef<"message_reaction", 'String'>
    readonly createdAt: FieldRef<"message_reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * message_reaction findUnique
   */
  export type message_reactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * Filter, which message_reaction to fetch.
     */
    where: message_reactionWhereUniqueInput
  }

  /**
   * message_reaction findUniqueOrThrow
   */
  export type message_reactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * Filter, which message_reaction to fetch.
     */
    where: message_reactionWhereUniqueInput
  }

  /**
   * message_reaction findFirst
   */
  export type message_reactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * Filter, which message_reaction to fetch.
     */
    where?: message_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionOrderByWithRelationInput | message_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_reactions.
     */
    cursor?: message_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_reactions.
     */
    distinct?: Message_reactionScalarFieldEnum | Message_reactionScalarFieldEnum[]
  }

  /**
   * message_reaction findFirstOrThrow
   */
  export type message_reactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * Filter, which message_reaction to fetch.
     */
    where?: message_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionOrderByWithRelationInput | message_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_reactions.
     */
    cursor?: message_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_reactions.
     */
    distinct?: Message_reactionScalarFieldEnum | Message_reactionScalarFieldEnum[]
  }

  /**
   * message_reaction findMany
   */
  export type message_reactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * Filter, which message_reactions to fetch.
     */
    where?: message_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionOrderByWithRelationInput | message_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing message_reactions.
     */
    cursor?: message_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    distinct?: Message_reactionScalarFieldEnum | Message_reactionScalarFieldEnum[]
  }

  /**
   * message_reaction create
   */
  export type message_reactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * The data needed to create a message_reaction.
     */
    data: XOR<message_reactionCreateInput, message_reactionUncheckedCreateInput>
  }

  /**
   * message_reaction createMany
   */
  export type message_reactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many message_reactions.
     */
    data: message_reactionCreateManyInput | message_reactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message_reaction update
   */
  export type message_reactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * The data needed to update a message_reaction.
     */
    data: XOR<message_reactionUpdateInput, message_reactionUncheckedUpdateInput>
    /**
     * Choose, which message_reaction to update.
     */
    where: message_reactionWhereUniqueInput
  }

  /**
   * message_reaction updateMany
   */
  export type message_reactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update message_reactions.
     */
    data: XOR<message_reactionUpdateManyMutationInput, message_reactionUncheckedUpdateManyInput>
    /**
     * Filter which message_reactions to update
     */
    where?: message_reactionWhereInput
    /**
     * Limit how many message_reactions to update.
     */
    limit?: number
  }

  /**
   * message_reaction upsert
   */
  export type message_reactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * The filter to search for the message_reaction to update in case it exists.
     */
    where: message_reactionWhereUniqueInput
    /**
     * In case the message_reaction found by the `where` argument doesn't exist, create a new message_reaction with this data.
     */
    create: XOR<message_reactionCreateInput, message_reactionUncheckedCreateInput>
    /**
     * In case the message_reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<message_reactionUpdateInput, message_reactionUncheckedUpdateInput>
  }

  /**
   * message_reaction delete
   */
  export type message_reactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
    /**
     * Filter which message_reaction to delete.
     */
    where: message_reactionWhereUniqueInput
  }

  /**
   * message_reaction deleteMany
   */
  export type message_reactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_reactions to delete
     */
    where?: message_reactionWhereInput
    /**
     * Limit how many message_reactions to delete.
     */
    limit?: number
  }

  /**
   * message_reaction without action
   */
  export type message_reactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reaction
     */
    select?: message_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reaction
     */
    omit?: message_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionInclude<ExtArgs> | null
  }


  /**
   * Model room_view
   */

  export type AggregateRoom_view = {
    _count: Room_viewCountAggregateOutputType | null
    _min: Room_viewMinAggregateOutputType | null
    _max: Room_viewMaxAggregateOutputType | null
  }

  export type Room_viewMinAggregateOutputType = {
    roomId: string | null
    userId: string | null
    lastSeenAt: Date | null
  }

  export type Room_viewMaxAggregateOutputType = {
    roomId: string | null
    userId: string | null
    lastSeenAt: Date | null
  }

  export type Room_viewCountAggregateOutputType = {
    roomId: number
    userId: number
    lastSeenAt: number
    _all: number
  }


  export type Room_viewMinAggregateInputType = {
    roomId?: true
    userId?: true
    lastSeenAt?: true
  }

  export type Room_viewMaxAggregateInputType = {
    roomId?: true
    userId?: true
    lastSeenAt?: true
  }

  export type Room_viewCountAggregateInputType = {
    roomId?: true
    userId?: true
    lastSeenAt?: true
    _all?: true
  }

  export type Room_viewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room_view to aggregate.
     */
    where?: room_viewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_views to fetch.
     */
    orderBy?: room_viewOrderByWithRelationInput | room_viewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: room_viewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned room_views
    **/
    _count?: true | Room_viewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Room_viewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Room_viewMaxAggregateInputType
  }

  export type GetRoom_viewAggregateType<T extends Room_viewAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom_view]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom_view[P]>
      : GetScalarType<T[P], AggregateRoom_view[P]>
  }




  export type room_viewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_viewWhereInput
    orderBy?: room_viewOrderByWithAggregationInput | room_viewOrderByWithAggregationInput[]
    by: Room_viewScalarFieldEnum[] | Room_viewScalarFieldEnum
    having?: room_viewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Room_viewCountAggregateInputType | true
    _min?: Room_viewMinAggregateInputType
    _max?: Room_viewMaxAggregateInputType
  }

  export type Room_viewGroupByOutputType = {
    roomId: string
    userId: string
    lastSeenAt: Date
    _count: Room_viewCountAggregateOutputType | null
    _min: Room_viewMinAggregateOutputType | null
    _max: Room_viewMaxAggregateOutputType | null
  }

  type GetRoom_viewGroupByPayload<T extends room_viewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Room_viewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Room_viewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Room_viewGroupByOutputType[P]>
            : GetScalarType<T[P], Room_viewGroupByOutputType[P]>
        }
      >
    >


  export type room_viewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    userId?: boolean
    lastSeenAt?: boolean
    room?: boolean | roomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room_view"]>



  export type room_viewSelectScalar = {
    roomId?: boolean
    userId?: boolean
    lastSeenAt?: boolean
  }

  export type room_viewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roomId" | "userId" | "lastSeenAt", ExtArgs["result"]["room_view"]>
  export type room_viewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | roomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $room_viewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "room_view"
    objects: {
      room: Prisma.$roomPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roomId: string
      userId: string
      lastSeenAt: Date
    }, ExtArgs["result"]["room_view"]>
    composites: {}
  }

  type room_viewGetPayload<S extends boolean | null | undefined | room_viewDefaultArgs> = $Result.GetResult<Prisma.$room_viewPayload, S>

  type room_viewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<room_viewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Room_viewCountAggregateInputType | true
    }

  export interface room_viewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['room_view'], meta: { name: 'room_view' } }
    /**
     * Find zero or one Room_view that matches the filter.
     * @param {room_viewFindUniqueArgs} args - Arguments to find a Room_view
     * @example
     * // Get one Room_view
     * const room_view = await prisma.room_view.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends room_viewFindUniqueArgs>(args: SelectSubset<T, room_viewFindUniqueArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room_view that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {room_viewFindUniqueOrThrowArgs} args - Arguments to find a Room_view
     * @example
     * // Get one Room_view
     * const room_view = await prisma.room_view.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends room_viewFindUniqueOrThrowArgs>(args: SelectSubset<T, room_viewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room_view that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_viewFindFirstArgs} args - Arguments to find a Room_view
     * @example
     * // Get one Room_view
     * const room_view = await prisma.room_view.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends room_viewFindFirstArgs>(args?: SelectSubset<T, room_viewFindFirstArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room_view that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_viewFindFirstOrThrowArgs} args - Arguments to find a Room_view
     * @example
     * // Get one Room_view
     * const room_view = await prisma.room_view.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends room_viewFindFirstOrThrowArgs>(args?: SelectSubset<T, room_viewFindFirstOrThrowArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Room_views that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_viewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Room_views
     * const room_views = await prisma.room_view.findMany()
     * 
     * // Get first 10 Room_views
     * const room_views = await prisma.room_view.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const room_viewWithRoomIdOnly = await prisma.room_view.findMany({ select: { roomId: true } })
     * 
     */
    findMany<T extends room_viewFindManyArgs>(args?: SelectSubset<T, room_viewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room_view.
     * @param {room_viewCreateArgs} args - Arguments to create a Room_view.
     * @example
     * // Create one Room_view
     * const Room_view = await prisma.room_view.create({
     *   data: {
     *     // ... data to create a Room_view
     *   }
     * })
     * 
     */
    create<T extends room_viewCreateArgs>(args: SelectSubset<T, room_viewCreateArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Room_views.
     * @param {room_viewCreateManyArgs} args - Arguments to create many Room_views.
     * @example
     * // Create many Room_views
     * const room_view = await prisma.room_view.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends room_viewCreateManyArgs>(args?: SelectSubset<T, room_viewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room_view.
     * @param {room_viewDeleteArgs} args - Arguments to delete one Room_view.
     * @example
     * // Delete one Room_view
     * const Room_view = await prisma.room_view.delete({
     *   where: {
     *     // ... filter to delete one Room_view
     *   }
     * })
     * 
     */
    delete<T extends room_viewDeleteArgs>(args: SelectSubset<T, room_viewDeleteArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room_view.
     * @param {room_viewUpdateArgs} args - Arguments to update one Room_view.
     * @example
     * // Update one Room_view
     * const room_view = await prisma.room_view.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends room_viewUpdateArgs>(args: SelectSubset<T, room_viewUpdateArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Room_views.
     * @param {room_viewDeleteManyArgs} args - Arguments to filter Room_views to delete.
     * @example
     * // Delete a few Room_views
     * const { count } = await prisma.room_view.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends room_viewDeleteManyArgs>(args?: SelectSubset<T, room_viewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Room_views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_viewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Room_views
     * const room_view = await prisma.room_view.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends room_viewUpdateManyArgs>(args: SelectSubset<T, room_viewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room_view.
     * @param {room_viewUpsertArgs} args - Arguments to update or create a Room_view.
     * @example
     * // Update or create a Room_view
     * const room_view = await prisma.room_view.upsert({
     *   create: {
     *     // ... data to create a Room_view
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room_view we want to update
     *   }
     * })
     */
    upsert<T extends room_viewUpsertArgs>(args: SelectSubset<T, room_viewUpsertArgs<ExtArgs>>): Prisma__room_viewClient<$Result.GetResult<Prisma.$room_viewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Room_views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_viewCountArgs} args - Arguments to filter Room_views to count.
     * @example
     * // Count the number of Room_views
     * const count = await prisma.room_view.count({
     *   where: {
     *     // ... the filter for the Room_views we want to count
     *   }
     * })
    **/
    count<T extends room_viewCountArgs>(
      args?: Subset<T, room_viewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Room_viewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room_view.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Room_viewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Room_viewAggregateArgs>(args: Subset<T, Room_viewAggregateArgs>): Prisma.PrismaPromise<GetRoom_viewAggregateType<T>>

    /**
     * Group by Room_view.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_viewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends room_viewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: room_viewGroupByArgs['orderBy'] }
        : { orderBy?: room_viewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, room_viewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoom_viewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the room_view model
   */
  readonly fields: room_viewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for room_view.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__room_viewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roomDefaultArgs<ExtArgs>>): Prisma__roomClient<$Result.GetResult<Prisma.$roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the room_view model
   */
  interface room_viewFieldRefs {
    readonly roomId: FieldRef<"room_view", 'String'>
    readonly userId: FieldRef<"room_view", 'String'>
    readonly lastSeenAt: FieldRef<"room_view", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * room_view findUnique
   */
  export type room_viewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * Filter, which room_view to fetch.
     */
    where: room_viewWhereUniqueInput
  }

  /**
   * room_view findUniqueOrThrow
   */
  export type room_viewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * Filter, which room_view to fetch.
     */
    where: room_viewWhereUniqueInput
  }

  /**
   * room_view findFirst
   */
  export type room_viewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * Filter, which room_view to fetch.
     */
    where?: room_viewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_views to fetch.
     */
    orderBy?: room_viewOrderByWithRelationInput | room_viewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for room_views.
     */
    cursor?: room_viewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of room_views.
     */
    distinct?: Room_viewScalarFieldEnum | Room_viewScalarFieldEnum[]
  }

  /**
   * room_view findFirstOrThrow
   */
  export type room_viewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * Filter, which room_view to fetch.
     */
    where?: room_viewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_views to fetch.
     */
    orderBy?: room_viewOrderByWithRelationInput | room_viewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for room_views.
     */
    cursor?: room_viewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of room_views.
     */
    distinct?: Room_viewScalarFieldEnum | Room_viewScalarFieldEnum[]
  }

  /**
   * room_view findMany
   */
  export type room_viewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * Filter, which room_views to fetch.
     */
    where?: room_viewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_views to fetch.
     */
    orderBy?: room_viewOrderByWithRelationInput | room_viewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing room_views.
     */
    cursor?: room_viewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_views.
     */
    skip?: number
    distinct?: Room_viewScalarFieldEnum | Room_viewScalarFieldEnum[]
  }

  /**
   * room_view create
   */
  export type room_viewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * The data needed to create a room_view.
     */
    data: XOR<room_viewCreateInput, room_viewUncheckedCreateInput>
  }

  /**
   * room_view createMany
   */
  export type room_viewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many room_views.
     */
    data: room_viewCreateManyInput | room_viewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * room_view update
   */
  export type room_viewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * The data needed to update a room_view.
     */
    data: XOR<room_viewUpdateInput, room_viewUncheckedUpdateInput>
    /**
     * Choose, which room_view to update.
     */
    where: room_viewWhereUniqueInput
  }

  /**
   * room_view updateMany
   */
  export type room_viewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update room_views.
     */
    data: XOR<room_viewUpdateManyMutationInput, room_viewUncheckedUpdateManyInput>
    /**
     * Filter which room_views to update
     */
    where?: room_viewWhereInput
    /**
     * Limit how many room_views to update.
     */
    limit?: number
  }

  /**
   * room_view upsert
   */
  export type room_viewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * The filter to search for the room_view to update in case it exists.
     */
    where: room_viewWhereUniqueInput
    /**
     * In case the room_view found by the `where` argument doesn't exist, create a new room_view with this data.
     */
    create: XOR<room_viewCreateInput, room_viewUncheckedCreateInput>
    /**
     * In case the room_view was found with the provided `where` argument, update it with this data.
     */
    update: XOR<room_viewUpdateInput, room_viewUncheckedUpdateInput>
  }

  /**
   * room_view delete
   */
  export type room_viewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
    /**
     * Filter which room_view to delete.
     */
    where: room_viewWhereUniqueInput
  }

  /**
   * room_view deleteMany
   */
  export type room_viewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room_views to delete
     */
    where?: room_viewWhereInput
    /**
     * Limit how many room_views to delete.
     */
    limit?: number
  }

  /**
   * room_view without action
   */
  export type room_viewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_view
     */
    select?: room_viewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the room_view
     */
    omit?: room_viewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: room_viewInclude<ExtArgs> | null
  }


  /**
   * Model EFMigrationsHistory
   */

  export type AggregateEFMigrationsHistory = {
    _count: EFMigrationsHistoryCountAggregateOutputType | null
    _min: EFMigrationsHistoryMinAggregateOutputType | null
    _max: EFMigrationsHistoryMaxAggregateOutputType | null
  }

  export type EFMigrationsHistoryMinAggregateOutputType = {
    MigrationId: string | null
    ProductVersion: string | null
  }

  export type EFMigrationsHistoryMaxAggregateOutputType = {
    MigrationId: string | null
    ProductVersion: string | null
  }

  export type EFMigrationsHistoryCountAggregateOutputType = {
    MigrationId: number
    ProductVersion: number
    _all: number
  }


  export type EFMigrationsHistoryMinAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
  }

  export type EFMigrationsHistoryMaxAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
  }

  export type EFMigrationsHistoryCountAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
    _all?: true
  }

  export type EFMigrationsHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFMigrationsHistory to aggregate.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EFMigrationsHistories
    **/
    _count?: true | EFMigrationsHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EFMigrationsHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EFMigrationsHistoryMaxAggregateInputType
  }

  export type GetEFMigrationsHistoryAggregateType<T extends EFMigrationsHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEFMigrationsHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEFMigrationsHistory[P]>
      : GetScalarType<T[P], AggregateEFMigrationsHistory[P]>
  }




  export type EFMigrationsHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EFMigrationsHistoryWhereInput
    orderBy?: EFMigrationsHistoryOrderByWithAggregationInput | EFMigrationsHistoryOrderByWithAggregationInput[]
    by: EFMigrationsHistoryScalarFieldEnum[] | EFMigrationsHistoryScalarFieldEnum
    having?: EFMigrationsHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EFMigrationsHistoryCountAggregateInputType | true
    _min?: EFMigrationsHistoryMinAggregateInputType
    _max?: EFMigrationsHistoryMaxAggregateInputType
  }

  export type EFMigrationsHistoryGroupByOutputType = {
    MigrationId: string
    ProductVersion: string
    _count: EFMigrationsHistoryCountAggregateOutputType | null
    _min: EFMigrationsHistoryMinAggregateOutputType | null
    _max: EFMigrationsHistoryMaxAggregateOutputType | null
  }

  type GetEFMigrationsHistoryGroupByPayload<T extends EFMigrationsHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EFMigrationsHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EFMigrationsHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EFMigrationsHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EFMigrationsHistoryGroupByOutputType[P]>
        }
      >
    >


  export type EFMigrationsHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MigrationId?: boolean
    ProductVersion?: boolean
  }, ExtArgs["result"]["eFMigrationsHistory"]>



  export type EFMigrationsHistorySelectScalar = {
    MigrationId?: boolean
    ProductVersion?: boolean
  }

  export type EFMigrationsHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"MigrationId" | "ProductVersion", ExtArgs["result"]["eFMigrationsHistory"]>

  export type $EFMigrationsHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EFMigrationsHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MigrationId: string
      ProductVersion: string
    }, ExtArgs["result"]["eFMigrationsHistory"]>
    composites: {}
  }

  type EFMigrationsHistoryGetPayload<S extends boolean | null | undefined | EFMigrationsHistoryDefaultArgs> = $Result.GetResult<Prisma.$EFMigrationsHistoryPayload, S>

  type EFMigrationsHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EFMigrationsHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EFMigrationsHistoryCountAggregateInputType | true
    }

  export interface EFMigrationsHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EFMigrationsHistory'], meta: { name: 'EFMigrationsHistory' } }
    /**
     * Find zero or one EFMigrationsHistory that matches the filter.
     * @param {EFMigrationsHistoryFindUniqueArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFMigrationsHistoryFindUniqueArgs>(args: SelectSubset<T, EFMigrationsHistoryFindUniqueArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EFMigrationsHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EFMigrationsHistoryFindUniqueOrThrowArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFMigrationsHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFMigrationsHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindFirstArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFMigrationsHistoryFindFirstArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindFirstArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFMigrationsHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindFirstOrThrowArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFMigrationsHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EFMigrationsHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EFMigrationsHistories
     * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
     * 
     * // Get first 10 EFMigrationsHistories
     * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany({ take: 10 })
     * 
     * // Only select the `MigrationId`
     * const eFMigrationsHistoryWithMigrationIdOnly = await prisma.eFMigrationsHistory.findMany({ select: { MigrationId: true } })
     * 
     */
    findMany<T extends EFMigrationsHistoryFindManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EFMigrationsHistory.
     * @param {EFMigrationsHistoryCreateArgs} args - Arguments to create a EFMigrationsHistory.
     * @example
     * // Create one EFMigrationsHistory
     * const EFMigrationsHistory = await prisma.eFMigrationsHistory.create({
     *   data: {
     *     // ... data to create a EFMigrationsHistory
     *   }
     * })
     * 
     */
    create<T extends EFMigrationsHistoryCreateArgs>(args: SelectSubset<T, EFMigrationsHistoryCreateArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EFMigrationsHistories.
     * @param {EFMigrationsHistoryCreateManyArgs} args - Arguments to create many EFMigrationsHistories.
     * @example
     * // Create many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EFMigrationsHistoryCreateManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EFMigrationsHistory.
     * @param {EFMigrationsHistoryDeleteArgs} args - Arguments to delete one EFMigrationsHistory.
     * @example
     * // Delete one EFMigrationsHistory
     * const EFMigrationsHistory = await prisma.eFMigrationsHistory.delete({
     *   where: {
     *     // ... filter to delete one EFMigrationsHistory
     *   }
     * })
     * 
     */
    delete<T extends EFMigrationsHistoryDeleteArgs>(args: SelectSubset<T, EFMigrationsHistoryDeleteArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EFMigrationsHistory.
     * @param {EFMigrationsHistoryUpdateArgs} args - Arguments to update one EFMigrationsHistory.
     * @example
     * // Update one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EFMigrationsHistoryUpdateArgs>(args: SelectSubset<T, EFMigrationsHistoryUpdateArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EFMigrationsHistories.
     * @param {EFMigrationsHistoryDeleteManyArgs} args - Arguments to filter EFMigrationsHistories to delete.
     * @example
     * // Delete a few EFMigrationsHistories
     * const { count } = await prisma.eFMigrationsHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EFMigrationsHistoryDeleteManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EFMigrationsHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EFMigrationsHistoryUpdateManyArgs>(args: SelectSubset<T, EFMigrationsHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EFMigrationsHistory.
     * @param {EFMigrationsHistoryUpsertArgs} args - Arguments to update or create a EFMigrationsHistory.
     * @example
     * // Update or create a EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.upsert({
     *   create: {
     *     // ... data to create a EFMigrationsHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EFMigrationsHistory we want to update
     *   }
     * })
     */
    upsert<T extends EFMigrationsHistoryUpsertArgs>(args: SelectSubset<T, EFMigrationsHistoryUpsertArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EFMigrationsHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryCountArgs} args - Arguments to filter EFMigrationsHistories to count.
     * @example
     * // Count the number of EFMigrationsHistories
     * const count = await prisma.eFMigrationsHistory.count({
     *   where: {
     *     // ... the filter for the EFMigrationsHistories we want to count
     *   }
     * })
    **/
    count<T extends EFMigrationsHistoryCountArgs>(
      args?: Subset<T, EFMigrationsHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EFMigrationsHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EFMigrationsHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EFMigrationsHistoryAggregateArgs>(args: Subset<T, EFMigrationsHistoryAggregateArgs>): Prisma.PrismaPromise<GetEFMigrationsHistoryAggregateType<T>>

    /**
     * Group by EFMigrationsHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EFMigrationsHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EFMigrationsHistoryGroupByArgs['orderBy'] }
        : { orderBy?: EFMigrationsHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EFMigrationsHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEFMigrationsHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EFMigrationsHistory model
   */
  readonly fields: EFMigrationsHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EFMigrationsHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EFMigrationsHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EFMigrationsHistory model
   */
  interface EFMigrationsHistoryFieldRefs {
    readonly MigrationId: FieldRef<"EFMigrationsHistory", 'String'>
    readonly ProductVersion: FieldRef<"EFMigrationsHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EFMigrationsHistory findUnique
   */
  export type EFMigrationsHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory findUniqueOrThrow
   */
  export type EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory findFirst
   */
  export type EFMigrationsHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFMigrationsHistories.
     */
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory findFirstOrThrow
   */
  export type EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFMigrationsHistories.
     */
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory findMany
   */
  export type EFMigrationsHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistories to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory create
   */
  export type EFMigrationsHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a EFMigrationsHistory.
     */
    data: XOR<EFMigrationsHistoryCreateInput, EFMigrationsHistoryUncheckedCreateInput>
  }

  /**
   * EFMigrationsHistory createMany
   */
  export type EFMigrationsHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EFMigrationsHistories.
     */
    data: EFMigrationsHistoryCreateManyInput | EFMigrationsHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EFMigrationsHistory update
   */
  export type EFMigrationsHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a EFMigrationsHistory.
     */
    data: XOR<EFMigrationsHistoryUpdateInput, EFMigrationsHistoryUncheckedUpdateInput>
    /**
     * Choose, which EFMigrationsHistory to update.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory updateMany
   */
  export type EFMigrationsHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EFMigrationsHistories.
     */
    data: XOR<EFMigrationsHistoryUpdateManyMutationInput, EFMigrationsHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EFMigrationsHistories to update
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * Limit how many EFMigrationsHistories to update.
     */
    limit?: number
  }

  /**
   * EFMigrationsHistory upsert
   */
  export type EFMigrationsHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the EFMigrationsHistory to update in case it exists.
     */
    where: EFMigrationsHistoryWhereUniqueInput
    /**
     * In case the EFMigrationsHistory found by the `where` argument doesn't exist, create a new EFMigrationsHistory with this data.
     */
    create: XOR<EFMigrationsHistoryCreateInput, EFMigrationsHistoryUncheckedCreateInput>
    /**
     * In case the EFMigrationsHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EFMigrationsHistoryUpdateInput, EFMigrationsHistoryUncheckedUpdateInput>
  }

  /**
   * EFMigrationsHistory delete
   */
  export type EFMigrationsHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter which EFMigrationsHistory to delete.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory deleteMany
   */
  export type EFMigrationsHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFMigrationsHistories to delete
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * Limit how many EFMigrationsHistories to delete.
     */
    limit?: number
  }

  /**
   * EFMigrationsHistory without action
   */
  export type EFMigrationsHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
  }


  /**
   * Model edition
   */

  export type AggregateEdition = {
    _count: EditionCountAggregateOutputType | null
    _min: EditionMinAggregateOutputType | null
    _max: EditionMaxAggregateOutputType | null
  }

  export type EditionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type EditionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type EditionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type EditionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EditionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EditionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type EditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edition to aggregate.
     */
    where?: editionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of editions to fetch.
     */
    orderBy?: editionOrderByWithRelationInput | editionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: editionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` editions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned editions
    **/
    _count?: true | EditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EditionMaxAggregateInputType
  }

  export type GetEditionAggregateType<T extends EditionAggregateArgs> = {
        [P in keyof T & keyof AggregateEdition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdition[P]>
      : GetScalarType<T[P], AggregateEdition[P]>
  }




  export type editionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: editionWhereInput
    orderBy?: editionOrderByWithAggregationInput | editionOrderByWithAggregationInput[]
    by: EditionScalarFieldEnum[] | EditionScalarFieldEnum
    having?: editionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EditionCountAggregateInputType | true
    _min?: EditionMinAggregateInputType
    _max?: EditionMaxAggregateInputType
  }

  export type EditionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string
    _count: EditionCountAggregateOutputType | null
    _min: EditionMinAggregateOutputType | null
    _max: EditionMaxAggregateOutputType | null
  }

  type GetEditionGroupByPayload<T extends editionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EditionGroupByOutputType[P]>
            : GetScalarType<T[P], EditionGroupByOutputType[P]>
        }
      >
    >


  export type editionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
    rooms?: boolean | edition$roomsArgs<ExtArgs>
    _count?: boolean | EditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edition"]>



  export type editionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type editionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["edition"]>
  export type editionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | userDefaultArgs<ExtArgs>
    updater?: boolean | userDefaultArgs<ExtArgs>
    rooms?: boolean | edition$roomsArgs<ExtArgs>
    _count?: boolean | EditionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $editionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "edition"
    objects: {
      creator: Prisma.$userPayload<ExtArgs>
      updater: Prisma.$userPayload<ExtArgs>
      rooms: Prisma.$edition_roomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string
    }, ExtArgs["result"]["edition"]>
    composites: {}
  }

  type editionGetPayload<S extends boolean | null | undefined | editionDefaultArgs> = $Result.GetResult<Prisma.$editionPayload, S>

  type editionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<editionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EditionCountAggregateInputType | true
    }

  export interface editionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edition'], meta: { name: 'edition' } }
    /**
     * Find zero or one Edition that matches the filter.
     * @param {editionFindUniqueArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends editionFindUniqueArgs>(args: SelectSubset<T, editionFindUniqueArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Edition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {editionFindUniqueOrThrowArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends editionFindUniqueOrThrowArgs>(args: SelectSubset<T, editionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {editionFindFirstArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends editionFindFirstArgs>(args?: SelectSubset<T, editionFindFirstArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {editionFindFirstOrThrowArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends editionFindFirstOrThrowArgs>(args?: SelectSubset<T, editionFindFirstOrThrowArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Editions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {editionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Editions
     * const editions = await prisma.edition.findMany()
     * 
     * // Get first 10 Editions
     * const editions = await prisma.edition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const editionWithIdOnly = await prisma.edition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends editionFindManyArgs>(args?: SelectSubset<T, editionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Edition.
     * @param {editionCreateArgs} args - Arguments to create a Edition.
     * @example
     * // Create one Edition
     * const Edition = await prisma.edition.create({
     *   data: {
     *     // ... data to create a Edition
     *   }
     * })
     * 
     */
    create<T extends editionCreateArgs>(args: SelectSubset<T, editionCreateArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Editions.
     * @param {editionCreateManyArgs} args - Arguments to create many Editions.
     * @example
     * // Create many Editions
     * const edition = await prisma.edition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends editionCreateManyArgs>(args?: SelectSubset<T, editionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Edition.
     * @param {editionDeleteArgs} args - Arguments to delete one Edition.
     * @example
     * // Delete one Edition
     * const Edition = await prisma.edition.delete({
     *   where: {
     *     // ... filter to delete one Edition
     *   }
     * })
     * 
     */
    delete<T extends editionDeleteArgs>(args: SelectSubset<T, editionDeleteArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Edition.
     * @param {editionUpdateArgs} args - Arguments to update one Edition.
     * @example
     * // Update one Edition
     * const edition = await prisma.edition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends editionUpdateArgs>(args: SelectSubset<T, editionUpdateArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Editions.
     * @param {editionDeleteManyArgs} args - Arguments to filter Editions to delete.
     * @example
     * // Delete a few Editions
     * const { count } = await prisma.edition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends editionDeleteManyArgs>(args?: SelectSubset<T, editionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Editions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {editionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Editions
     * const edition = await prisma.edition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends editionUpdateManyArgs>(args: SelectSubset<T, editionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Edition.
     * @param {editionUpsertArgs} args - Arguments to update or create a Edition.
     * @example
     * // Update or create a Edition
     * const edition = await prisma.edition.upsert({
     *   create: {
     *     // ... data to create a Edition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Edition we want to update
     *   }
     * })
     */
    upsert<T extends editionUpsertArgs>(args: SelectSubset<T, editionUpsertArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Editions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {editionCountArgs} args - Arguments to filter Editions to count.
     * @example
     * // Count the number of Editions
     * const count = await prisma.edition.count({
     *   where: {
     *     // ... the filter for the Editions we want to count
     *   }
     * })
    **/
    count<T extends editionCountArgs>(
      args?: Subset<T, editionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Edition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EditionAggregateArgs>(args: Subset<T, EditionAggregateArgs>): Prisma.PrismaPromise<GetEditionAggregateType<T>>

    /**
     * Group by Edition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {editionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends editionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: editionGroupByArgs['orderBy'] }
        : { orderBy?: editionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, editionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edition model
   */
  readonly fields: editionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__editionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updater<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rooms<T extends edition$roomsArgs<ExtArgs> = {}>(args?: Subset<T, edition$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the edition model
   */
  interface editionFieldRefs {
    readonly id: FieldRef<"edition", 'String'>
    readonly name: FieldRef<"edition", 'String'>
    readonly description: FieldRef<"edition", 'String'>
    readonly startDate: FieldRef<"edition", 'DateTime'>
    readonly endDate: FieldRef<"edition", 'DateTime'>
    readonly createdAt: FieldRef<"edition", 'DateTime'>
    readonly updatedAt: FieldRef<"edition", 'DateTime'>
    readonly createdBy: FieldRef<"edition", 'String'>
    readonly updatedBy: FieldRef<"edition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * edition findUnique
   */
  export type editionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * Filter, which edition to fetch.
     */
    where: editionWhereUniqueInput
  }

  /**
   * edition findUniqueOrThrow
   */
  export type editionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * Filter, which edition to fetch.
     */
    where: editionWhereUniqueInput
  }

  /**
   * edition findFirst
   */
  export type editionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * Filter, which edition to fetch.
     */
    where?: editionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of editions to fetch.
     */
    orderBy?: editionOrderByWithRelationInput | editionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for editions.
     */
    cursor?: editionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` editions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of editions.
     */
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * edition findFirstOrThrow
   */
  export type editionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * Filter, which edition to fetch.
     */
    where?: editionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of editions to fetch.
     */
    orderBy?: editionOrderByWithRelationInput | editionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for editions.
     */
    cursor?: editionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` editions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of editions.
     */
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * edition findMany
   */
  export type editionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * Filter, which editions to fetch.
     */
    where?: editionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of editions to fetch.
     */
    orderBy?: editionOrderByWithRelationInput | editionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing editions.
     */
    cursor?: editionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` editions.
     */
    skip?: number
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * edition create
   */
  export type editionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * The data needed to create a edition.
     */
    data: XOR<editionCreateInput, editionUncheckedCreateInput>
  }

  /**
   * edition createMany
   */
  export type editionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many editions.
     */
    data: editionCreateManyInput | editionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * edition update
   */
  export type editionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * The data needed to update a edition.
     */
    data: XOR<editionUpdateInput, editionUncheckedUpdateInput>
    /**
     * Choose, which edition to update.
     */
    where: editionWhereUniqueInput
  }

  /**
   * edition updateMany
   */
  export type editionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update editions.
     */
    data: XOR<editionUpdateManyMutationInput, editionUncheckedUpdateManyInput>
    /**
     * Filter which editions to update
     */
    where?: editionWhereInput
    /**
     * Limit how many editions to update.
     */
    limit?: number
  }

  /**
   * edition upsert
   */
  export type editionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * The filter to search for the edition to update in case it exists.
     */
    where: editionWhereUniqueInput
    /**
     * In case the edition found by the `where` argument doesn't exist, create a new edition with this data.
     */
    create: XOR<editionCreateInput, editionUncheckedCreateInput>
    /**
     * In case the edition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<editionUpdateInput, editionUncheckedUpdateInput>
  }

  /**
   * edition delete
   */
  export type editionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
    /**
     * Filter which edition to delete.
     */
    where: editionWhereUniqueInput
  }

  /**
   * edition deleteMany
   */
  export type editionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which editions to delete
     */
    where?: editionWhereInput
    /**
     * Limit how many editions to delete.
     */
    limit?: number
  }

  /**
   * edition.rooms
   */
  export type edition$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    where?: edition_roomWhereInput
    orderBy?: edition_roomOrderByWithRelationInput | edition_roomOrderByWithRelationInput[]
    cursor?: edition_roomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Edition_roomScalarFieldEnum | Edition_roomScalarFieldEnum[]
  }

  /**
   * edition without action
   */
  export type editionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition
     */
    select?: editionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition
     */
    omit?: editionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: editionInclude<ExtArgs> | null
  }


  /**
   * Model edition_room
   */

  export type AggregateEdition_room = {
    _count: Edition_roomCountAggregateOutputType | null
    _min: Edition_roomMinAggregateOutputType | null
    _max: Edition_roomMaxAggregateOutputType | null
  }

  export type Edition_roomMinAggregateOutputType = {
    id: string | null
    editionId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Edition_roomMaxAggregateOutputType = {
    id: string | null
    editionId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Edition_roomCountAggregateOutputType = {
    id: number
    editionId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Edition_roomMinAggregateInputType = {
    id?: true
    editionId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Edition_roomMaxAggregateInputType = {
    id?: true
    editionId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Edition_roomCountAggregateInputType = {
    id?: true
    editionId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Edition_roomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edition_room to aggregate.
     */
    where?: edition_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edition_rooms to fetch.
     */
    orderBy?: edition_roomOrderByWithRelationInput | edition_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edition_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edition_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edition_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edition_rooms
    **/
    _count?: true | Edition_roomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Edition_roomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Edition_roomMaxAggregateInputType
  }

  export type GetEdition_roomAggregateType<T extends Edition_roomAggregateArgs> = {
        [P in keyof T & keyof AggregateEdition_room]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdition_room[P]>
      : GetScalarType<T[P], AggregateEdition_room[P]>
  }




  export type edition_roomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edition_roomWhereInput
    orderBy?: edition_roomOrderByWithAggregationInput | edition_roomOrderByWithAggregationInput[]
    by: Edition_roomScalarFieldEnum[] | Edition_roomScalarFieldEnum
    having?: edition_roomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Edition_roomCountAggregateInputType | true
    _min?: Edition_roomMinAggregateInputType
    _max?: Edition_roomMaxAggregateInputType
  }

  export type Edition_roomGroupByOutputType = {
    id: string
    editionId: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: Edition_roomCountAggregateOutputType | null
    _min: Edition_roomMinAggregateOutputType | null
    _max: Edition_roomMaxAggregateOutputType | null
  }

  type GetEdition_roomGroupByPayload<T extends edition_roomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Edition_roomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Edition_roomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Edition_roomGroupByOutputType[P]>
            : GetScalarType<T[P], Edition_roomGroupByOutputType[P]>
        }
      >
    >


  export type edition_roomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    editionId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    edition?: boolean | editionDefaultArgs<ExtArgs>
    tables?: boolean | edition_room$tablesArgs<ExtArgs>
    _count?: boolean | Edition_roomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edition_room"]>



  export type edition_roomSelectScalar = {
    id?: boolean
    editionId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type edition_roomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "editionId" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["edition_room"]>
  export type edition_roomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edition?: boolean | editionDefaultArgs<ExtArgs>
    tables?: boolean | edition_room$tablesArgs<ExtArgs>
    _count?: boolean | Edition_roomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $edition_roomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "edition_room"
    objects: {
      edition: Prisma.$editionPayload<ExtArgs>
      tables: Prisma.$tablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      editionId: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["edition_room"]>
    composites: {}
  }

  type edition_roomGetPayload<S extends boolean | null | undefined | edition_roomDefaultArgs> = $Result.GetResult<Prisma.$edition_roomPayload, S>

  type edition_roomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<edition_roomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Edition_roomCountAggregateInputType | true
    }

  export interface edition_roomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edition_room'], meta: { name: 'edition_room' } }
    /**
     * Find zero or one Edition_room that matches the filter.
     * @param {edition_roomFindUniqueArgs} args - Arguments to find a Edition_room
     * @example
     * // Get one Edition_room
     * const edition_room = await prisma.edition_room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends edition_roomFindUniqueArgs>(args: SelectSubset<T, edition_roomFindUniqueArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Edition_room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {edition_roomFindUniqueOrThrowArgs} args - Arguments to find a Edition_room
     * @example
     * // Get one Edition_room
     * const edition_room = await prisma.edition_room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends edition_roomFindUniqueOrThrowArgs>(args: SelectSubset<T, edition_roomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edition_room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edition_roomFindFirstArgs} args - Arguments to find a Edition_room
     * @example
     * // Get one Edition_room
     * const edition_room = await prisma.edition_room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends edition_roomFindFirstArgs>(args?: SelectSubset<T, edition_roomFindFirstArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edition_room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edition_roomFindFirstOrThrowArgs} args - Arguments to find a Edition_room
     * @example
     * // Get one Edition_room
     * const edition_room = await prisma.edition_room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends edition_roomFindFirstOrThrowArgs>(args?: SelectSubset<T, edition_roomFindFirstOrThrowArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Edition_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edition_roomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Edition_rooms
     * const edition_rooms = await prisma.edition_room.findMany()
     * 
     * // Get first 10 Edition_rooms
     * const edition_rooms = await prisma.edition_room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edition_roomWithIdOnly = await prisma.edition_room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends edition_roomFindManyArgs>(args?: SelectSubset<T, edition_roomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Edition_room.
     * @param {edition_roomCreateArgs} args - Arguments to create a Edition_room.
     * @example
     * // Create one Edition_room
     * const Edition_room = await prisma.edition_room.create({
     *   data: {
     *     // ... data to create a Edition_room
     *   }
     * })
     * 
     */
    create<T extends edition_roomCreateArgs>(args: SelectSubset<T, edition_roomCreateArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Edition_rooms.
     * @param {edition_roomCreateManyArgs} args - Arguments to create many Edition_rooms.
     * @example
     * // Create many Edition_rooms
     * const edition_room = await prisma.edition_room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends edition_roomCreateManyArgs>(args?: SelectSubset<T, edition_roomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Edition_room.
     * @param {edition_roomDeleteArgs} args - Arguments to delete one Edition_room.
     * @example
     * // Delete one Edition_room
     * const Edition_room = await prisma.edition_room.delete({
     *   where: {
     *     // ... filter to delete one Edition_room
     *   }
     * })
     * 
     */
    delete<T extends edition_roomDeleteArgs>(args: SelectSubset<T, edition_roomDeleteArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Edition_room.
     * @param {edition_roomUpdateArgs} args - Arguments to update one Edition_room.
     * @example
     * // Update one Edition_room
     * const edition_room = await prisma.edition_room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends edition_roomUpdateArgs>(args: SelectSubset<T, edition_roomUpdateArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Edition_rooms.
     * @param {edition_roomDeleteManyArgs} args - Arguments to filter Edition_rooms to delete.
     * @example
     * // Delete a few Edition_rooms
     * const { count } = await prisma.edition_room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends edition_roomDeleteManyArgs>(args?: SelectSubset<T, edition_roomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Edition_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edition_roomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Edition_rooms
     * const edition_room = await prisma.edition_room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends edition_roomUpdateManyArgs>(args: SelectSubset<T, edition_roomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Edition_room.
     * @param {edition_roomUpsertArgs} args - Arguments to update or create a Edition_room.
     * @example
     * // Update or create a Edition_room
     * const edition_room = await prisma.edition_room.upsert({
     *   create: {
     *     // ... data to create a Edition_room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Edition_room we want to update
     *   }
     * })
     */
    upsert<T extends edition_roomUpsertArgs>(args: SelectSubset<T, edition_roomUpsertArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Edition_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edition_roomCountArgs} args - Arguments to filter Edition_rooms to count.
     * @example
     * // Count the number of Edition_rooms
     * const count = await prisma.edition_room.count({
     *   where: {
     *     // ... the filter for the Edition_rooms we want to count
     *   }
     * })
    **/
    count<T extends edition_roomCountArgs>(
      args?: Subset<T, edition_roomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Edition_roomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Edition_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Edition_roomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Edition_roomAggregateArgs>(args: Subset<T, Edition_roomAggregateArgs>): Prisma.PrismaPromise<GetEdition_roomAggregateType<T>>

    /**
     * Group by Edition_room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edition_roomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edition_roomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edition_roomGroupByArgs['orderBy'] }
        : { orderBy?: edition_roomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edition_roomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdition_roomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edition_room model
   */
  readonly fields: edition_roomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edition_room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edition_roomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edition<T extends editionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, editionDefaultArgs<ExtArgs>>): Prisma__editionClient<$Result.GetResult<Prisma.$editionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tables<T extends edition_room$tablesArgs<ExtArgs> = {}>(args?: Subset<T, edition_room$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the edition_room model
   */
  interface edition_roomFieldRefs {
    readonly id: FieldRef<"edition_room", 'String'>
    readonly editionId: FieldRef<"edition_room", 'String'>
    readonly name: FieldRef<"edition_room", 'String'>
    readonly createdAt: FieldRef<"edition_room", 'DateTime'>
    readonly updatedAt: FieldRef<"edition_room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * edition_room findUnique
   */
  export type edition_roomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * Filter, which edition_room to fetch.
     */
    where: edition_roomWhereUniqueInput
  }

  /**
   * edition_room findUniqueOrThrow
   */
  export type edition_roomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * Filter, which edition_room to fetch.
     */
    where: edition_roomWhereUniqueInput
  }

  /**
   * edition_room findFirst
   */
  export type edition_roomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * Filter, which edition_room to fetch.
     */
    where?: edition_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edition_rooms to fetch.
     */
    orderBy?: edition_roomOrderByWithRelationInput | edition_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edition_rooms.
     */
    cursor?: edition_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edition_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edition_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edition_rooms.
     */
    distinct?: Edition_roomScalarFieldEnum | Edition_roomScalarFieldEnum[]
  }

  /**
   * edition_room findFirstOrThrow
   */
  export type edition_roomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * Filter, which edition_room to fetch.
     */
    where?: edition_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edition_rooms to fetch.
     */
    orderBy?: edition_roomOrderByWithRelationInput | edition_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edition_rooms.
     */
    cursor?: edition_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edition_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edition_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edition_rooms.
     */
    distinct?: Edition_roomScalarFieldEnum | Edition_roomScalarFieldEnum[]
  }

  /**
   * edition_room findMany
   */
  export type edition_roomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * Filter, which edition_rooms to fetch.
     */
    where?: edition_roomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edition_rooms to fetch.
     */
    orderBy?: edition_roomOrderByWithRelationInput | edition_roomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edition_rooms.
     */
    cursor?: edition_roomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edition_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edition_rooms.
     */
    skip?: number
    distinct?: Edition_roomScalarFieldEnum | Edition_roomScalarFieldEnum[]
  }

  /**
   * edition_room create
   */
  export type edition_roomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * The data needed to create a edition_room.
     */
    data: XOR<edition_roomCreateInput, edition_roomUncheckedCreateInput>
  }

  /**
   * edition_room createMany
   */
  export type edition_roomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edition_rooms.
     */
    data: edition_roomCreateManyInput | edition_roomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * edition_room update
   */
  export type edition_roomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * The data needed to update a edition_room.
     */
    data: XOR<edition_roomUpdateInput, edition_roomUncheckedUpdateInput>
    /**
     * Choose, which edition_room to update.
     */
    where: edition_roomWhereUniqueInput
  }

  /**
   * edition_room updateMany
   */
  export type edition_roomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edition_rooms.
     */
    data: XOR<edition_roomUpdateManyMutationInput, edition_roomUncheckedUpdateManyInput>
    /**
     * Filter which edition_rooms to update
     */
    where?: edition_roomWhereInput
    /**
     * Limit how many edition_rooms to update.
     */
    limit?: number
  }

  /**
   * edition_room upsert
   */
  export type edition_roomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * The filter to search for the edition_room to update in case it exists.
     */
    where: edition_roomWhereUniqueInput
    /**
     * In case the edition_room found by the `where` argument doesn't exist, create a new edition_room with this data.
     */
    create: XOR<edition_roomCreateInput, edition_roomUncheckedCreateInput>
    /**
     * In case the edition_room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edition_roomUpdateInput, edition_roomUncheckedUpdateInput>
  }

  /**
   * edition_room delete
   */
  export type edition_roomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
    /**
     * Filter which edition_room to delete.
     */
    where: edition_roomWhereUniqueInput
  }

  /**
   * edition_room deleteMany
   */
  export type edition_roomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edition_rooms to delete
     */
    where?: edition_roomWhereInput
    /**
     * Limit how many edition_rooms to delete.
     */
    limit?: number
  }

  /**
   * edition_room.tables
   */
  export type edition_room$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    where?: tableWhereInput
    orderBy?: tableOrderByWithRelationInput | tableOrderByWithRelationInput[]
    cursor?: tableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * edition_room without action
   */
  export type edition_roomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edition_room
     */
    select?: edition_roomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edition_room
     */
    omit?: edition_roomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edition_roomInclude<ExtArgs> | null
  }


  /**
   * Model table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    positionX: number | null
    positionY: number | null
    width: number | null
    height: number | null
    capacity: number | null
  }

  export type TableSumAggregateOutputType = {
    positionX: number | null
    positionY: number | null
    width: number | null
    height: number | null
    capacity: number | null
  }

  export type TableMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    name: string | null
    positionX: number | null
    positionY: number | null
    width: number | null
    height: number | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    name: string | null
    positionX: number | null
    positionY: number | null
    width: number | null
    height: number | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    roomId: number
    name: number
    positionX: number
    positionY: number
    width: number
    height: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    positionX?: true
    positionY?: true
    width?: true
    height?: true
    capacity?: true
  }

  export type TableSumAggregateInputType = {
    positionX?: true
    positionY?: true
    width?: true
    height?: true
    capacity?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    roomId?: true
    name?: true
    positionX?: true
    positionY?: true
    width?: true
    height?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    roomId?: true
    name?: true
    positionX?: true
    positionY?: true
    width?: true
    height?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    roomId?: true
    name?: true
    positionX?: true
    positionY?: true
    width?: true
    height?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table to aggregate.
     */
    where?: tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tableOrderByWithRelationInput | tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type tableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tableWhereInput
    orderBy?: tableOrderByWithAggregationInput | tableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: tableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: string
    roomId: string
    name: string
    positionX: number
    positionY: number
    width: number
    height: number
    capacity: number
    createdAt: Date
    updatedAt: Date
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends tableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type tableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    name?: boolean
    positionX?: boolean
    positionY?: boolean
    width?: boolean
    height?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | edition_roomDefaultArgs<ExtArgs>
    seats?: boolean | table$seatsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>



  export type tableSelectScalar = {
    id?: boolean
    roomId?: boolean
    name?: boolean
    positionX?: boolean
    positionY?: boolean
    width?: boolean
    height?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "name" | "positionX" | "positionY" | "width" | "height" | "capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["table"]>
  export type tableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | edition_roomDefaultArgs<ExtArgs>
    seats?: boolean | table$seatsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "table"
    objects: {
      room: Prisma.$edition_roomPayload<ExtArgs>
      seats: Prisma.$table_seatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      name: string
      /**
       * Grid position X
       */
      positionX: number
      /**
       * Grid position Y
       */
      positionY: number
      /**
       * Width in grid units
       */
      width: number
      /**
       * Height in grid units
       */
      height: number
      /**
       * Number of seats
       */
      capacity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type tableGetPayload<S extends boolean | null | undefined | tableDefaultArgs> = $Result.GetResult<Prisma.$tablePayload, S>

  type tableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface tableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['table'], meta: { name: 'table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {tableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tableFindUniqueArgs>(args: SelectSubset<T, tableFindUniqueArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tableFindUniqueOrThrowArgs>(args: SelectSubset<T, tableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tableFindFirstArgs>(args?: SelectSubset<T, tableFindFirstArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tableFindFirstOrThrowArgs>(args?: SelectSubset<T, tableFindFirstOrThrowArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tableFindManyArgs>(args?: SelectSubset<T, tableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table.
     * @param {tableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends tableCreateArgs>(args: SelectSubset<T, tableCreateArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tables.
     * @param {tableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tableCreateManyArgs>(args?: SelectSubset<T, tableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Table.
     * @param {tableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends tableDeleteArgs>(args: SelectSubset<T, tableDeleteArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table.
     * @param {tableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tableUpdateArgs>(args: SelectSubset<T, tableUpdateArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tables.
     * @param {tableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tableDeleteManyArgs>(args?: SelectSubset<T, tableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tableUpdateManyArgs>(args: SelectSubset<T, tableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {tableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends tableUpsertArgs>(args: SelectSubset<T, tableUpsertArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends tableCountArgs>(
      args?: Subset<T, tableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tableGroupByArgs['orderBy'] }
        : { orderBy?: tableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the table model
   */
  readonly fields: tableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends edition_roomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edition_roomDefaultArgs<ExtArgs>>): Prisma__edition_roomClient<$Result.GetResult<Prisma.$edition_roomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seats<T extends table$seatsArgs<ExtArgs> = {}>(args?: Subset<T, table$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the table model
   */
  interface tableFieldRefs {
    readonly id: FieldRef<"table", 'String'>
    readonly roomId: FieldRef<"table", 'String'>
    readonly name: FieldRef<"table", 'String'>
    readonly positionX: FieldRef<"table", 'Int'>
    readonly positionY: FieldRef<"table", 'Int'>
    readonly width: FieldRef<"table", 'Int'>
    readonly height: FieldRef<"table", 'Int'>
    readonly capacity: FieldRef<"table", 'Int'>
    readonly createdAt: FieldRef<"table", 'DateTime'>
    readonly updatedAt: FieldRef<"table", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * table findUnique
   */
  export type tableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * Filter, which table to fetch.
     */
    where: tableWhereUniqueInput
  }

  /**
   * table findUniqueOrThrow
   */
  export type tableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * Filter, which table to fetch.
     */
    where: tableWhereUniqueInput
  }

  /**
   * table findFirst
   */
  export type tableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * Filter, which table to fetch.
     */
    where?: tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tableOrderByWithRelationInput | tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables.
     */
    cursor?: tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * table findFirstOrThrow
   */
  export type tableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * Filter, which table to fetch.
     */
    where?: tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tableOrderByWithRelationInput | tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tables.
     */
    cursor?: tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * table findMany
   */
  export type tableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * Filter, which tables to fetch.
     */
    where?: tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tables to fetch.
     */
    orderBy?: tableOrderByWithRelationInput | tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tables.
     */
    cursor?: tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * table create
   */
  export type tableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * The data needed to create a table.
     */
    data: XOR<tableCreateInput, tableUncheckedCreateInput>
  }

  /**
   * table createMany
   */
  export type tableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tables.
     */
    data: tableCreateManyInput | tableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * table update
   */
  export type tableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * The data needed to update a table.
     */
    data: XOR<tableUpdateInput, tableUncheckedUpdateInput>
    /**
     * Choose, which table to update.
     */
    where: tableWhereUniqueInput
  }

  /**
   * table updateMany
   */
  export type tableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tables.
     */
    data: XOR<tableUpdateManyMutationInput, tableUncheckedUpdateManyInput>
    /**
     * Filter which tables to update
     */
    where?: tableWhereInput
    /**
     * Limit how many tables to update.
     */
    limit?: number
  }

  /**
   * table upsert
   */
  export type tableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * The filter to search for the table to update in case it exists.
     */
    where: tableWhereUniqueInput
    /**
     * In case the table found by the `where` argument doesn't exist, create a new table with this data.
     */
    create: XOR<tableCreateInput, tableUncheckedCreateInput>
    /**
     * In case the table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tableUpdateInput, tableUncheckedUpdateInput>
  }

  /**
   * table delete
   */
  export type tableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
    /**
     * Filter which table to delete.
     */
    where: tableWhereUniqueInput
  }

  /**
   * table deleteMany
   */
  export type tableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tables to delete
     */
    where?: tableWhereInput
    /**
     * Limit how many tables to delete.
     */
    limit?: number
  }

  /**
   * table.seats
   */
  export type table$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    where?: table_seatWhereInput
    orderBy?: table_seatOrderByWithRelationInput | table_seatOrderByWithRelationInput[]
    cursor?: table_seatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Table_seatScalarFieldEnum | Table_seatScalarFieldEnum[]
  }

  /**
   * table without action
   */
  export type tableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table
     */
    select?: tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table
     */
    omit?: tableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tableInclude<ExtArgs> | null
  }


  /**
   * Model table_seat
   */

  export type AggregateTable_seat = {
    _count: Table_seatCountAggregateOutputType | null
    _avg: Table_seatAvgAggregateOutputType | null
    _sum: Table_seatSumAggregateOutputType | null
    _min: Table_seatMinAggregateOutputType | null
    _max: Table_seatMaxAggregateOutputType | null
  }

  export type Table_seatAvgAggregateOutputType = {
    seatIndex: number | null
  }

  export type Table_seatSumAggregateOutputType = {
    seatIndex: number | null
  }

  export type Table_seatMinAggregateOutputType = {
    id: string | null
    tableId: string | null
    seatIndex: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Table_seatMaxAggregateOutputType = {
    id: string | null
    tableId: string | null
    seatIndex: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Table_seatCountAggregateOutputType = {
    id: number
    tableId: number
    seatIndex: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Table_seatAvgAggregateInputType = {
    seatIndex?: true
  }

  export type Table_seatSumAggregateInputType = {
    seatIndex?: true
  }

  export type Table_seatMinAggregateInputType = {
    id?: true
    tableId?: true
    seatIndex?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Table_seatMaxAggregateInputType = {
    id?: true
    tableId?: true
    seatIndex?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Table_seatCountAggregateInputType = {
    id?: true
    tableId?: true
    seatIndex?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Table_seatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table_seat to aggregate.
     */
    where?: table_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_seats to fetch.
     */
    orderBy?: table_seatOrderByWithRelationInput | table_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: table_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned table_seats
    **/
    _count?: true | Table_seatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Table_seatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Table_seatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Table_seatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Table_seatMaxAggregateInputType
  }

  export type GetTable_seatAggregateType<T extends Table_seatAggregateArgs> = {
        [P in keyof T & keyof AggregateTable_seat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable_seat[P]>
      : GetScalarType<T[P], AggregateTable_seat[P]>
  }




  export type table_seatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: table_seatWhereInput
    orderBy?: table_seatOrderByWithAggregationInput | table_seatOrderByWithAggregationInput[]
    by: Table_seatScalarFieldEnum[] | Table_seatScalarFieldEnum
    having?: table_seatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Table_seatCountAggregateInputType | true
    _avg?: Table_seatAvgAggregateInputType
    _sum?: Table_seatSumAggregateInputType
    _min?: Table_seatMinAggregateInputType
    _max?: Table_seatMaxAggregateInputType
  }

  export type Table_seatGroupByOutputType = {
    id: string
    tableId: string
    seatIndex: number
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: Table_seatCountAggregateOutputType | null
    _avg: Table_seatAvgAggregateOutputType | null
    _sum: Table_seatSumAggregateOutputType | null
    _min: Table_seatMinAggregateOutputType | null
    _max: Table_seatMaxAggregateOutputType | null
  }

  type GetTable_seatGroupByPayload<T extends table_seatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Table_seatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Table_seatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Table_seatGroupByOutputType[P]>
            : GetScalarType<T[P], Table_seatGroupByOutputType[P]>
        }
      >
    >


  export type table_seatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    seatIndex?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | tableDefaultArgs<ExtArgs>
    user?: boolean | table_seat$userArgs<ExtArgs>
  }, ExtArgs["result"]["table_seat"]>



  export type table_seatSelectScalar = {
    id?: boolean
    tableId?: boolean
    seatIndex?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type table_seatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "seatIndex" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["table_seat"]>
  export type table_seatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | tableDefaultArgs<ExtArgs>
    user?: boolean | table_seat$userArgs<ExtArgs>
  }

  export type $table_seatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "table_seat"
    objects: {
      table: Prisma.$tablePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableId: string
      /**
       * Position around the table (0-N)
       */
      seatIndex: number
      /**
       * Optional user at this seat
       */
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["table_seat"]>
    composites: {}
  }

  type table_seatGetPayload<S extends boolean | null | undefined | table_seatDefaultArgs> = $Result.GetResult<Prisma.$table_seatPayload, S>

  type table_seatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<table_seatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Table_seatCountAggregateInputType | true
    }

  export interface table_seatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['table_seat'], meta: { name: 'table_seat' } }
    /**
     * Find zero or one Table_seat that matches the filter.
     * @param {table_seatFindUniqueArgs} args - Arguments to find a Table_seat
     * @example
     * // Get one Table_seat
     * const table_seat = await prisma.table_seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends table_seatFindUniqueArgs>(args: SelectSubset<T, table_seatFindUniqueArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table_seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {table_seatFindUniqueOrThrowArgs} args - Arguments to find a Table_seat
     * @example
     * // Get one Table_seat
     * const table_seat = await prisma.table_seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends table_seatFindUniqueOrThrowArgs>(args: SelectSubset<T, table_seatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table_seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_seatFindFirstArgs} args - Arguments to find a Table_seat
     * @example
     * // Get one Table_seat
     * const table_seat = await prisma.table_seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends table_seatFindFirstArgs>(args?: SelectSubset<T, table_seatFindFirstArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table_seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_seatFindFirstOrThrowArgs} args - Arguments to find a Table_seat
     * @example
     * // Get one Table_seat
     * const table_seat = await prisma.table_seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends table_seatFindFirstOrThrowArgs>(args?: SelectSubset<T, table_seatFindFirstOrThrowArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Table_seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_seatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Table_seats
     * const table_seats = await prisma.table_seat.findMany()
     * 
     * // Get first 10 Table_seats
     * const table_seats = await prisma.table_seat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const table_seatWithIdOnly = await prisma.table_seat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends table_seatFindManyArgs>(args?: SelectSubset<T, table_seatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table_seat.
     * @param {table_seatCreateArgs} args - Arguments to create a Table_seat.
     * @example
     * // Create one Table_seat
     * const Table_seat = await prisma.table_seat.create({
     *   data: {
     *     // ... data to create a Table_seat
     *   }
     * })
     * 
     */
    create<T extends table_seatCreateArgs>(args: SelectSubset<T, table_seatCreateArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Table_seats.
     * @param {table_seatCreateManyArgs} args - Arguments to create many Table_seats.
     * @example
     * // Create many Table_seats
     * const table_seat = await prisma.table_seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends table_seatCreateManyArgs>(args?: SelectSubset<T, table_seatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Table_seat.
     * @param {table_seatDeleteArgs} args - Arguments to delete one Table_seat.
     * @example
     * // Delete one Table_seat
     * const Table_seat = await prisma.table_seat.delete({
     *   where: {
     *     // ... filter to delete one Table_seat
     *   }
     * })
     * 
     */
    delete<T extends table_seatDeleteArgs>(args: SelectSubset<T, table_seatDeleteArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table_seat.
     * @param {table_seatUpdateArgs} args - Arguments to update one Table_seat.
     * @example
     * // Update one Table_seat
     * const table_seat = await prisma.table_seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends table_seatUpdateArgs>(args: SelectSubset<T, table_seatUpdateArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Table_seats.
     * @param {table_seatDeleteManyArgs} args - Arguments to filter Table_seats to delete.
     * @example
     * // Delete a few Table_seats
     * const { count } = await prisma.table_seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends table_seatDeleteManyArgs>(args?: SelectSubset<T, table_seatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Table_seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_seatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Table_seats
     * const table_seat = await prisma.table_seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends table_seatUpdateManyArgs>(args: SelectSubset<T, table_seatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table_seat.
     * @param {table_seatUpsertArgs} args - Arguments to update or create a Table_seat.
     * @example
     * // Update or create a Table_seat
     * const table_seat = await prisma.table_seat.upsert({
     *   create: {
     *     // ... data to create a Table_seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table_seat we want to update
     *   }
     * })
     */
    upsert<T extends table_seatUpsertArgs>(args: SelectSubset<T, table_seatUpsertArgs<ExtArgs>>): Prisma__table_seatClient<$Result.GetResult<Prisma.$table_seatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Table_seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_seatCountArgs} args - Arguments to filter Table_seats to count.
     * @example
     * // Count the number of Table_seats
     * const count = await prisma.table_seat.count({
     *   where: {
     *     // ... the filter for the Table_seats we want to count
     *   }
     * })
    **/
    count<T extends table_seatCountArgs>(
      args?: Subset<T, table_seatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Table_seatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table_seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Table_seatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Table_seatAggregateArgs>(args: Subset<T, Table_seatAggregateArgs>): Prisma.PrismaPromise<GetTable_seatAggregateType<T>>

    /**
     * Group by Table_seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_seatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends table_seatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: table_seatGroupByArgs['orderBy'] }
        : { orderBy?: table_seatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, table_seatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTable_seatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the table_seat model
   */
  readonly fields: table_seatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for table_seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__table_seatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    table<T extends tableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tableDefaultArgs<ExtArgs>>): Prisma__tableClient<$Result.GetResult<Prisma.$tablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends table_seat$userArgs<ExtArgs> = {}>(args?: Subset<T, table_seat$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the table_seat model
   */
  interface table_seatFieldRefs {
    readonly id: FieldRef<"table_seat", 'String'>
    readonly tableId: FieldRef<"table_seat", 'String'>
    readonly seatIndex: FieldRef<"table_seat", 'Int'>
    readonly userId: FieldRef<"table_seat", 'String'>
    readonly createdAt: FieldRef<"table_seat", 'DateTime'>
    readonly updatedAt: FieldRef<"table_seat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * table_seat findUnique
   */
  export type table_seatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * Filter, which table_seat to fetch.
     */
    where: table_seatWhereUniqueInput
  }

  /**
   * table_seat findUniqueOrThrow
   */
  export type table_seatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * Filter, which table_seat to fetch.
     */
    where: table_seatWhereUniqueInput
  }

  /**
   * table_seat findFirst
   */
  export type table_seatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * Filter, which table_seat to fetch.
     */
    where?: table_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_seats to fetch.
     */
    orderBy?: table_seatOrderByWithRelationInput | table_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for table_seats.
     */
    cursor?: table_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of table_seats.
     */
    distinct?: Table_seatScalarFieldEnum | Table_seatScalarFieldEnum[]
  }

  /**
   * table_seat findFirstOrThrow
   */
  export type table_seatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * Filter, which table_seat to fetch.
     */
    where?: table_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_seats to fetch.
     */
    orderBy?: table_seatOrderByWithRelationInput | table_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for table_seats.
     */
    cursor?: table_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of table_seats.
     */
    distinct?: Table_seatScalarFieldEnum | Table_seatScalarFieldEnum[]
  }

  /**
   * table_seat findMany
   */
  export type table_seatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * Filter, which table_seats to fetch.
     */
    where?: table_seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_seats to fetch.
     */
    orderBy?: table_seatOrderByWithRelationInput | table_seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing table_seats.
     */
    cursor?: table_seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_seats.
     */
    skip?: number
    distinct?: Table_seatScalarFieldEnum | Table_seatScalarFieldEnum[]
  }

  /**
   * table_seat create
   */
  export type table_seatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * The data needed to create a table_seat.
     */
    data: XOR<table_seatCreateInput, table_seatUncheckedCreateInput>
  }

  /**
   * table_seat createMany
   */
  export type table_seatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many table_seats.
     */
    data: table_seatCreateManyInput | table_seatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * table_seat update
   */
  export type table_seatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * The data needed to update a table_seat.
     */
    data: XOR<table_seatUpdateInput, table_seatUncheckedUpdateInput>
    /**
     * Choose, which table_seat to update.
     */
    where: table_seatWhereUniqueInput
  }

  /**
   * table_seat updateMany
   */
  export type table_seatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update table_seats.
     */
    data: XOR<table_seatUpdateManyMutationInput, table_seatUncheckedUpdateManyInput>
    /**
     * Filter which table_seats to update
     */
    where?: table_seatWhereInput
    /**
     * Limit how many table_seats to update.
     */
    limit?: number
  }

  /**
   * table_seat upsert
   */
  export type table_seatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * The filter to search for the table_seat to update in case it exists.
     */
    where: table_seatWhereUniqueInput
    /**
     * In case the table_seat found by the `where` argument doesn't exist, create a new table_seat with this data.
     */
    create: XOR<table_seatCreateInput, table_seatUncheckedCreateInput>
    /**
     * In case the table_seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<table_seatUpdateInput, table_seatUncheckedUpdateInput>
  }

  /**
   * table_seat delete
   */
  export type table_seatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
    /**
     * Filter which table_seat to delete.
     */
    where: table_seatWhereUniqueInput
  }

  /**
   * table_seat deleteMany
   */
  export type table_seatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table_seats to delete
     */
    where?: table_seatWhereInput
    /**
     * Limit how many table_seats to delete.
     */
    limit?: number
  }

  /**
   * table_seat.user
   */
  export type table_seat$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * table_seat without action
   */
  export type table_seatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_seat
     */
    select?: table_seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_seat
     */
    omit?: table_seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: table_seatInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    email: 'email',
    role: 'role',
    status: 'status',
    expiresAt: 'expiresAt',
    inviterId: 'inviterId'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const JwksScalarFieldEnum: {
    id: 'id',
    publicKey: 'publicKey',
    privateKey: 'privateKey',
    createdAt: 'createdAt'
  };

  export type JwksScalarFieldEnum = (typeof JwksScalarFieldEnum)[keyof typeof JwksScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    impersonatedBy: 'impersonatedBy',
    activeOrganizationId: 'activeOrganizationId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    displayUsername: 'displayUsername',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SidelinkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    hidden: 'hidden'
  };

  export type SidelinkScalarFieldEnum = (typeof SidelinkScalarFieldEnum)[keyof typeof SidelinkScalarFieldEnum]


  export const Username_file_configScalarFieldEnum: {
    id: 'id',
    folder_slug: 'folder_slug',
    path: 'path',
    variable: 'variable',
    config_type: 'config_type'
  };

  export type Username_file_configScalarFieldEnum = (typeof Username_file_configScalarFieldEnum)[keyof typeof Username_file_configScalarFieldEnum]


  export const User_settingsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    local_games_dir: 'local_games_dir'
  };

  export type User_settingsScalarFieldEnum = (typeof User_settingsScalarFieldEnum)[keyof typeof User_settingsScalarFieldEnum]


  export const Game_sessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    game_slug: 'game_slug',
    start_time: 'start_time',
    end_time: 'end_time',
    total_seconds: 'total_seconds'
  };

  export type Game_sessionScalarFieldEnum = (typeof Game_sessionScalarFieldEnum)[keyof typeof Game_sessionScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    url: 'url',
    start_time: 'start_time',
    end_time: 'end_time',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by',
    location: 'location',
    image_url: 'image_url'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const Global_settingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type Global_settingsScalarFieldEnum = (typeof Global_settingsScalarFieldEnum)[keyof typeof Global_settingsScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    size_gb: 'size_gb',
    title: 'title',
    folder_slug: 'folder_slug',
    version: 'version',
    genres: 'genres',
    platforms: 'platforms',
    game_modes: 'game_modes',
    is_featured: 'is_featured',
    date_updated: 'date_updated',
    date_added: 'date_added',
    editor_name: 'editor_name',
    main_process_name: 'main_process_name',
    cover: 'cover',
    logo: 'logo',
    screenshots: 'screenshots',
    description: 'description',
    start_command: 'start_command',
    max_players: 'max_players',
    use_notifications: 'use_notifications',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const Game_serverScalarFieldEnum: {
    id: 'id',
    game_slug: 'game_slug',
    game_title: 'game_title',
    type: 'type',
    port: 'port',
    description: 'description',
    name: 'name',
    monitor: 'monitor',
    last_detection_at: 'last_detection_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type Game_serverScalarFieldEnum = (typeof Game_serverScalarFieldEnum)[keyof typeof Game_serverScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    name: 'name',
    nameplate_decoration_animated: 'nameplate_decoration_animated',
    nameplate_decoration_static: 'nameplate_decoration_static',
    avatar_decoration_animated: 'avatar_decoration_animated',
    avatar_decoration_static: 'avatar_decoration_static'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const User_gameScalarFieldEnum: {
    user_id: 'user_id',
    game_slug: 'game_slug',
    installed_at: 'installed_at'
  };

  export type User_gameScalarFieldEnum = (typeof User_gameScalarFieldEnum)[keyof typeof User_gameScalarFieldEnum]


  export const User_game_favoriteScalarFieldEnum: {
    user_id: 'user_id',
    game_slug: 'game_slug',
    addedAt: 'addedAt'
  };

  export type User_game_favoriteScalarFieldEnum = (typeof User_game_favoriteScalarFieldEnum)[keyof typeof User_game_favoriteScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    published: 'published',
    position: 'position',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const GuildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    icon: 'icon',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuildScalarFieldEnum = (typeof GuildScalarFieldEnum)[keyof typeof GuildScalarFieldEnum]


  export const Guild_memberScalarFieldEnum: {
    id: 'id',
    guildId: 'guildId',
    userId: 'userId',
    nickname: 'nickname',
    roles: 'roles',
    joinedAt: 'joinedAt'
  };

  export type Guild_memberScalarFieldEnum = (typeof Guild_memberScalarFieldEnum)[keyof typeof Guild_memberScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    guildId: 'guildId',
    name: 'name',
    slug: 'slug',
    type: 'type',
    topic: 'topic',
    position: 'position',
    isPrivate: 'isPrivate',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const Channel_memberScalarFieldEnum: {
    channelId: 'channelId',
    userId: 'userId',
    addedAt: 'addedAt'
  };

  export type Channel_memberScalarFieldEnum = (typeof Channel_memberScalarFieldEnum)[keyof typeof Channel_memberScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    ownerId: 'ownerId',
    guildId: 'guildId',
    channelId: 'channelId',
    lastMessageAt: 'lastMessageAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const Room_participantScalarFieldEnum: {
    roomId: 'roomId',
    userId: 'userId',
    joinedAt: 'joinedAt',
    isMuted: 'isMuted',
    isPinned: 'isPinned'
  };

  export type Room_participantScalarFieldEnum = (typeof Room_participantScalarFieldEnum)[keyof typeof Room_participantScalarFieldEnum]


  export const Dm_pair_uniqueScalarFieldEnum: {
    id: 'id',
    userA: 'userA',
    userB: 'userB',
    roomId: 'roomId'
  };

  export type Dm_pair_uniqueScalarFieldEnum = (typeof Dm_pair_uniqueScalarFieldEnum)[keyof typeof Dm_pair_uniqueScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    authorId: 'authorId',
    type: 'type',
    content: 'content',
    attachments: 'attachments',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    deletedAt: 'deletedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const Message_readScalarFieldEnum: {
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type Message_readScalarFieldEnum = (typeof Message_readScalarFieldEnum)[keyof typeof Message_readScalarFieldEnum]


  export const Message_reactionScalarFieldEnum: {
    messageId: 'messageId',
    userId: 'userId',
    emoji: 'emoji',
    createdAt: 'createdAt'
  };

  export type Message_reactionScalarFieldEnum = (typeof Message_reactionScalarFieldEnum)[keyof typeof Message_reactionScalarFieldEnum]


  export const Room_viewScalarFieldEnum: {
    roomId: 'roomId',
    userId: 'userId',
    lastSeenAt: 'lastSeenAt'
  };

  export type Room_viewScalarFieldEnum = (typeof Room_viewScalarFieldEnum)[keyof typeof Room_viewScalarFieldEnum]


  export const EFMigrationsHistoryScalarFieldEnum: {
    MigrationId: 'MigrationId',
    ProductVersion: 'ProductVersion'
  };

  export type EFMigrationsHistoryScalarFieldEnum = (typeof EFMigrationsHistoryScalarFieldEnum)[keyof typeof EFMigrationsHistoryScalarFieldEnum]


  export const EditionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type EditionScalarFieldEnum = (typeof EditionScalarFieldEnum)[keyof typeof EditionScalarFieldEnum]


  export const Edition_roomScalarFieldEnum: {
    id: 'id',
    editionId: 'editionId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Edition_roomScalarFieldEnum = (typeof Edition_roomScalarFieldEnum)[keyof typeof Edition_roomScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    name: 'name',
    positionX: 'positionX',
    positionY: 'positionY',
    width: 'width',
    height: 'height',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const Table_seatScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    seatIndex: 'seatIndex',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Table_seatScalarFieldEnum = (typeof Table_seatScalarFieldEnum)[keyof typeof Table_seatScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const accountOrderByRelevanceFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    scope: 'scope',
    password: 'password'
  };

  export type accountOrderByRelevanceFieldEnum = (typeof accountOrderByRelevanceFieldEnum)[keyof typeof accountOrderByRelevanceFieldEnum]


  export const invitationOrderByRelevanceFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    email: 'email',
    role: 'role',
    status: 'status',
    inviterId: 'inviterId'
  };

  export type invitationOrderByRelevanceFieldEnum = (typeof invitationOrderByRelevanceFieldEnum)[keyof typeof invitationOrderByRelevanceFieldEnum]


  export const jwksOrderByRelevanceFieldEnum: {
    id: 'id',
    publicKey: 'publicKey',
    privateKey: 'privateKey'
  };

  export type jwksOrderByRelevanceFieldEnum = (typeof jwksOrderByRelevanceFieldEnum)[keyof typeof jwksOrderByRelevanceFieldEnum]


  export const memberOrderByRelevanceFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role'
  };

  export type memberOrderByRelevanceFieldEnum = (typeof memberOrderByRelevanceFieldEnum)[keyof typeof memberOrderByRelevanceFieldEnum]


  export const organizationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    metadata: 'metadata'
  };

  export type organizationOrderByRelevanceFieldEnum = (typeof organizationOrderByRelevanceFieldEnum)[keyof typeof organizationOrderByRelevanceFieldEnum]


  export const sessionOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    impersonatedBy: 'impersonatedBy',
    activeOrganizationId: 'activeOrganizationId'
  };

  export type sessionOrderByRelevanceFieldEnum = (typeof sessionOrderByRelevanceFieldEnum)[keyof typeof sessionOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image',
    username: 'username',
    role: 'role',
    banReason: 'banReason',
    displayUsername: 'displayUsername'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const verificationOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value'
  };

  export type verificationOrderByRelevanceFieldEnum = (typeof verificationOrderByRelevanceFieldEnum)[keyof typeof verificationOrderByRelevanceFieldEnum]


  export const sidelinkOrderByRelevanceFieldEnum: {
    name: 'name',
    url: 'url',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type sidelinkOrderByRelevanceFieldEnum = (typeof sidelinkOrderByRelevanceFieldEnum)[keyof typeof sidelinkOrderByRelevanceFieldEnum]


  export const username_file_configOrderByRelevanceFieldEnum: {
    folder_slug: 'folder_slug',
    path: 'path',
    variable: 'variable',
    config_type: 'config_type'
  };

  export type username_file_configOrderByRelevanceFieldEnum = (typeof username_file_configOrderByRelevanceFieldEnum)[keyof typeof username_file_configOrderByRelevanceFieldEnum]


  export const user_settingsOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    local_games_dir: 'local_games_dir'
  };

  export type user_settingsOrderByRelevanceFieldEnum = (typeof user_settingsOrderByRelevanceFieldEnum)[keyof typeof user_settingsOrderByRelevanceFieldEnum]


  export const game_sessionOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    game_slug: 'game_slug'
  };

  export type game_sessionOrderByRelevanceFieldEnum = (typeof game_sessionOrderByRelevanceFieldEnum)[keyof typeof game_sessionOrderByRelevanceFieldEnum]


  export const eventOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    url: 'url',
    created_by: 'created_by',
    updated_by: 'updated_by',
    location: 'location',
    image_url: 'image_url'
  };

  export type eventOrderByRelevanceFieldEnum = (typeof eventOrderByRelevanceFieldEnum)[keyof typeof eventOrderByRelevanceFieldEnum]


  export const global_settingsOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type global_settingsOrderByRelevanceFieldEnum = (typeof global_settingsOrderByRelevanceFieldEnum)[keyof typeof global_settingsOrderByRelevanceFieldEnum]


  export const gameOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    folder_slug: 'folder_slug',
    version: 'version',
    genres: 'genres',
    platforms: 'platforms',
    game_modes: 'game_modes',
    editor_name: 'editor_name',
    main_process_name: 'main_process_name',
    cover: 'cover',
    logo: 'logo',
    screenshots: 'screenshots',
    description: 'description',
    start_command: 'start_command',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type gameOrderByRelevanceFieldEnum = (typeof gameOrderByRelevanceFieldEnum)[keyof typeof gameOrderByRelevanceFieldEnum]


  export const game_serverOrderByRelevanceFieldEnum: {
    game_slug: 'game_slug',
    game_title: 'game_title',
    type: 'type',
    description: 'description',
    name: 'name',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type game_serverOrderByRelevanceFieldEnum = (typeof game_serverOrderByRelevanceFieldEnum)[keyof typeof game_serverOrderByRelevanceFieldEnum]


  export const roleOrderByRelevanceFieldEnum: {
    name: 'name',
    nameplate_decoration_animated: 'nameplate_decoration_animated',
    nameplate_decoration_static: 'nameplate_decoration_static',
    avatar_decoration_animated: 'avatar_decoration_animated',
    avatar_decoration_static: 'avatar_decoration_static'
  };

  export type roleOrderByRelevanceFieldEnum = (typeof roleOrderByRelevanceFieldEnum)[keyof typeof roleOrderByRelevanceFieldEnum]


  export const user_gameOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    game_slug: 'game_slug'
  };

  export type user_gameOrderByRelevanceFieldEnum = (typeof user_gameOrderByRelevanceFieldEnum)[keyof typeof user_gameOrderByRelevanceFieldEnum]


  export const user_game_favoriteOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    game_slug: 'game_slug'
  };

  export type user_game_favoriteOrderByRelevanceFieldEnum = (typeof user_game_favoriteOrderByRelevanceFieldEnum)[keyof typeof user_game_favoriteOrderByRelevanceFieldEnum]


  export const faqOrderByRelevanceFieldEnum: {
    question: 'question',
    answer: 'answer',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type faqOrderByRelevanceFieldEnum = (typeof faqOrderByRelevanceFieldEnum)[keyof typeof faqOrderByRelevanceFieldEnum]


  export const guildOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    icon: 'icon',
    ownerId: 'ownerId'
  };

  export type guildOrderByRelevanceFieldEnum = (typeof guildOrderByRelevanceFieldEnum)[keyof typeof guildOrderByRelevanceFieldEnum]


  export const guild_memberOrderByRelevanceFieldEnum: {
    id: 'id',
    guildId: 'guildId',
    userId: 'userId',
    nickname: 'nickname',
    roles: 'roles'
  };

  export type guild_memberOrderByRelevanceFieldEnum = (typeof guild_memberOrderByRelevanceFieldEnum)[keyof typeof guild_memberOrderByRelevanceFieldEnum]


  export const channelOrderByRelevanceFieldEnum: {
    id: 'id',
    guildId: 'guildId',
    name: 'name',
    slug: 'slug',
    topic: 'topic',
    parentId: 'parentId'
  };

  export type channelOrderByRelevanceFieldEnum = (typeof channelOrderByRelevanceFieldEnum)[keyof typeof channelOrderByRelevanceFieldEnum]


  export const channel_memberOrderByRelevanceFieldEnum: {
    channelId: 'channelId',
    userId: 'userId'
  };

  export type channel_memberOrderByRelevanceFieldEnum = (typeof channel_memberOrderByRelevanceFieldEnum)[keyof typeof channel_memberOrderByRelevanceFieldEnum]


  export const roomOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    ownerId: 'ownerId',
    guildId: 'guildId',
    channelId: 'channelId'
  };

  export type roomOrderByRelevanceFieldEnum = (typeof roomOrderByRelevanceFieldEnum)[keyof typeof roomOrderByRelevanceFieldEnum]


  export const room_participantOrderByRelevanceFieldEnum: {
    roomId: 'roomId',
    userId: 'userId'
  };

  export type room_participantOrderByRelevanceFieldEnum = (typeof room_participantOrderByRelevanceFieldEnum)[keyof typeof room_participantOrderByRelevanceFieldEnum]


  export const dm_pair_uniqueOrderByRelevanceFieldEnum: {
    id: 'id',
    userA: 'userA',
    userB: 'userB',
    roomId: 'roomId'
  };

  export type dm_pair_uniqueOrderByRelevanceFieldEnum = (typeof dm_pair_uniqueOrderByRelevanceFieldEnum)[keyof typeof dm_pair_uniqueOrderByRelevanceFieldEnum]


  export const messageOrderByRelevanceFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    authorId: 'authorId',
    content: 'content',
    attachments: 'attachments'
  };

  export type messageOrderByRelevanceFieldEnum = (typeof messageOrderByRelevanceFieldEnum)[keyof typeof messageOrderByRelevanceFieldEnum]


  export const message_readOrderByRelevanceFieldEnum: {
    messageId: 'messageId',
    userId: 'userId'
  };

  export type message_readOrderByRelevanceFieldEnum = (typeof message_readOrderByRelevanceFieldEnum)[keyof typeof message_readOrderByRelevanceFieldEnum]


  export const message_reactionOrderByRelevanceFieldEnum: {
    messageId: 'messageId',
    userId: 'userId',
    emoji: 'emoji'
  };

  export type message_reactionOrderByRelevanceFieldEnum = (typeof message_reactionOrderByRelevanceFieldEnum)[keyof typeof message_reactionOrderByRelevanceFieldEnum]


  export const room_viewOrderByRelevanceFieldEnum: {
    roomId: 'roomId',
    userId: 'userId'
  };

  export type room_viewOrderByRelevanceFieldEnum = (typeof room_viewOrderByRelevanceFieldEnum)[keyof typeof room_viewOrderByRelevanceFieldEnum]


  export const EFMigrationsHistoryOrderByRelevanceFieldEnum: {
    MigrationId: 'MigrationId',
    ProductVersion: 'ProductVersion'
  };

  export type EFMigrationsHistoryOrderByRelevanceFieldEnum = (typeof EFMigrationsHistoryOrderByRelevanceFieldEnum)[keyof typeof EFMigrationsHistoryOrderByRelevanceFieldEnum]


  export const editionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type editionOrderByRelevanceFieldEnum = (typeof editionOrderByRelevanceFieldEnum)[keyof typeof editionOrderByRelevanceFieldEnum]


  export const edition_roomOrderByRelevanceFieldEnum: {
    id: 'id',
    editionId: 'editionId',
    name: 'name'
  };

  export type edition_roomOrderByRelevanceFieldEnum = (typeof edition_roomOrderByRelevanceFieldEnum)[keyof typeof edition_roomOrderByRelevanceFieldEnum]


  export const tableOrderByRelevanceFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    name: 'name'
  };

  export type tableOrderByRelevanceFieldEnum = (typeof tableOrderByRelevanceFieldEnum)[keyof typeof tableOrderByRelevanceFieldEnum]


  export const table_seatOrderByRelevanceFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    userId: 'userId'
  };

  export type table_seatOrderByRelevanceFieldEnum = (typeof table_seatOrderByRelevanceFieldEnum)[keyof typeof table_seatOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'channel_type'
   */
  export type Enumchannel_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'channel_type'>
    


  /**
   * Reference to a field of type 'room_type'
   */
  export type Enumroom_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'room_type'>
    


  /**
   * Reference to a field of type 'message_type'
   */
  export type Enummessage_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'message_type'>
    
  /**
   * Deep Input Types
   */


  export type accountWhereInput = {
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    id?: StringFilter<"account"> | string
    accountId?: StringFilter<"account"> | string
    providerId?: StringFilter<"account"> | string
    userId?: StringFilter<"account"> | string
    accessToken?: StringNullableFilter<"account"> | string | null
    refreshToken?: StringNullableFilter<"account"> | string | null
    idToken?: StringNullableFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    scope?: StringNullableFilter<"account"> | string | null
    password?: StringNullableFilter<"account"> | string | null
    createdAt?: DateTimeFilter<"account"> | Date | string
    updatedAt?: DateTimeFilter<"account"> | Date | string
  }

  export type accountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: accountOrderByRelevanceInput
  }

  export type accountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: accountWhereInput | accountWhereInput[]
    OR?: accountWhereInput[]
    NOT?: accountWhereInput | accountWhereInput[]
    accountId?: StringFilter<"account"> | string
    providerId?: StringFilter<"account"> | string
    userId?: StringFilter<"account"> | string
    accessToken?: StringNullableFilter<"account"> | string | null
    refreshToken?: StringNullableFilter<"account"> | string | null
    idToken?: StringNullableFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null
    scope?: StringNullableFilter<"account"> | string | null
    password?: StringNullableFilter<"account"> | string | null
    createdAt?: DateTimeFilter<"account"> | Date | string
    updatedAt?: DateTimeFilter<"account"> | Date | string
  }, "id">

  export type accountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: accountCountOrderByAggregateInput
    _max?: accountMaxOrderByAggregateInput
    _min?: accountMinOrderByAggregateInput
  }

  export type accountScalarWhereWithAggregatesInput = {
    AND?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    OR?: accountScalarWhereWithAggregatesInput[]
    NOT?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"account"> | string
    accountId?: StringWithAggregatesFilter<"account"> | string
    providerId?: StringWithAggregatesFilter<"account"> | string
    userId?: StringWithAggregatesFilter<"account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"account"> | string | null
    password?: StringNullableWithAggregatesFilter<"account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"account"> | Date | string
  }

  export type invitationWhereInput = {
    AND?: invitationWhereInput | invitationWhereInput[]
    OR?: invitationWhereInput[]
    NOT?: invitationWhereInput | invitationWhereInput[]
    id?: StringFilter<"invitation"> | string
    organizationId?: StringFilter<"invitation"> | string
    email?: StringFilter<"invitation"> | string
    role?: StringNullableFilter<"invitation"> | string | null
    status?: StringFilter<"invitation"> | string
    expiresAt?: DateTimeFilter<"invitation"> | Date | string
    inviterId?: StringFilter<"invitation"> | string
  }

  export type invitationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    _relevance?: invitationOrderByRelevanceInput
  }

  export type invitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invitationWhereInput | invitationWhereInput[]
    OR?: invitationWhereInput[]
    NOT?: invitationWhereInput | invitationWhereInput[]
    organizationId?: StringFilter<"invitation"> | string
    email?: StringFilter<"invitation"> | string
    role?: StringNullableFilter<"invitation"> | string | null
    status?: StringFilter<"invitation"> | string
    expiresAt?: DateTimeFilter<"invitation"> | Date | string
    inviterId?: StringFilter<"invitation"> | string
  }, "id">

  export type invitationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    _count?: invitationCountOrderByAggregateInput
    _max?: invitationMaxOrderByAggregateInput
    _min?: invitationMinOrderByAggregateInput
  }

  export type invitationScalarWhereWithAggregatesInput = {
    AND?: invitationScalarWhereWithAggregatesInput | invitationScalarWhereWithAggregatesInput[]
    OR?: invitationScalarWhereWithAggregatesInput[]
    NOT?: invitationScalarWhereWithAggregatesInput | invitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"invitation"> | string
    organizationId?: StringWithAggregatesFilter<"invitation"> | string
    email?: StringWithAggregatesFilter<"invitation"> | string
    role?: StringNullableWithAggregatesFilter<"invitation"> | string | null
    status?: StringWithAggregatesFilter<"invitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"invitation"> | Date | string
    inviterId?: StringWithAggregatesFilter<"invitation"> | string
  }

  export type jwksWhereInput = {
    AND?: jwksWhereInput | jwksWhereInput[]
    OR?: jwksWhereInput[]
    NOT?: jwksWhereInput | jwksWhereInput[]
    id?: StringFilter<"jwks"> | string
    publicKey?: StringFilter<"jwks"> | string
    privateKey?: StringFilter<"jwks"> | string
    createdAt?: DateTimeFilter<"jwks"> | Date | string
  }

  export type jwksOrderByWithRelationInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
    _relevance?: jwksOrderByRelevanceInput
  }

  export type jwksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: jwksWhereInput | jwksWhereInput[]
    OR?: jwksWhereInput[]
    NOT?: jwksWhereInput | jwksWhereInput[]
    publicKey?: StringFilter<"jwks"> | string
    privateKey?: StringFilter<"jwks"> | string
    createdAt?: DateTimeFilter<"jwks"> | Date | string
  }, "id">

  export type jwksOrderByWithAggregationInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
    _count?: jwksCountOrderByAggregateInput
    _max?: jwksMaxOrderByAggregateInput
    _min?: jwksMinOrderByAggregateInput
  }

  export type jwksScalarWhereWithAggregatesInput = {
    AND?: jwksScalarWhereWithAggregatesInput | jwksScalarWhereWithAggregatesInput[]
    OR?: jwksScalarWhereWithAggregatesInput[]
    NOT?: jwksScalarWhereWithAggregatesInput | jwksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"jwks"> | string
    publicKey?: StringWithAggregatesFilter<"jwks"> | string
    privateKey?: StringWithAggregatesFilter<"jwks"> | string
    createdAt?: DateTimeWithAggregatesFilter<"jwks"> | Date | string
  }

  export type memberWhereInput = {
    AND?: memberWhereInput | memberWhereInput[]
    OR?: memberWhereInput[]
    NOT?: memberWhereInput | memberWhereInput[]
    id?: StringFilter<"member"> | string
    organizationId?: StringFilter<"member"> | string
    userId?: StringFilter<"member"> | string
    role?: StringFilter<"member"> | string
    createdAt?: DateTimeFilter<"member"> | Date | string
  }

  export type memberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _relevance?: memberOrderByRelevanceInput
  }

  export type memberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: memberWhereInput | memberWhereInput[]
    OR?: memberWhereInput[]
    NOT?: memberWhereInput | memberWhereInput[]
    organizationId?: StringFilter<"member"> | string
    userId?: StringFilter<"member"> | string
    role?: StringFilter<"member"> | string
    createdAt?: DateTimeFilter<"member"> | Date | string
  }, "id">

  export type memberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: memberCountOrderByAggregateInput
    _max?: memberMaxOrderByAggregateInput
    _min?: memberMinOrderByAggregateInput
  }

  export type memberScalarWhereWithAggregatesInput = {
    AND?: memberScalarWhereWithAggregatesInput | memberScalarWhereWithAggregatesInput[]
    OR?: memberScalarWhereWithAggregatesInput[]
    NOT?: memberScalarWhereWithAggregatesInput | memberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"member"> | string
    organizationId?: StringWithAggregatesFilter<"member"> | string
    userId?: StringWithAggregatesFilter<"member"> | string
    role?: StringWithAggregatesFilter<"member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"member"> | Date | string
  }

  export type organizationWhereInput = {
    AND?: organizationWhereInput | organizationWhereInput[]
    OR?: organizationWhereInput[]
    NOT?: organizationWhereInput | organizationWhereInput[]
    id?: StringFilter<"organization"> | string
    name?: StringFilter<"organization"> | string
    slug?: StringFilter<"organization"> | string
    logo?: StringNullableFilter<"organization"> | string | null
    createdAt?: DateTimeFilter<"organization"> | Date | string
    metadata?: StringNullableFilter<"organization"> | string | null
  }

  export type organizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _relevance?: organizationOrderByRelevanceInput
  }

  export type organizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: organizationWhereInput | organizationWhereInput[]
    OR?: organizationWhereInput[]
    NOT?: organizationWhereInput | organizationWhereInput[]
    name?: StringFilter<"organization"> | string
    logo?: StringNullableFilter<"organization"> | string | null
    createdAt?: DateTimeFilter<"organization"> | Date | string
    metadata?: StringNullableFilter<"organization"> | string | null
  }, "id" | "slug">

  export type organizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: organizationCountOrderByAggregateInput
    _max?: organizationMaxOrderByAggregateInput
    _min?: organizationMinOrderByAggregateInput
  }

  export type organizationScalarWhereWithAggregatesInput = {
    AND?: organizationScalarWhereWithAggregatesInput | organizationScalarWhereWithAggregatesInput[]
    OR?: organizationScalarWhereWithAggregatesInput[]
    NOT?: organizationScalarWhereWithAggregatesInput | organizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"organization"> | string
    name?: StringWithAggregatesFilter<"organization"> | string
    slug?: StringWithAggregatesFilter<"organization"> | string
    logo?: StringNullableWithAggregatesFilter<"organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"organization"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"organization"> | string | null
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    token?: StringFilter<"session"> | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    userId?: StringFilter<"session"> | string
    impersonatedBy?: StringNullableFilter<"session"> | string | null
    activeOrganizationId?: StringNullableFilter<"session"> | string | null
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    activeOrganizationId?: SortOrderInput | SortOrder
    _relevance?: sessionOrderByRelevanceInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    userId?: StringFilter<"session"> | string
    impersonatedBy?: StringNullableFilter<"session"> | string | null
    activeOrganizationId?: StringNullableFilter<"session"> | string | null
  }, "id" | "token">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    activeOrganizationId?: SortOrderInput | SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    token?: StringWithAggregatesFilter<"session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"session"> | string | null
    userId?: StringWithAggregatesFilter<"session"> | string
    impersonatedBy?: StringNullableWithAggregatesFilter<"session"> | string | null
    activeOrganizationId?: StringNullableWithAggregatesFilter<"session"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    image?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    username?: StringNullableFilter<"user"> | string | null
    role?: StringFilter<"user"> | string
    banned?: BoolNullableFilter<"user"> | boolean | null
    banReason?: StringNullableFilter<"user"> | string | null
    banExpires?: DateTimeNullableFilter<"user"> | Date | string | null
    displayUsername?: StringNullableFilter<"user"> | string | null
    lastLogin?: DateTimeNullableFilter<"user"> | Date | string | null
    channel_memberships?: Channel_memberListRelationFilter
    event_created?: EventListRelationFilter
    event_updated?: EventListRelationFilter
    faq_created?: FaqListRelationFilter
    faq_updated?: FaqListRelationFilter
    gamesCreated?: GameListRelationFilter
    gamesUpdated?: GameListRelationFilter
    game_session?: Game_sessionListRelationFilter
    guild?: GuildListRelationFilter
    guild_memberships?: Guild_memberListRelationFilter
    messages?: MessageListRelationFilter
    message_reactions?: Message_reactionListRelationFilter
    message_reads?: Message_readListRelationFilter
    room?: RoomListRelationFilter
    room_participations?: Room_participantListRelationFilter
    room_view?: Room_viewListRelationFilter
    user_settings?: XOR<User_settingsNullableScalarRelationFilter, user_settingsWhereInput> | null
    edition_created?: EditionListRelationFilter
    edition_updated?: EditionListRelationFilter
    table_seats?: Table_seatListRelationFilter
    game_server_created?: Game_serverListRelationFilter
    game_server_updated?: Game_serverListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    role?: SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    displayUsername?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    channel_memberships?: channel_memberOrderByRelationAggregateInput
    event_created?: eventOrderByRelationAggregateInput
    event_updated?: eventOrderByRelationAggregateInput
    faq_created?: faqOrderByRelationAggregateInput
    faq_updated?: faqOrderByRelationAggregateInput
    gamesCreated?: gameOrderByRelationAggregateInput
    gamesUpdated?: gameOrderByRelationAggregateInput
    game_session?: game_sessionOrderByRelationAggregateInput
    guild?: guildOrderByRelationAggregateInput
    guild_memberships?: guild_memberOrderByRelationAggregateInput
    messages?: messageOrderByRelationAggregateInput
    message_reactions?: message_reactionOrderByRelationAggregateInput
    message_reads?: message_readOrderByRelationAggregateInput
    room?: roomOrderByRelationAggregateInput
    room_participations?: room_participantOrderByRelationAggregateInput
    room_view?: room_viewOrderByRelationAggregateInput
    user_settings?: user_settingsOrderByWithRelationInput
    edition_created?: editionOrderByRelationAggregateInput
    edition_updated?: editionOrderByRelationAggregateInput
    table_seats?: table_seatOrderByRelationAggregateInput
    game_server_created?: game_serverOrderByRelationAggregateInput
    game_server_updated?: game_serverOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    emailVerified?: BoolFilter<"user"> | boolean
    image?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    role?: StringFilter<"user"> | string
    banned?: BoolNullableFilter<"user"> | boolean | null
    banReason?: StringNullableFilter<"user"> | string | null
    banExpires?: DateTimeNullableFilter<"user"> | Date | string | null
    displayUsername?: StringNullableFilter<"user"> | string | null
    lastLogin?: DateTimeNullableFilter<"user"> | Date | string | null
    channel_memberships?: Channel_memberListRelationFilter
    event_created?: EventListRelationFilter
    event_updated?: EventListRelationFilter
    faq_created?: FaqListRelationFilter
    faq_updated?: FaqListRelationFilter
    gamesCreated?: GameListRelationFilter
    gamesUpdated?: GameListRelationFilter
    game_session?: Game_sessionListRelationFilter
    guild?: GuildListRelationFilter
    guild_memberships?: Guild_memberListRelationFilter
    messages?: MessageListRelationFilter
    message_reactions?: Message_reactionListRelationFilter
    message_reads?: Message_readListRelationFilter
    room?: RoomListRelationFilter
    room_participations?: Room_participantListRelationFilter
    room_view?: Room_viewListRelationFilter
    user_settings?: XOR<User_settingsNullableScalarRelationFilter, user_settingsWhereInput> | null
    edition_created?: EditionListRelationFilter
    edition_updated?: EditionListRelationFilter
    table_seats?: Table_seatListRelationFilter
    game_server_created?: Game_serverListRelationFilter
    game_server_updated?: Game_serverListRelationFilter
  }, "id" | "email" | "username">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    role?: SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    displayUsername?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    emailVerified?: BoolWithAggregatesFilter<"user"> | boolean
    image?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    username?: StringNullableWithAggregatesFilter<"user"> | string | null
    role?: StringWithAggregatesFilter<"user"> | string
    banned?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"user"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    displayUsername?: StringNullableWithAggregatesFilter<"user"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type verificationWhereInput = {
    AND?: verificationWhereInput | verificationWhereInput[]
    OR?: verificationWhereInput[]
    NOT?: verificationWhereInput | verificationWhereInput[]
    id?: StringFilter<"verification"> | string
    identifier?: StringFilter<"verification"> | string
    value?: StringFilter<"verification"> | string
    expiresAt?: DateTimeFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"verification"> | Date | string | null
  }

  export type verificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: verificationOrderByRelevanceInput
  }

  export type verificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: verificationWhereInput | verificationWhereInput[]
    OR?: verificationWhereInput[]
    NOT?: verificationWhereInput | verificationWhereInput[]
    identifier?: StringFilter<"verification"> | string
    value?: StringFilter<"verification"> | string
    expiresAt?: DateTimeFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"verification"> | Date | string | null
  }, "id">

  export type verificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: verificationCountOrderByAggregateInput
    _max?: verificationMaxOrderByAggregateInput
    _min?: verificationMinOrderByAggregateInput
  }

  export type verificationScalarWhereWithAggregatesInput = {
    AND?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[]
    OR?: verificationScalarWhereWithAggregatesInput[]
    NOT?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"verification"> | string
    identifier?: StringWithAggregatesFilter<"verification"> | string
    value?: StringWithAggregatesFilter<"verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"verification"> | Date | string | null
  }

  export type sidelinkWhereInput = {
    AND?: sidelinkWhereInput | sidelinkWhereInput[]
    OR?: sidelinkWhereInput[]
    NOT?: sidelinkWhereInput | sidelinkWhereInput[]
    id?: IntFilter<"sidelink"> | number
    name?: StringFilter<"sidelink"> | string
    url?: StringFilter<"sidelink"> | string
    createdAt?: DateTimeFilter<"sidelink"> | Date | string
    updatedAt?: DateTimeFilter<"sidelink"> | Date | string
    createdBy?: StringFilter<"sidelink"> | string
    updatedBy?: StringFilter<"sidelink"> | string
    hidden?: BoolFilter<"sidelink"> | boolean
  }

  export type sidelinkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    hidden?: SortOrder
    _relevance?: sidelinkOrderByRelevanceInput
  }

  export type sidelinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sidelinkWhereInput | sidelinkWhereInput[]
    OR?: sidelinkWhereInput[]
    NOT?: sidelinkWhereInput | sidelinkWhereInput[]
    name?: StringFilter<"sidelink"> | string
    url?: StringFilter<"sidelink"> | string
    createdAt?: DateTimeFilter<"sidelink"> | Date | string
    updatedAt?: DateTimeFilter<"sidelink"> | Date | string
    createdBy?: StringFilter<"sidelink"> | string
    updatedBy?: StringFilter<"sidelink"> | string
    hidden?: BoolFilter<"sidelink"> | boolean
  }, "id">

  export type sidelinkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    hidden?: SortOrder
    _count?: sidelinkCountOrderByAggregateInput
    _avg?: sidelinkAvgOrderByAggregateInput
    _max?: sidelinkMaxOrderByAggregateInput
    _min?: sidelinkMinOrderByAggregateInput
    _sum?: sidelinkSumOrderByAggregateInput
  }

  export type sidelinkScalarWhereWithAggregatesInput = {
    AND?: sidelinkScalarWhereWithAggregatesInput | sidelinkScalarWhereWithAggregatesInput[]
    OR?: sidelinkScalarWhereWithAggregatesInput[]
    NOT?: sidelinkScalarWhereWithAggregatesInput | sidelinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sidelink"> | number
    name?: StringWithAggregatesFilter<"sidelink"> | string
    url?: StringWithAggregatesFilter<"sidelink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"sidelink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sidelink"> | Date | string
    createdBy?: StringWithAggregatesFilter<"sidelink"> | string
    updatedBy?: StringWithAggregatesFilter<"sidelink"> | string
    hidden?: BoolWithAggregatesFilter<"sidelink"> | boolean
  }

  export type username_file_configWhereInput = {
    AND?: username_file_configWhereInput | username_file_configWhereInput[]
    OR?: username_file_configWhereInput[]
    NOT?: username_file_configWhereInput | username_file_configWhereInput[]
    id?: IntFilter<"username_file_config"> | number
    folder_slug?: StringNullableFilter<"username_file_config"> | string | null
    path?: StringNullableFilter<"username_file_config"> | string | null
    variable?: StringNullableFilter<"username_file_config"> | string | null
    config_type?: StringNullableFilter<"username_file_config"> | string | null
  }

  export type username_file_configOrderByWithRelationInput = {
    id?: SortOrder
    folder_slug?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    variable?: SortOrderInput | SortOrder
    config_type?: SortOrderInput | SortOrder
    _relevance?: username_file_configOrderByRelevanceInput
  }

  export type username_file_configWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: username_file_configWhereInput | username_file_configWhereInput[]
    OR?: username_file_configWhereInput[]
    NOT?: username_file_configWhereInput | username_file_configWhereInput[]
    folder_slug?: StringNullableFilter<"username_file_config"> | string | null
    path?: StringNullableFilter<"username_file_config"> | string | null
    variable?: StringNullableFilter<"username_file_config"> | string | null
    config_type?: StringNullableFilter<"username_file_config"> | string | null
  }, "id">

  export type username_file_configOrderByWithAggregationInput = {
    id?: SortOrder
    folder_slug?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    variable?: SortOrderInput | SortOrder
    config_type?: SortOrderInput | SortOrder
    _count?: username_file_configCountOrderByAggregateInput
    _avg?: username_file_configAvgOrderByAggregateInput
    _max?: username_file_configMaxOrderByAggregateInput
    _min?: username_file_configMinOrderByAggregateInput
    _sum?: username_file_configSumOrderByAggregateInput
  }

  export type username_file_configScalarWhereWithAggregatesInput = {
    AND?: username_file_configScalarWhereWithAggregatesInput | username_file_configScalarWhereWithAggregatesInput[]
    OR?: username_file_configScalarWhereWithAggregatesInput[]
    NOT?: username_file_configScalarWhereWithAggregatesInput | username_file_configScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"username_file_config"> | number
    folder_slug?: StringNullableWithAggregatesFilter<"username_file_config"> | string | null
    path?: StringNullableWithAggregatesFilter<"username_file_config"> | string | null
    variable?: StringNullableWithAggregatesFilter<"username_file_config"> | string | null
    config_type?: StringNullableWithAggregatesFilter<"username_file_config"> | string | null
  }

  export type user_settingsWhereInput = {
    AND?: user_settingsWhereInput | user_settingsWhereInput[]
    OR?: user_settingsWhereInput[]
    NOT?: user_settingsWhereInput | user_settingsWhereInput[]
    id?: IntFilter<"user_settings"> | number
    user_id?: StringFilter<"user_settings"> | string
    local_games_dir?: StringFilter<"user_settings"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type user_settingsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    local_games_dir?: SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: user_settingsOrderByRelevanceInput
  }

  export type user_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: string
    AND?: user_settingsWhereInput | user_settingsWhereInput[]
    OR?: user_settingsWhereInput[]
    NOT?: user_settingsWhereInput | user_settingsWhereInput[]
    local_games_dir?: StringFilter<"user_settings"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "user_id">

  export type user_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    local_games_dir?: SortOrder
    _count?: user_settingsCountOrderByAggregateInput
    _avg?: user_settingsAvgOrderByAggregateInput
    _max?: user_settingsMaxOrderByAggregateInput
    _min?: user_settingsMinOrderByAggregateInput
    _sum?: user_settingsSumOrderByAggregateInput
  }

  export type user_settingsScalarWhereWithAggregatesInput = {
    AND?: user_settingsScalarWhereWithAggregatesInput | user_settingsScalarWhereWithAggregatesInput[]
    OR?: user_settingsScalarWhereWithAggregatesInput[]
    NOT?: user_settingsScalarWhereWithAggregatesInput | user_settingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_settings"> | number
    user_id?: StringWithAggregatesFilter<"user_settings"> | string
    local_games_dir?: StringWithAggregatesFilter<"user_settings"> | string
  }

  export type game_sessionWhereInput = {
    AND?: game_sessionWhereInput | game_sessionWhereInput[]
    OR?: game_sessionWhereInput[]
    NOT?: game_sessionWhereInput | game_sessionWhereInput[]
    id?: StringFilter<"game_session"> | string
    user_id?: StringFilter<"game_session"> | string
    game_slug?: StringFilter<"game_session"> | string
    start_time?: DateTimeFilter<"game_session"> | Date | string
    end_time?: DateTimeNullableFilter<"game_session"> | Date | string | null
    total_seconds?: IntNullableFilter<"game_session"> | number | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type game_sessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_slug?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrderInput | SortOrder
    total_seconds?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: game_sessionOrderByRelevanceInput
  }

  export type game_sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: game_sessionWhereInput | game_sessionWhereInput[]
    OR?: game_sessionWhereInput[]
    NOT?: game_sessionWhereInput | game_sessionWhereInput[]
    user_id?: StringFilter<"game_session"> | string
    game_slug?: StringFilter<"game_session"> | string
    start_time?: DateTimeFilter<"game_session"> | Date | string
    end_time?: DateTimeNullableFilter<"game_session"> | Date | string | null
    total_seconds?: IntNullableFilter<"game_session"> | number | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type game_sessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_slug?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrderInput | SortOrder
    total_seconds?: SortOrderInput | SortOrder
    _count?: game_sessionCountOrderByAggregateInput
    _avg?: game_sessionAvgOrderByAggregateInput
    _max?: game_sessionMaxOrderByAggregateInput
    _min?: game_sessionMinOrderByAggregateInput
    _sum?: game_sessionSumOrderByAggregateInput
  }

  export type game_sessionScalarWhereWithAggregatesInput = {
    AND?: game_sessionScalarWhereWithAggregatesInput | game_sessionScalarWhereWithAggregatesInput[]
    OR?: game_sessionScalarWhereWithAggregatesInput[]
    NOT?: game_sessionScalarWhereWithAggregatesInput | game_sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"game_session"> | string
    user_id?: StringWithAggregatesFilter<"game_session"> | string
    game_slug?: StringWithAggregatesFilter<"game_session"> | string
    start_time?: DateTimeWithAggregatesFilter<"game_session"> | Date | string
    end_time?: DateTimeNullableWithAggregatesFilter<"game_session"> | Date | string | null
    total_seconds?: IntNullableWithAggregatesFilter<"game_session"> | number | null
  }

  export type eventWhereInput = {
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    id?: StringFilter<"event"> | string
    name?: StringFilter<"event"> | string
    description?: StringNullableFilter<"event"> | string | null
    url?: StringNullableFilter<"event"> | string | null
    start_time?: DateTimeFilter<"event"> | Date | string
    end_time?: DateTimeFilter<"event"> | Date | string
    created_at?: DateTimeFilter<"event"> | Date | string
    updated_at?: DateTimeFilter<"event"> | Date | string
    created_by?: StringFilter<"event"> | string
    updated_by?: StringFilter<"event"> | string
    location?: StringNullableFilter<"event"> | string | null
    image_url?: StringNullableFilter<"event"> | string | null
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type eventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    location?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    creator?: userOrderByWithRelationInput
    updater?: userOrderByWithRelationInput
    _relevance?: eventOrderByRelevanceInput
  }

  export type eventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    name?: StringFilter<"event"> | string
    description?: StringNullableFilter<"event"> | string | null
    url?: StringNullableFilter<"event"> | string | null
    start_time?: DateTimeFilter<"event"> | Date | string
    end_time?: DateTimeFilter<"event"> | Date | string
    created_at?: DateTimeFilter<"event"> | Date | string
    updated_at?: DateTimeFilter<"event"> | Date | string
    created_by?: StringFilter<"event"> | string
    updated_by?: StringFilter<"event"> | string
    location?: StringNullableFilter<"event"> | string | null
    image_url?: StringNullableFilter<"event"> | string | null
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type eventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    location?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    _count?: eventCountOrderByAggregateInput
    _max?: eventMaxOrderByAggregateInput
    _min?: eventMinOrderByAggregateInput
  }

  export type eventScalarWhereWithAggregatesInput = {
    AND?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    OR?: eventScalarWhereWithAggregatesInput[]
    NOT?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"event"> | string
    name?: StringWithAggregatesFilter<"event"> | string
    description?: StringNullableWithAggregatesFilter<"event"> | string | null
    url?: StringNullableWithAggregatesFilter<"event"> | string | null
    start_time?: DateTimeWithAggregatesFilter<"event"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"event"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"event"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event"> | Date | string
    created_by?: StringWithAggregatesFilter<"event"> | string
    updated_by?: StringWithAggregatesFilter<"event"> | string
    location?: StringNullableWithAggregatesFilter<"event"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"event"> | string | null
  }

  export type global_settingsWhereInput = {
    AND?: global_settingsWhereInput | global_settingsWhereInput[]
    OR?: global_settingsWhereInput[]
    NOT?: global_settingsWhereInput | global_settingsWhereInput[]
    id?: IntFilter<"global_settings"> | number
    key?: StringFilter<"global_settings"> | string
    value?: StringNullableFilter<"global_settings"> | string | null
    created_at?: DateTimeFilter<"global_settings"> | Date | string
    updated_at?: DateTimeFilter<"global_settings"> | Date | string
    created_by?: StringFilter<"global_settings"> | string
    updated_by?: StringFilter<"global_settings"> | string
  }

  export type global_settingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _relevance?: global_settingsOrderByRelevanceInput
  }

  export type global_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: global_settingsWhereInput | global_settingsWhereInput[]
    OR?: global_settingsWhereInput[]
    NOT?: global_settingsWhereInput | global_settingsWhereInput[]
    value?: StringNullableFilter<"global_settings"> | string | null
    created_at?: DateTimeFilter<"global_settings"> | Date | string
    updated_at?: DateTimeFilter<"global_settings"> | Date | string
    created_by?: StringFilter<"global_settings"> | string
    updated_by?: StringFilter<"global_settings"> | string
  }, "id" | "key">

  export type global_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: global_settingsCountOrderByAggregateInput
    _avg?: global_settingsAvgOrderByAggregateInput
    _max?: global_settingsMaxOrderByAggregateInput
    _min?: global_settingsMinOrderByAggregateInput
    _sum?: global_settingsSumOrderByAggregateInput
  }

  export type global_settingsScalarWhereWithAggregatesInput = {
    AND?: global_settingsScalarWhereWithAggregatesInput | global_settingsScalarWhereWithAggregatesInput[]
    OR?: global_settingsScalarWhereWithAggregatesInput[]
    NOT?: global_settingsScalarWhereWithAggregatesInput | global_settingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"global_settings"> | number
    key?: StringWithAggregatesFilter<"global_settings"> | string
    value?: StringNullableWithAggregatesFilter<"global_settings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"global_settings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"global_settings"> | Date | string
    created_by?: StringWithAggregatesFilter<"global_settings"> | string
    updated_by?: StringWithAggregatesFilter<"global_settings"> | string
  }

  export type gameWhereInput = {
    AND?: gameWhereInput | gameWhereInput[]
    OR?: gameWhereInput[]
    NOT?: gameWhereInput | gameWhereInput[]
    id?: StringFilter<"game"> | string
    size_gb?: FloatFilter<"game"> | number
    title?: StringFilter<"game"> | string
    folder_slug?: StringFilter<"game"> | string
    version?: StringNullableFilter<"game"> | string | null
    genres?: StringFilter<"game"> | string
    platforms?: StringNullableFilter<"game"> | string | null
    game_modes?: StringFilter<"game"> | string
    is_featured?: BoolFilter<"game"> | boolean
    date_updated?: DateTimeNullableFilter<"game"> | Date | string | null
    date_added?: DateTimeNullableFilter<"game"> | Date | string | null
    editor_name?: StringNullableFilter<"game"> | string | null
    main_process_name?: StringNullableFilter<"game"> | string | null
    cover?: StringNullableFilter<"game"> | string | null
    logo?: StringNullableFilter<"game"> | string | null
    screenshots?: StringFilter<"game"> | string
    description?: StringNullableFilter<"game"> | string | null
    start_command?: StringNullableFilter<"game"> | string | null
    max_players?: IntFilter<"game"> | number
    use_notifications?: BoolFilter<"game"> | boolean
    created_at?: DateTimeFilter<"game"> | Date | string
    updated_at?: DateTimeFilter<"game"> | Date | string
    created_by?: StringFilter<"game"> | string
    updated_by?: StringFilter<"game"> | string
    createdBy?: XOR<UserScalarRelationFilter, userWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type gameOrderByWithRelationInput = {
    id?: SortOrder
    size_gb?: SortOrder
    title?: SortOrder
    folder_slug?: SortOrder
    version?: SortOrderInput | SortOrder
    genres?: SortOrder
    platforms?: SortOrderInput | SortOrder
    game_modes?: SortOrder
    is_featured?: SortOrder
    date_updated?: SortOrderInput | SortOrder
    date_added?: SortOrderInput | SortOrder
    editor_name?: SortOrderInput | SortOrder
    main_process_name?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    screenshots?: SortOrder
    description?: SortOrderInput | SortOrder
    start_command?: SortOrderInput | SortOrder
    max_players?: SortOrder
    use_notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    createdBy?: userOrderByWithRelationInput
    updatedBy?: userOrderByWithRelationInput
    _relevance?: gameOrderByRelevanceInput
  }

  export type gameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    folder_slug?: string
    AND?: gameWhereInput | gameWhereInput[]
    OR?: gameWhereInput[]
    NOT?: gameWhereInput | gameWhereInput[]
    size_gb?: FloatFilter<"game"> | number
    title?: StringFilter<"game"> | string
    version?: StringNullableFilter<"game"> | string | null
    genres?: StringFilter<"game"> | string
    platforms?: StringNullableFilter<"game"> | string | null
    game_modes?: StringFilter<"game"> | string
    is_featured?: BoolFilter<"game"> | boolean
    date_updated?: DateTimeNullableFilter<"game"> | Date | string | null
    date_added?: DateTimeNullableFilter<"game"> | Date | string | null
    editor_name?: StringNullableFilter<"game"> | string | null
    main_process_name?: StringNullableFilter<"game"> | string | null
    cover?: StringNullableFilter<"game"> | string | null
    logo?: StringNullableFilter<"game"> | string | null
    screenshots?: StringFilter<"game"> | string
    description?: StringNullableFilter<"game"> | string | null
    start_command?: StringNullableFilter<"game"> | string | null
    max_players?: IntFilter<"game"> | number
    use_notifications?: BoolFilter<"game"> | boolean
    created_at?: DateTimeFilter<"game"> | Date | string
    updated_at?: DateTimeFilter<"game"> | Date | string
    created_by?: StringFilter<"game"> | string
    updated_by?: StringFilter<"game"> | string
    createdBy?: XOR<UserScalarRelationFilter, userWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "folder_slug">

  export type gameOrderByWithAggregationInput = {
    id?: SortOrder
    size_gb?: SortOrder
    title?: SortOrder
    folder_slug?: SortOrder
    version?: SortOrderInput | SortOrder
    genres?: SortOrder
    platforms?: SortOrderInput | SortOrder
    game_modes?: SortOrder
    is_featured?: SortOrder
    date_updated?: SortOrderInput | SortOrder
    date_added?: SortOrderInput | SortOrder
    editor_name?: SortOrderInput | SortOrder
    main_process_name?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    screenshots?: SortOrder
    description?: SortOrderInput | SortOrder
    start_command?: SortOrderInput | SortOrder
    max_players?: SortOrder
    use_notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: gameCountOrderByAggregateInput
    _avg?: gameAvgOrderByAggregateInput
    _max?: gameMaxOrderByAggregateInput
    _min?: gameMinOrderByAggregateInput
    _sum?: gameSumOrderByAggregateInput
  }

  export type gameScalarWhereWithAggregatesInput = {
    AND?: gameScalarWhereWithAggregatesInput | gameScalarWhereWithAggregatesInput[]
    OR?: gameScalarWhereWithAggregatesInput[]
    NOT?: gameScalarWhereWithAggregatesInput | gameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"game"> | string
    size_gb?: FloatWithAggregatesFilter<"game"> | number
    title?: StringWithAggregatesFilter<"game"> | string
    folder_slug?: StringWithAggregatesFilter<"game"> | string
    version?: StringNullableWithAggregatesFilter<"game"> | string | null
    genres?: StringWithAggregatesFilter<"game"> | string
    platforms?: StringNullableWithAggregatesFilter<"game"> | string | null
    game_modes?: StringWithAggregatesFilter<"game"> | string
    is_featured?: BoolWithAggregatesFilter<"game"> | boolean
    date_updated?: DateTimeNullableWithAggregatesFilter<"game"> | Date | string | null
    date_added?: DateTimeNullableWithAggregatesFilter<"game"> | Date | string | null
    editor_name?: StringNullableWithAggregatesFilter<"game"> | string | null
    main_process_name?: StringNullableWithAggregatesFilter<"game"> | string | null
    cover?: StringNullableWithAggregatesFilter<"game"> | string | null
    logo?: StringNullableWithAggregatesFilter<"game"> | string | null
    screenshots?: StringWithAggregatesFilter<"game"> | string
    description?: StringNullableWithAggregatesFilter<"game"> | string | null
    start_command?: StringNullableWithAggregatesFilter<"game"> | string | null
    max_players?: IntWithAggregatesFilter<"game"> | number
    use_notifications?: BoolWithAggregatesFilter<"game"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"game"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"game"> | Date | string
    created_by?: StringWithAggregatesFilter<"game"> | string
    updated_by?: StringWithAggregatesFilter<"game"> | string
  }

  export type game_serverWhereInput = {
    AND?: game_serverWhereInput | game_serverWhereInput[]
    OR?: game_serverWhereInput[]
    NOT?: game_serverWhereInput | game_serverWhereInput[]
    id?: IntFilter<"game_server"> | number
    game_slug?: StringFilter<"game_server"> | string
    game_title?: StringFilter<"game_server"> | string
    type?: StringFilter<"game_server"> | string
    port?: IntFilter<"game_server"> | number
    description?: StringNullableFilter<"game_server"> | string | null
    name?: StringFilter<"game_server"> | string
    monitor?: BoolFilter<"game_server"> | boolean
    last_detection_at?: DateTimeNullableFilter<"game_server"> | Date | string | null
    created_at?: DateTimeFilter<"game_server"> | Date | string
    updated_at?: DateTimeFilter<"game_server"> | Date | string
    created_by?: StringFilter<"game_server"> | string
    updated_by?: StringFilter<"game_server"> | string
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type game_serverOrderByWithRelationInput = {
    id?: SortOrder
    game_slug?: SortOrder
    game_title?: SortOrder
    type?: SortOrder
    port?: SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrder
    monitor?: SortOrder
    last_detection_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    creator?: userOrderByWithRelationInput
    updater?: userOrderByWithRelationInput
    _relevance?: game_serverOrderByRelevanceInput
  }

  export type game_serverWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: game_serverWhereInput | game_serverWhereInput[]
    OR?: game_serverWhereInput[]
    NOT?: game_serverWhereInput | game_serverWhereInput[]
    game_slug?: StringFilter<"game_server"> | string
    game_title?: StringFilter<"game_server"> | string
    type?: StringFilter<"game_server"> | string
    port?: IntFilter<"game_server"> | number
    description?: StringNullableFilter<"game_server"> | string | null
    name?: StringFilter<"game_server"> | string
    monitor?: BoolFilter<"game_server"> | boolean
    last_detection_at?: DateTimeNullableFilter<"game_server"> | Date | string | null
    created_at?: DateTimeFilter<"game_server"> | Date | string
    updated_at?: DateTimeFilter<"game_server"> | Date | string
    created_by?: StringFilter<"game_server"> | string
    updated_by?: StringFilter<"game_server"> | string
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type game_serverOrderByWithAggregationInput = {
    id?: SortOrder
    game_slug?: SortOrder
    game_title?: SortOrder
    type?: SortOrder
    port?: SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrder
    monitor?: SortOrder
    last_detection_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: game_serverCountOrderByAggregateInput
    _avg?: game_serverAvgOrderByAggregateInput
    _max?: game_serverMaxOrderByAggregateInput
    _min?: game_serverMinOrderByAggregateInput
    _sum?: game_serverSumOrderByAggregateInput
  }

  export type game_serverScalarWhereWithAggregatesInput = {
    AND?: game_serverScalarWhereWithAggregatesInput | game_serverScalarWhereWithAggregatesInput[]
    OR?: game_serverScalarWhereWithAggregatesInput[]
    NOT?: game_serverScalarWhereWithAggregatesInput | game_serverScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"game_server"> | number
    game_slug?: StringWithAggregatesFilter<"game_server"> | string
    game_title?: StringWithAggregatesFilter<"game_server"> | string
    type?: StringWithAggregatesFilter<"game_server"> | string
    port?: IntWithAggregatesFilter<"game_server"> | number
    description?: StringNullableWithAggregatesFilter<"game_server"> | string | null
    name?: StringWithAggregatesFilter<"game_server"> | string
    monitor?: BoolWithAggregatesFilter<"game_server"> | boolean
    last_detection_at?: DateTimeNullableWithAggregatesFilter<"game_server"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"game_server"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"game_server"> | Date | string
    created_by?: StringWithAggregatesFilter<"game_server"> | string
    updated_by?: StringWithAggregatesFilter<"game_server"> | string
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    name?: StringFilter<"role"> | string
    nameplate_decoration_animated?: StringNullableFilter<"role"> | string | null
    nameplate_decoration_static?: StringNullableFilter<"role"> | string | null
    avatar_decoration_animated?: StringNullableFilter<"role"> | string | null
    avatar_decoration_static?: StringNullableFilter<"role"> | string | null
  }

  export type roleOrderByWithRelationInput = {
    name?: SortOrder
    nameplate_decoration_animated?: SortOrderInput | SortOrder
    nameplate_decoration_static?: SortOrderInput | SortOrder
    avatar_decoration_animated?: SortOrderInput | SortOrder
    avatar_decoration_static?: SortOrderInput | SortOrder
    _relevance?: roleOrderByRelevanceInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    nameplate_decoration_animated?: StringNullableFilter<"role"> | string | null
    nameplate_decoration_static?: StringNullableFilter<"role"> | string | null
    avatar_decoration_animated?: StringNullableFilter<"role"> | string | null
    avatar_decoration_static?: StringNullableFilter<"role"> | string | null
  }, "name" | "name">

  export type roleOrderByWithAggregationInput = {
    name?: SortOrder
    nameplate_decoration_animated?: SortOrderInput | SortOrder
    nameplate_decoration_static?: SortOrderInput | SortOrder
    avatar_decoration_animated?: SortOrderInput | SortOrder
    avatar_decoration_static?: SortOrderInput | SortOrder
    _count?: roleCountOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"role"> | string
    nameplate_decoration_animated?: StringNullableWithAggregatesFilter<"role"> | string | null
    nameplate_decoration_static?: StringNullableWithAggregatesFilter<"role"> | string | null
    avatar_decoration_animated?: StringNullableWithAggregatesFilter<"role"> | string | null
    avatar_decoration_static?: StringNullableWithAggregatesFilter<"role"> | string | null
  }

  export type user_gameWhereInput = {
    AND?: user_gameWhereInput | user_gameWhereInput[]
    OR?: user_gameWhereInput[]
    NOT?: user_gameWhereInput | user_gameWhereInput[]
    user_id?: StringFilter<"user_game"> | string
    game_slug?: StringFilter<"user_game"> | string
    installed_at?: DateTimeNullableFilter<"user_game"> | Date | string | null
  }

  export type user_gameOrderByWithRelationInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    installed_at?: SortOrderInput | SortOrder
    _relevance?: user_gameOrderByRelevanceInput
  }

  export type user_gameWhereUniqueInput = Prisma.AtLeast<{
    user_id_game_slug?: user_gameUser_idGame_slugCompoundUniqueInput
    AND?: user_gameWhereInput | user_gameWhereInput[]
    OR?: user_gameWhereInput[]
    NOT?: user_gameWhereInput | user_gameWhereInput[]
    user_id?: StringFilter<"user_game"> | string
    game_slug?: StringFilter<"user_game"> | string
    installed_at?: DateTimeNullableFilter<"user_game"> | Date | string | null
  }, "user_id_game_slug">

  export type user_gameOrderByWithAggregationInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    installed_at?: SortOrderInput | SortOrder
    _count?: user_gameCountOrderByAggregateInput
    _max?: user_gameMaxOrderByAggregateInput
    _min?: user_gameMinOrderByAggregateInput
  }

  export type user_gameScalarWhereWithAggregatesInput = {
    AND?: user_gameScalarWhereWithAggregatesInput | user_gameScalarWhereWithAggregatesInput[]
    OR?: user_gameScalarWhereWithAggregatesInput[]
    NOT?: user_gameScalarWhereWithAggregatesInput | user_gameScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"user_game"> | string
    game_slug?: StringWithAggregatesFilter<"user_game"> | string
    installed_at?: DateTimeNullableWithAggregatesFilter<"user_game"> | Date | string | null
  }

  export type user_game_favoriteWhereInput = {
    AND?: user_game_favoriteWhereInput | user_game_favoriteWhereInput[]
    OR?: user_game_favoriteWhereInput[]
    NOT?: user_game_favoriteWhereInput | user_game_favoriteWhereInput[]
    user_id?: StringFilter<"user_game_favorite"> | string
    game_slug?: StringFilter<"user_game_favorite"> | string
    addedAt?: DateTimeFilter<"user_game_favorite"> | Date | string
  }

  export type user_game_favoriteOrderByWithRelationInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    addedAt?: SortOrder
    _relevance?: user_game_favoriteOrderByRelevanceInput
  }

  export type user_game_favoriteWhereUniqueInput = Prisma.AtLeast<{
    user_id_game_slug?: user_game_favoriteUser_idGame_slugCompoundUniqueInput
    AND?: user_game_favoriteWhereInput | user_game_favoriteWhereInput[]
    OR?: user_game_favoriteWhereInput[]
    NOT?: user_game_favoriteWhereInput | user_game_favoriteWhereInput[]
    user_id?: StringFilter<"user_game_favorite"> | string
    game_slug?: StringFilter<"user_game_favorite"> | string
    addedAt?: DateTimeFilter<"user_game_favorite"> | Date | string
  }, "user_id_game_slug">

  export type user_game_favoriteOrderByWithAggregationInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    addedAt?: SortOrder
    _count?: user_game_favoriteCountOrderByAggregateInput
    _max?: user_game_favoriteMaxOrderByAggregateInput
    _min?: user_game_favoriteMinOrderByAggregateInput
  }

  export type user_game_favoriteScalarWhereWithAggregatesInput = {
    AND?: user_game_favoriteScalarWhereWithAggregatesInput | user_game_favoriteScalarWhereWithAggregatesInput[]
    OR?: user_game_favoriteScalarWhereWithAggregatesInput[]
    NOT?: user_game_favoriteScalarWhereWithAggregatesInput | user_game_favoriteScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"user_game_favorite"> | string
    game_slug?: StringWithAggregatesFilter<"user_game_favorite"> | string
    addedAt?: DateTimeWithAggregatesFilter<"user_game_favorite"> | Date | string
  }

  export type faqWhereInput = {
    AND?: faqWhereInput | faqWhereInput[]
    OR?: faqWhereInput[]
    NOT?: faqWhereInput | faqWhereInput[]
    id?: IntFilter<"faq"> | number
    question?: StringFilter<"faq"> | string
    answer?: StringFilter<"faq"> | string
    published?: BoolFilter<"faq"> | boolean
    position?: IntFilter<"faq"> | number
    created_at?: DateTimeFilter<"faq"> | Date | string
    updated_at?: DateTimeFilter<"faq"> | Date | string
    created_by?: StringFilter<"faq"> | string
    updated_by?: StringFilter<"faq"> | string
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type faqOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    published?: SortOrder
    position?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    creator?: userOrderByWithRelationInput
    updater?: userOrderByWithRelationInput
    _relevance?: faqOrderByRelevanceInput
  }

  export type faqWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: faqWhereInput | faqWhereInput[]
    OR?: faqWhereInput[]
    NOT?: faqWhereInput | faqWhereInput[]
    question?: StringFilter<"faq"> | string
    answer?: StringFilter<"faq"> | string
    published?: BoolFilter<"faq"> | boolean
    position?: IntFilter<"faq"> | number
    created_at?: DateTimeFilter<"faq"> | Date | string
    updated_at?: DateTimeFilter<"faq"> | Date | string
    created_by?: StringFilter<"faq"> | string
    updated_by?: StringFilter<"faq"> | string
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type faqOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    published?: SortOrder
    position?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    _count?: faqCountOrderByAggregateInput
    _avg?: faqAvgOrderByAggregateInput
    _max?: faqMaxOrderByAggregateInput
    _min?: faqMinOrderByAggregateInput
    _sum?: faqSumOrderByAggregateInput
  }

  export type faqScalarWhereWithAggregatesInput = {
    AND?: faqScalarWhereWithAggregatesInput | faqScalarWhereWithAggregatesInput[]
    OR?: faqScalarWhereWithAggregatesInput[]
    NOT?: faqScalarWhereWithAggregatesInput | faqScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"faq"> | number
    question?: StringWithAggregatesFilter<"faq"> | string
    answer?: StringWithAggregatesFilter<"faq"> | string
    published?: BoolWithAggregatesFilter<"faq"> | boolean
    position?: IntWithAggregatesFilter<"faq"> | number
    created_at?: DateTimeWithAggregatesFilter<"faq"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"faq"> | Date | string
    created_by?: StringWithAggregatesFilter<"faq"> | string
    updated_by?: StringWithAggregatesFilter<"faq"> | string
  }

  export type guildWhereInput = {
    AND?: guildWhereInput | guildWhereInput[]
    OR?: guildWhereInput[]
    NOT?: guildWhereInput | guildWhereInput[]
    id?: StringFilter<"guild"> | string
    name?: StringFilter<"guild"> | string
    slug?: StringFilter<"guild"> | string
    icon?: StringNullableFilter<"guild"> | string | null
    ownerId?: StringFilter<"guild"> | string
    createdAt?: DateTimeFilter<"guild"> | Date | string
    updatedAt?: DateTimeFilter<"guild"> | Date | string
    channels?: ChannelListRelationFilter
    owner?: XOR<UserScalarRelationFilter, userWhereInput>
    members?: Guild_memberListRelationFilter
    room?: RoomListRelationFilter
  }

  export type guildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channels?: channelOrderByRelationAggregateInput
    owner?: userOrderByWithRelationInput
    members?: guild_memberOrderByRelationAggregateInput
    room?: roomOrderByRelationAggregateInput
    _relevance?: guildOrderByRelevanceInput
  }

  export type guildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: guildWhereInput | guildWhereInput[]
    OR?: guildWhereInput[]
    NOT?: guildWhereInput | guildWhereInput[]
    name?: StringFilter<"guild"> | string
    icon?: StringNullableFilter<"guild"> | string | null
    ownerId?: StringFilter<"guild"> | string
    createdAt?: DateTimeFilter<"guild"> | Date | string
    updatedAt?: DateTimeFilter<"guild"> | Date | string
    channels?: ChannelListRelationFilter
    owner?: XOR<UserScalarRelationFilter, userWhereInput>
    members?: Guild_memberListRelationFilter
    room?: RoomListRelationFilter
  }, "id" | "slug">

  export type guildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: guildCountOrderByAggregateInput
    _max?: guildMaxOrderByAggregateInput
    _min?: guildMinOrderByAggregateInput
  }

  export type guildScalarWhereWithAggregatesInput = {
    AND?: guildScalarWhereWithAggregatesInput | guildScalarWhereWithAggregatesInput[]
    OR?: guildScalarWhereWithAggregatesInput[]
    NOT?: guildScalarWhereWithAggregatesInput | guildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"guild"> | string
    name?: StringWithAggregatesFilter<"guild"> | string
    slug?: StringWithAggregatesFilter<"guild"> | string
    icon?: StringNullableWithAggregatesFilter<"guild"> | string | null
    ownerId?: StringWithAggregatesFilter<"guild"> | string
    createdAt?: DateTimeWithAggregatesFilter<"guild"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"guild"> | Date | string
  }

  export type guild_memberWhereInput = {
    AND?: guild_memberWhereInput | guild_memberWhereInput[]
    OR?: guild_memberWhereInput[]
    NOT?: guild_memberWhereInput | guild_memberWhereInput[]
    id?: StringFilter<"guild_member"> | string
    guildId?: StringFilter<"guild_member"> | string
    userId?: StringFilter<"guild_member"> | string
    nickname?: StringNullableFilter<"guild_member"> | string | null
    roles?: StringNullableFilter<"guild_member"> | string | null
    joinedAt?: DateTimeFilter<"guild_member"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, guildWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type guild_memberOrderByWithRelationInput = {
    id?: SortOrder
    guildId?: SortOrder
    userId?: SortOrder
    nickname?: SortOrderInput | SortOrder
    roles?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    guild?: guildOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: guild_memberOrderByRelevanceInput
  }

  export type guild_memberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guildId_userId?: guild_memberGuildIdUserIdCompoundUniqueInput
    AND?: guild_memberWhereInput | guild_memberWhereInput[]
    OR?: guild_memberWhereInput[]
    NOT?: guild_memberWhereInput | guild_memberWhereInput[]
    guildId?: StringFilter<"guild_member"> | string
    userId?: StringFilter<"guild_member"> | string
    nickname?: StringNullableFilter<"guild_member"> | string | null
    roles?: StringNullableFilter<"guild_member"> | string | null
    joinedAt?: DateTimeFilter<"guild_member"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, guildWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "guildId_userId">

  export type guild_memberOrderByWithAggregationInput = {
    id?: SortOrder
    guildId?: SortOrder
    userId?: SortOrder
    nickname?: SortOrderInput | SortOrder
    roles?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: guild_memberCountOrderByAggregateInput
    _max?: guild_memberMaxOrderByAggregateInput
    _min?: guild_memberMinOrderByAggregateInput
  }

  export type guild_memberScalarWhereWithAggregatesInput = {
    AND?: guild_memberScalarWhereWithAggregatesInput | guild_memberScalarWhereWithAggregatesInput[]
    OR?: guild_memberScalarWhereWithAggregatesInput[]
    NOT?: guild_memberScalarWhereWithAggregatesInput | guild_memberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"guild_member"> | string
    guildId?: StringWithAggregatesFilter<"guild_member"> | string
    userId?: StringWithAggregatesFilter<"guild_member"> | string
    nickname?: StringNullableWithAggregatesFilter<"guild_member"> | string | null
    roles?: StringNullableWithAggregatesFilter<"guild_member"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"guild_member"> | Date | string
  }

  export type channelWhereInput = {
    AND?: channelWhereInput | channelWhereInput[]
    OR?: channelWhereInput[]
    NOT?: channelWhereInput | channelWhereInput[]
    id?: StringFilter<"channel"> | string
    guildId?: StringFilter<"channel"> | string
    name?: StringFilter<"channel"> | string
    slug?: StringFilter<"channel"> | string
    type?: Enumchannel_typeFilter<"channel"> | $Enums.channel_type
    topic?: StringNullableFilter<"channel"> | string | null
    position?: IntFilter<"channel"> | number
    isPrivate?: BoolFilter<"channel"> | boolean
    parentId?: StringNullableFilter<"channel"> | string | null
    createdAt?: DateTimeFilter<"channel"> | Date | string
    updatedAt?: DateTimeFilter<"channel"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, guildWhereInput>
    parent?: XOR<ChannelNullableScalarRelationFilter, channelWhereInput> | null
    children?: ChannelListRelationFilter
    members?: Channel_memberListRelationFilter
    room?: XOR<RoomNullableScalarRelationFilter, roomWhereInput> | null
  }

  export type channelOrderByWithRelationInput = {
    id?: SortOrder
    guildId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    topic?: SortOrderInput | SortOrder
    position?: SortOrder
    isPrivate?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    guild?: guildOrderByWithRelationInput
    parent?: channelOrderByWithRelationInput
    children?: channelOrderByRelationAggregateInput
    members?: channel_memberOrderByRelationAggregateInput
    room?: roomOrderByWithRelationInput
    _relevance?: channelOrderByRelevanceInput
  }

  export type channelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guildId_slug?: channelGuildIdSlugCompoundUniqueInput
    AND?: channelWhereInput | channelWhereInput[]
    OR?: channelWhereInput[]
    NOT?: channelWhereInput | channelWhereInput[]
    guildId?: StringFilter<"channel"> | string
    name?: StringFilter<"channel"> | string
    slug?: StringFilter<"channel"> | string
    type?: Enumchannel_typeFilter<"channel"> | $Enums.channel_type
    topic?: StringNullableFilter<"channel"> | string | null
    position?: IntFilter<"channel"> | number
    isPrivate?: BoolFilter<"channel"> | boolean
    parentId?: StringNullableFilter<"channel"> | string | null
    createdAt?: DateTimeFilter<"channel"> | Date | string
    updatedAt?: DateTimeFilter<"channel"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, guildWhereInput>
    parent?: XOR<ChannelNullableScalarRelationFilter, channelWhereInput> | null
    children?: ChannelListRelationFilter
    members?: Channel_memberListRelationFilter
    room?: XOR<RoomNullableScalarRelationFilter, roomWhereInput> | null
  }, "id" | "guildId_slug">

  export type channelOrderByWithAggregationInput = {
    id?: SortOrder
    guildId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    topic?: SortOrderInput | SortOrder
    position?: SortOrder
    isPrivate?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: channelCountOrderByAggregateInput
    _avg?: channelAvgOrderByAggregateInput
    _max?: channelMaxOrderByAggregateInput
    _min?: channelMinOrderByAggregateInput
    _sum?: channelSumOrderByAggregateInput
  }

  export type channelScalarWhereWithAggregatesInput = {
    AND?: channelScalarWhereWithAggregatesInput | channelScalarWhereWithAggregatesInput[]
    OR?: channelScalarWhereWithAggregatesInput[]
    NOT?: channelScalarWhereWithAggregatesInput | channelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"channel"> | string
    guildId?: StringWithAggregatesFilter<"channel"> | string
    name?: StringWithAggregatesFilter<"channel"> | string
    slug?: StringWithAggregatesFilter<"channel"> | string
    type?: Enumchannel_typeWithAggregatesFilter<"channel"> | $Enums.channel_type
    topic?: StringNullableWithAggregatesFilter<"channel"> | string | null
    position?: IntWithAggregatesFilter<"channel"> | number
    isPrivate?: BoolWithAggregatesFilter<"channel"> | boolean
    parentId?: StringNullableWithAggregatesFilter<"channel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"channel"> | Date | string
  }

  export type channel_memberWhereInput = {
    AND?: channel_memberWhereInput | channel_memberWhereInput[]
    OR?: channel_memberWhereInput[]
    NOT?: channel_memberWhereInput | channel_memberWhereInput[]
    channelId?: StringFilter<"channel_member"> | string
    userId?: StringFilter<"channel_member"> | string
    addedAt?: DateTimeFilter<"channel_member"> | Date | string
    channel?: XOR<ChannelScalarRelationFilter, channelWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type channel_memberOrderByWithRelationInput = {
    channelId?: SortOrder
    userId?: SortOrder
    addedAt?: SortOrder
    channel?: channelOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: channel_memberOrderByRelevanceInput
  }

  export type channel_memberWhereUniqueInput = Prisma.AtLeast<{
    channelId_userId?: channel_memberChannelIdUserIdCompoundUniqueInput
    AND?: channel_memberWhereInput | channel_memberWhereInput[]
    OR?: channel_memberWhereInput[]
    NOT?: channel_memberWhereInput | channel_memberWhereInput[]
    channelId?: StringFilter<"channel_member"> | string
    userId?: StringFilter<"channel_member"> | string
    addedAt?: DateTimeFilter<"channel_member"> | Date | string
    channel?: XOR<ChannelScalarRelationFilter, channelWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "channelId_userId">

  export type channel_memberOrderByWithAggregationInput = {
    channelId?: SortOrder
    userId?: SortOrder
    addedAt?: SortOrder
    _count?: channel_memberCountOrderByAggregateInput
    _max?: channel_memberMaxOrderByAggregateInput
    _min?: channel_memberMinOrderByAggregateInput
  }

  export type channel_memberScalarWhereWithAggregatesInput = {
    AND?: channel_memberScalarWhereWithAggregatesInput | channel_memberScalarWhereWithAggregatesInput[]
    OR?: channel_memberScalarWhereWithAggregatesInput[]
    NOT?: channel_memberScalarWhereWithAggregatesInput | channel_memberScalarWhereWithAggregatesInput[]
    channelId?: StringWithAggregatesFilter<"channel_member"> | string
    userId?: StringWithAggregatesFilter<"channel_member"> | string
    addedAt?: DateTimeWithAggregatesFilter<"channel_member"> | Date | string
  }

  export type roomWhereInput = {
    AND?: roomWhereInput | roomWhereInput[]
    OR?: roomWhereInput[]
    NOT?: roomWhereInput | roomWhereInput[]
    id?: StringFilter<"room"> | string
    type?: Enumroom_typeFilter<"room"> | $Enums.room_type
    name?: StringNullableFilter<"room"> | string | null
    ownerId?: StringNullableFilter<"room"> | string | null
    guildId?: StringNullableFilter<"room"> | string | null
    channelId?: StringNullableFilter<"room"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"room"> | Date | string | null
    createdAt?: DateTimeFilter<"room"> | Date | string
    updatedAt?: DateTimeFilter<"room"> | Date | string
    dm_pair_unique?: Dm_pair_uniqueListRelationFilter
    messages?: MessageListRelationFilter
    channel?: XOR<ChannelNullableScalarRelationFilter, channelWhereInput> | null
    guild?: XOR<GuildNullableScalarRelationFilter, guildWhereInput> | null
    owner?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    participants?: Room_participantListRelationFilter
    room_view?: Room_viewListRelationFilter
  }

  export type roomOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    guildId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dm_pair_unique?: dm_pair_uniqueOrderByRelationAggregateInput
    messages?: messageOrderByRelationAggregateInput
    channel?: channelOrderByWithRelationInput
    guild?: guildOrderByWithRelationInput
    owner?: userOrderByWithRelationInput
    participants?: room_participantOrderByRelationAggregateInput
    room_view?: room_viewOrderByRelationAggregateInput
    _relevance?: roomOrderByRelevanceInput
  }

  export type roomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId?: string
    AND?: roomWhereInput | roomWhereInput[]
    OR?: roomWhereInput[]
    NOT?: roomWhereInput | roomWhereInput[]
    type?: Enumroom_typeFilter<"room"> | $Enums.room_type
    name?: StringNullableFilter<"room"> | string | null
    ownerId?: StringNullableFilter<"room"> | string | null
    guildId?: StringNullableFilter<"room"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"room"> | Date | string | null
    createdAt?: DateTimeFilter<"room"> | Date | string
    updatedAt?: DateTimeFilter<"room"> | Date | string
    dm_pair_unique?: Dm_pair_uniqueListRelationFilter
    messages?: MessageListRelationFilter
    channel?: XOR<ChannelNullableScalarRelationFilter, channelWhereInput> | null
    guild?: XOR<GuildNullableScalarRelationFilter, guildWhereInput> | null
    owner?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    participants?: Room_participantListRelationFilter
    room_view?: Room_viewListRelationFilter
  }, "id" | "channelId">

  export type roomOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    guildId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: roomCountOrderByAggregateInput
    _max?: roomMaxOrderByAggregateInput
    _min?: roomMinOrderByAggregateInput
  }

  export type roomScalarWhereWithAggregatesInput = {
    AND?: roomScalarWhereWithAggregatesInput | roomScalarWhereWithAggregatesInput[]
    OR?: roomScalarWhereWithAggregatesInput[]
    NOT?: roomScalarWhereWithAggregatesInput | roomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"room"> | string
    type?: Enumroom_typeWithAggregatesFilter<"room"> | $Enums.room_type
    name?: StringNullableWithAggregatesFilter<"room"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"room"> | string | null
    guildId?: StringNullableWithAggregatesFilter<"room"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"room"> | string | null
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"room"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"room"> | Date | string
  }

  export type room_participantWhereInput = {
    AND?: room_participantWhereInput | room_participantWhereInput[]
    OR?: room_participantWhereInput[]
    NOT?: room_participantWhereInput | room_participantWhereInput[]
    roomId?: StringFilter<"room_participant"> | string
    userId?: StringFilter<"room_participant"> | string
    joinedAt?: DateTimeFilter<"room_participant"> | Date | string
    isMuted?: BoolFilter<"room_participant"> | boolean
    isPinned?: BoolFilter<"room_participant"> | boolean
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type room_participantOrderByWithRelationInput = {
    roomId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isMuted?: SortOrder
    isPinned?: SortOrder
    room?: roomOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: room_participantOrderByRelevanceInput
  }

  export type room_participantWhereUniqueInput = Prisma.AtLeast<{
    roomId_userId?: room_participantRoomIdUserIdCompoundUniqueInput
    AND?: room_participantWhereInput | room_participantWhereInput[]
    OR?: room_participantWhereInput[]
    NOT?: room_participantWhereInput | room_participantWhereInput[]
    roomId?: StringFilter<"room_participant"> | string
    userId?: StringFilter<"room_participant"> | string
    joinedAt?: DateTimeFilter<"room_participant"> | Date | string
    isMuted?: BoolFilter<"room_participant"> | boolean
    isPinned?: BoolFilter<"room_participant"> | boolean
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "roomId_userId">

  export type room_participantOrderByWithAggregationInput = {
    roomId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isMuted?: SortOrder
    isPinned?: SortOrder
    _count?: room_participantCountOrderByAggregateInput
    _max?: room_participantMaxOrderByAggregateInput
    _min?: room_participantMinOrderByAggregateInput
  }

  export type room_participantScalarWhereWithAggregatesInput = {
    AND?: room_participantScalarWhereWithAggregatesInput | room_participantScalarWhereWithAggregatesInput[]
    OR?: room_participantScalarWhereWithAggregatesInput[]
    NOT?: room_participantScalarWhereWithAggregatesInput | room_participantScalarWhereWithAggregatesInput[]
    roomId?: StringWithAggregatesFilter<"room_participant"> | string
    userId?: StringWithAggregatesFilter<"room_participant"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"room_participant"> | Date | string
    isMuted?: BoolWithAggregatesFilter<"room_participant"> | boolean
    isPinned?: BoolWithAggregatesFilter<"room_participant"> | boolean
  }

  export type dm_pair_uniqueWhereInput = {
    AND?: dm_pair_uniqueWhereInput | dm_pair_uniqueWhereInput[]
    OR?: dm_pair_uniqueWhereInput[]
    NOT?: dm_pair_uniqueWhereInput | dm_pair_uniqueWhereInput[]
    id?: StringFilter<"dm_pair_unique"> | string
    userA?: StringFilter<"dm_pair_unique"> | string
    userB?: StringFilter<"dm_pair_unique"> | string
    roomId?: StringFilter<"dm_pair_unique"> | string
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
  }

  export type dm_pair_uniqueOrderByWithRelationInput = {
    id?: SortOrder
    userA?: SortOrder
    userB?: SortOrder
    roomId?: SortOrder
    room?: roomOrderByWithRelationInput
    _relevance?: dm_pair_uniqueOrderByRelevanceInput
  }

  export type dm_pair_uniqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userA_userB?: dm_pair_uniqueUserAUserBCompoundUniqueInput
    AND?: dm_pair_uniqueWhereInput | dm_pair_uniqueWhereInput[]
    OR?: dm_pair_uniqueWhereInput[]
    NOT?: dm_pair_uniqueWhereInput | dm_pair_uniqueWhereInput[]
    userA?: StringFilter<"dm_pair_unique"> | string
    userB?: StringFilter<"dm_pair_unique"> | string
    roomId?: StringFilter<"dm_pair_unique"> | string
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
  }, "id" | "userA_userB">

  export type dm_pair_uniqueOrderByWithAggregationInput = {
    id?: SortOrder
    userA?: SortOrder
    userB?: SortOrder
    roomId?: SortOrder
    _count?: dm_pair_uniqueCountOrderByAggregateInput
    _max?: dm_pair_uniqueMaxOrderByAggregateInput
    _min?: dm_pair_uniqueMinOrderByAggregateInput
  }

  export type dm_pair_uniqueScalarWhereWithAggregatesInput = {
    AND?: dm_pair_uniqueScalarWhereWithAggregatesInput | dm_pair_uniqueScalarWhereWithAggregatesInput[]
    OR?: dm_pair_uniqueScalarWhereWithAggregatesInput[]
    NOT?: dm_pair_uniqueScalarWhereWithAggregatesInput | dm_pair_uniqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"dm_pair_unique"> | string
    userA?: StringWithAggregatesFilter<"dm_pair_unique"> | string
    userB?: StringWithAggregatesFilter<"dm_pair_unique"> | string
    roomId?: StringWithAggregatesFilter<"dm_pair_unique"> | string
  }

  export type messageWhereInput = {
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    id?: StringFilter<"message"> | string
    roomId?: StringFilter<"message"> | string
    authorId?: StringFilter<"message"> | string
    type?: Enummessage_typeFilter<"message"> | $Enums.message_type
    content?: StringNullableFilter<"message"> | string | null
    attachments?: StringNullableFilter<"message"> | string | null
    createdAt?: DateTimeFilter<"message"> | Date | string
    editedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, userWhereInput>
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    reactions?: Message_reactionListRelationFilter
    reads?: Message_readListRelationFilter
  }

  export type messageOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    author?: userOrderByWithRelationInput
    room?: roomOrderByWithRelationInput
    reactions?: message_reactionOrderByRelationAggregateInput
    reads?: message_readOrderByRelationAggregateInput
    _relevance?: messageOrderByRelevanceInput
  }

  export type messageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    roomId?: StringFilter<"message"> | string
    authorId?: StringFilter<"message"> | string
    type?: Enummessage_typeFilter<"message"> | $Enums.message_type
    content?: StringNullableFilter<"message"> | string | null
    attachments?: StringNullableFilter<"message"> | string | null
    createdAt?: DateTimeFilter<"message"> | Date | string
    editedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, userWhereInput>
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    reactions?: Message_reactionListRelationFilter
    reads?: Message_readListRelationFilter
  }, "id">

  export type messageOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: messageCountOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    OR?: messageScalarWhereWithAggregatesInput[]
    NOT?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"message"> | string
    roomId?: StringWithAggregatesFilter<"message"> | string
    authorId?: StringWithAggregatesFilter<"message"> | string
    type?: Enummessage_typeWithAggregatesFilter<"message"> | $Enums.message_type
    content?: StringNullableWithAggregatesFilter<"message"> | string | null
    attachments?: StringNullableWithAggregatesFilter<"message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"message"> | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter<"message"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"message"> | Date | string | null
  }

  export type message_readWhereInput = {
    AND?: message_readWhereInput | message_readWhereInput[]
    OR?: message_readWhereInput[]
    NOT?: message_readWhereInput | message_readWhereInput[]
    messageId?: StringFilter<"message_read"> | string
    userId?: StringFilter<"message_read"> | string
    readAt?: DateTimeFilter<"message_read"> | Date | string
    message?: XOR<MessageScalarRelationFilter, messageWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type message_readOrderByWithRelationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: messageOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: message_readOrderByRelevanceInput
  }

  export type message_readWhereUniqueInput = Prisma.AtLeast<{
    messageId_userId?: message_readMessageIdUserIdCompoundUniqueInput
    AND?: message_readWhereInput | message_readWhereInput[]
    OR?: message_readWhereInput[]
    NOT?: message_readWhereInput | message_readWhereInput[]
    messageId?: StringFilter<"message_read"> | string
    userId?: StringFilter<"message_read"> | string
    readAt?: DateTimeFilter<"message_read"> | Date | string
    message?: XOR<MessageScalarRelationFilter, messageWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "messageId_userId">

  export type message_readOrderByWithAggregationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: message_readCountOrderByAggregateInput
    _max?: message_readMaxOrderByAggregateInput
    _min?: message_readMinOrderByAggregateInput
  }

  export type message_readScalarWhereWithAggregatesInput = {
    AND?: message_readScalarWhereWithAggregatesInput | message_readScalarWhereWithAggregatesInput[]
    OR?: message_readScalarWhereWithAggregatesInput[]
    NOT?: message_readScalarWhereWithAggregatesInput | message_readScalarWhereWithAggregatesInput[]
    messageId?: StringWithAggregatesFilter<"message_read"> | string
    userId?: StringWithAggregatesFilter<"message_read"> | string
    readAt?: DateTimeWithAggregatesFilter<"message_read"> | Date | string
  }

  export type message_reactionWhereInput = {
    AND?: message_reactionWhereInput | message_reactionWhereInput[]
    OR?: message_reactionWhereInput[]
    NOT?: message_reactionWhereInput | message_reactionWhereInput[]
    messageId?: StringFilter<"message_reaction"> | string
    userId?: StringFilter<"message_reaction"> | string
    emoji?: StringFilter<"message_reaction"> | string
    createdAt?: DateTimeFilter<"message_reaction"> | Date | string
    message?: XOR<MessageScalarRelationFilter, messageWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type message_reactionOrderByWithRelationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    message?: messageOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: message_reactionOrderByRelevanceInput
  }

  export type message_reactionWhereUniqueInput = Prisma.AtLeast<{
    messageId_userId_emoji?: message_reactionMessageIdUserIdEmojiCompoundUniqueInput
    AND?: message_reactionWhereInput | message_reactionWhereInput[]
    OR?: message_reactionWhereInput[]
    NOT?: message_reactionWhereInput | message_reactionWhereInput[]
    messageId?: StringFilter<"message_reaction"> | string
    userId?: StringFilter<"message_reaction"> | string
    emoji?: StringFilter<"message_reaction"> | string
    createdAt?: DateTimeFilter<"message_reaction"> | Date | string
    message?: XOR<MessageScalarRelationFilter, messageWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "messageId_userId_emoji">

  export type message_reactionOrderByWithAggregationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    _count?: message_reactionCountOrderByAggregateInput
    _max?: message_reactionMaxOrderByAggregateInput
    _min?: message_reactionMinOrderByAggregateInput
  }

  export type message_reactionScalarWhereWithAggregatesInput = {
    AND?: message_reactionScalarWhereWithAggregatesInput | message_reactionScalarWhereWithAggregatesInput[]
    OR?: message_reactionScalarWhereWithAggregatesInput[]
    NOT?: message_reactionScalarWhereWithAggregatesInput | message_reactionScalarWhereWithAggregatesInput[]
    messageId?: StringWithAggregatesFilter<"message_reaction"> | string
    userId?: StringWithAggregatesFilter<"message_reaction"> | string
    emoji?: StringWithAggregatesFilter<"message_reaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"message_reaction"> | Date | string
  }

  export type room_viewWhereInput = {
    AND?: room_viewWhereInput | room_viewWhereInput[]
    OR?: room_viewWhereInput[]
    NOT?: room_viewWhereInput | room_viewWhereInput[]
    roomId?: StringFilter<"room_view"> | string
    userId?: StringFilter<"room_view"> | string
    lastSeenAt?: DateTimeFilter<"room_view"> | Date | string
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type room_viewOrderByWithRelationInput = {
    roomId?: SortOrder
    userId?: SortOrder
    lastSeenAt?: SortOrder
    room?: roomOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: room_viewOrderByRelevanceInput
  }

  export type room_viewWhereUniqueInput = Prisma.AtLeast<{
    roomId_userId?: room_viewRoomIdUserIdCompoundUniqueInput
    AND?: room_viewWhereInput | room_viewWhereInput[]
    OR?: room_viewWhereInput[]
    NOT?: room_viewWhereInput | room_viewWhereInput[]
    roomId?: StringFilter<"room_view"> | string
    userId?: StringFilter<"room_view"> | string
    lastSeenAt?: DateTimeFilter<"room_view"> | Date | string
    room?: XOR<RoomScalarRelationFilter, roomWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "roomId_userId">

  export type room_viewOrderByWithAggregationInput = {
    roomId?: SortOrder
    userId?: SortOrder
    lastSeenAt?: SortOrder
    _count?: room_viewCountOrderByAggregateInput
    _max?: room_viewMaxOrderByAggregateInput
    _min?: room_viewMinOrderByAggregateInput
  }

  export type room_viewScalarWhereWithAggregatesInput = {
    AND?: room_viewScalarWhereWithAggregatesInput | room_viewScalarWhereWithAggregatesInput[]
    OR?: room_viewScalarWhereWithAggregatesInput[]
    NOT?: room_viewScalarWhereWithAggregatesInput | room_viewScalarWhereWithAggregatesInput[]
    roomId?: StringWithAggregatesFilter<"room_view"> | string
    userId?: StringWithAggregatesFilter<"room_view"> | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"room_view"> | Date | string
  }

  export type EFMigrationsHistoryWhereInput = {
    AND?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    OR?: EFMigrationsHistoryWhereInput[]
    NOT?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    MigrationId?: StringFilter<"EFMigrationsHistory"> | string
    ProductVersion?: StringFilter<"EFMigrationsHistory"> | string
  }

  export type EFMigrationsHistoryOrderByWithRelationInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
    _relevance?: EFMigrationsHistoryOrderByRelevanceInput
  }

  export type EFMigrationsHistoryWhereUniqueInput = Prisma.AtLeast<{
    MigrationId?: string
    AND?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    OR?: EFMigrationsHistoryWhereInput[]
    NOT?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    ProductVersion?: StringFilter<"EFMigrationsHistory"> | string
  }, "MigrationId">

  export type EFMigrationsHistoryOrderByWithAggregationInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
    _count?: EFMigrationsHistoryCountOrderByAggregateInput
    _max?: EFMigrationsHistoryMaxOrderByAggregateInput
    _min?: EFMigrationsHistoryMinOrderByAggregateInput
  }

  export type EFMigrationsHistoryScalarWhereWithAggregatesInput = {
    AND?: EFMigrationsHistoryScalarWhereWithAggregatesInput | EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    OR?: EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    NOT?: EFMigrationsHistoryScalarWhereWithAggregatesInput | EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    MigrationId?: StringWithAggregatesFilter<"EFMigrationsHistory"> | string
    ProductVersion?: StringWithAggregatesFilter<"EFMigrationsHistory"> | string
  }

  export type editionWhereInput = {
    AND?: editionWhereInput | editionWhereInput[]
    OR?: editionWhereInput[]
    NOT?: editionWhereInput | editionWhereInput[]
    id?: StringFilter<"edition"> | string
    name?: StringFilter<"edition"> | string
    description?: StringNullableFilter<"edition"> | string | null
    startDate?: DateTimeFilter<"edition"> | Date | string
    endDate?: DateTimeFilter<"edition"> | Date | string
    createdAt?: DateTimeFilter<"edition"> | Date | string
    updatedAt?: DateTimeFilter<"edition"> | Date | string
    createdBy?: StringFilter<"edition"> | string
    updatedBy?: StringFilter<"edition"> | string
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
    rooms?: Edition_roomListRelationFilter
  }

  export type editionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    creator?: userOrderByWithRelationInput
    updater?: userOrderByWithRelationInput
    rooms?: edition_roomOrderByRelationAggregateInput
    _relevance?: editionOrderByRelevanceInput
  }

  export type editionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: editionWhereInput | editionWhereInput[]
    OR?: editionWhereInput[]
    NOT?: editionWhereInput | editionWhereInput[]
    name?: StringFilter<"edition"> | string
    description?: StringNullableFilter<"edition"> | string | null
    startDate?: DateTimeFilter<"edition"> | Date | string
    endDate?: DateTimeFilter<"edition"> | Date | string
    createdAt?: DateTimeFilter<"edition"> | Date | string
    updatedAt?: DateTimeFilter<"edition"> | Date | string
    createdBy?: StringFilter<"edition"> | string
    updatedBy?: StringFilter<"edition"> | string
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    updater?: XOR<UserScalarRelationFilter, userWhereInput>
    rooms?: Edition_roomListRelationFilter
  }, "id">

  export type editionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    _count?: editionCountOrderByAggregateInput
    _max?: editionMaxOrderByAggregateInput
    _min?: editionMinOrderByAggregateInput
  }

  export type editionScalarWhereWithAggregatesInput = {
    AND?: editionScalarWhereWithAggregatesInput | editionScalarWhereWithAggregatesInput[]
    OR?: editionScalarWhereWithAggregatesInput[]
    NOT?: editionScalarWhereWithAggregatesInput | editionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"edition"> | string
    name?: StringWithAggregatesFilter<"edition"> | string
    description?: StringNullableWithAggregatesFilter<"edition"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"edition"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"edition"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"edition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"edition"> | Date | string
    createdBy?: StringWithAggregatesFilter<"edition"> | string
    updatedBy?: StringWithAggregatesFilter<"edition"> | string
  }

  export type edition_roomWhereInput = {
    AND?: edition_roomWhereInput | edition_roomWhereInput[]
    OR?: edition_roomWhereInput[]
    NOT?: edition_roomWhereInput | edition_roomWhereInput[]
    id?: StringFilter<"edition_room"> | string
    editionId?: StringFilter<"edition_room"> | string
    name?: StringFilter<"edition_room"> | string
    createdAt?: DateTimeFilter<"edition_room"> | Date | string
    updatedAt?: DateTimeFilter<"edition_room"> | Date | string
    edition?: XOR<EditionScalarRelationFilter, editionWhereInput>
    tables?: TableListRelationFilter
  }

  export type edition_roomOrderByWithRelationInput = {
    id?: SortOrder
    editionId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    edition?: editionOrderByWithRelationInput
    tables?: tableOrderByRelationAggregateInput
    _relevance?: edition_roomOrderByRelevanceInput
  }

  export type edition_roomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    editionId_name?: edition_roomEditionIdNameCompoundUniqueInput
    AND?: edition_roomWhereInput | edition_roomWhereInput[]
    OR?: edition_roomWhereInput[]
    NOT?: edition_roomWhereInput | edition_roomWhereInput[]
    editionId?: StringFilter<"edition_room"> | string
    name?: StringFilter<"edition_room"> | string
    createdAt?: DateTimeFilter<"edition_room"> | Date | string
    updatedAt?: DateTimeFilter<"edition_room"> | Date | string
    edition?: XOR<EditionScalarRelationFilter, editionWhereInput>
    tables?: TableListRelationFilter
  }, "id" | "editionId_name">

  export type edition_roomOrderByWithAggregationInput = {
    id?: SortOrder
    editionId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: edition_roomCountOrderByAggregateInput
    _max?: edition_roomMaxOrderByAggregateInput
    _min?: edition_roomMinOrderByAggregateInput
  }

  export type edition_roomScalarWhereWithAggregatesInput = {
    AND?: edition_roomScalarWhereWithAggregatesInput | edition_roomScalarWhereWithAggregatesInput[]
    OR?: edition_roomScalarWhereWithAggregatesInput[]
    NOT?: edition_roomScalarWhereWithAggregatesInput | edition_roomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"edition_room"> | string
    editionId?: StringWithAggregatesFilter<"edition_room"> | string
    name?: StringWithAggregatesFilter<"edition_room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"edition_room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"edition_room"> | Date | string
  }

  export type tableWhereInput = {
    AND?: tableWhereInput | tableWhereInput[]
    OR?: tableWhereInput[]
    NOT?: tableWhereInput | tableWhereInput[]
    id?: StringFilter<"table"> | string
    roomId?: StringFilter<"table"> | string
    name?: StringFilter<"table"> | string
    positionX?: IntFilter<"table"> | number
    positionY?: IntFilter<"table"> | number
    width?: IntFilter<"table"> | number
    height?: IntFilter<"table"> | number
    capacity?: IntFilter<"table"> | number
    createdAt?: DateTimeFilter<"table"> | Date | string
    updatedAt?: DateTimeFilter<"table"> | Date | string
    room?: XOR<Edition_roomScalarRelationFilter, edition_roomWhereInput>
    seats?: Table_seatListRelationFilter
  }

  export type tableOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: edition_roomOrderByWithRelationInput
    seats?: table_seatOrderByRelationAggregateInput
    _relevance?: tableOrderByRelevanceInput
  }

  export type tableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tableWhereInput | tableWhereInput[]
    OR?: tableWhereInput[]
    NOT?: tableWhereInput | tableWhereInput[]
    roomId?: StringFilter<"table"> | string
    name?: StringFilter<"table"> | string
    positionX?: IntFilter<"table"> | number
    positionY?: IntFilter<"table"> | number
    width?: IntFilter<"table"> | number
    height?: IntFilter<"table"> | number
    capacity?: IntFilter<"table"> | number
    createdAt?: DateTimeFilter<"table"> | Date | string
    updatedAt?: DateTimeFilter<"table"> | Date | string
    room?: XOR<Edition_roomScalarRelationFilter, edition_roomWhereInput>
    seats?: Table_seatListRelationFilter
  }, "id">

  export type tableOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tableCountOrderByAggregateInput
    _avg?: tableAvgOrderByAggregateInput
    _max?: tableMaxOrderByAggregateInput
    _min?: tableMinOrderByAggregateInput
    _sum?: tableSumOrderByAggregateInput
  }

  export type tableScalarWhereWithAggregatesInput = {
    AND?: tableScalarWhereWithAggregatesInput | tableScalarWhereWithAggregatesInput[]
    OR?: tableScalarWhereWithAggregatesInput[]
    NOT?: tableScalarWhereWithAggregatesInput | tableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"table"> | string
    roomId?: StringWithAggregatesFilter<"table"> | string
    name?: StringWithAggregatesFilter<"table"> | string
    positionX?: IntWithAggregatesFilter<"table"> | number
    positionY?: IntWithAggregatesFilter<"table"> | number
    width?: IntWithAggregatesFilter<"table"> | number
    height?: IntWithAggregatesFilter<"table"> | number
    capacity?: IntWithAggregatesFilter<"table"> | number
    createdAt?: DateTimeWithAggregatesFilter<"table"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"table"> | Date | string
  }

  export type table_seatWhereInput = {
    AND?: table_seatWhereInput | table_seatWhereInput[]
    OR?: table_seatWhereInput[]
    NOT?: table_seatWhereInput | table_seatWhereInput[]
    id?: StringFilter<"table_seat"> | string
    tableId?: StringFilter<"table_seat"> | string
    seatIndex?: IntFilter<"table_seat"> | number
    userId?: StringNullableFilter<"table_seat"> | string | null
    createdAt?: DateTimeFilter<"table_seat"> | Date | string
    updatedAt?: DateTimeFilter<"table_seat"> | Date | string
    table?: XOR<TableScalarRelationFilter, tableWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type table_seatOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    seatIndex?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    table?: tableOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: table_seatOrderByRelevanceInput
  }

  export type table_seatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tableId_seatIndex?: table_seatTableIdSeatIndexCompoundUniqueInput
    AND?: table_seatWhereInput | table_seatWhereInput[]
    OR?: table_seatWhereInput[]
    NOT?: table_seatWhereInput | table_seatWhereInput[]
    tableId?: StringFilter<"table_seat"> | string
    seatIndex?: IntFilter<"table_seat"> | number
    userId?: StringNullableFilter<"table_seat"> | string | null
    createdAt?: DateTimeFilter<"table_seat"> | Date | string
    updatedAt?: DateTimeFilter<"table_seat"> | Date | string
    table?: XOR<TableScalarRelationFilter, tableWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id" | "tableId_seatIndex">

  export type table_seatOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    seatIndex?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: table_seatCountOrderByAggregateInput
    _avg?: table_seatAvgOrderByAggregateInput
    _max?: table_seatMaxOrderByAggregateInput
    _min?: table_seatMinOrderByAggregateInput
    _sum?: table_seatSumOrderByAggregateInput
  }

  export type table_seatScalarWhereWithAggregatesInput = {
    AND?: table_seatScalarWhereWithAggregatesInput | table_seatScalarWhereWithAggregatesInput[]
    OR?: table_seatScalarWhereWithAggregatesInput[]
    NOT?: table_seatScalarWhereWithAggregatesInput | table_seatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"table_seat"> | string
    tableId?: StringWithAggregatesFilter<"table_seat"> | string
    seatIndex?: IntWithAggregatesFilter<"table_seat"> | number
    userId?: StringNullableWithAggregatesFilter<"table_seat"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"table_seat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"table_seat"> | Date | string
  }

  export type accountCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationCreateInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type invitationUncheckedCreateInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type invitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type invitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type invitationCreateManyInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type invitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type invitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type jwksCreateInput = {
    id: string
    publicKey: string
    privateKey: string
    createdAt: Date | string
  }

  export type jwksUncheckedCreateInput = {
    id: string
    publicKey: string
    privateKey: string
    createdAt: Date | string
  }

  export type jwksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jwksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jwksCreateManyInput = {
    id: string
    publicKey: string
    privateKey: string
    createdAt: Date | string
  }

  export type jwksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jwksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memberCreateInput = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type memberUncheckedCreateInput = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type memberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memberCreateManyInput = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type memberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type memberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationCreateInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
  }

  export type organizationUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
  }

  export type organizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationCreateManyInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
  }

  export type organizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type sessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type verificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type verificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sidelinkCreateInput = {
    name: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy: string
    hidden?: boolean
  }

  export type sidelinkUncheckedCreateInput = {
    id?: number
    name: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy: string
    hidden?: boolean
  }

  export type sidelinkUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sidelinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sidelinkCreateManyInput = {
    id?: number
    name: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy: string
    hidden?: boolean
  }

  export type sidelinkUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sidelinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type username_file_configCreateInput = {
    folder_slug?: string | null
    path?: string | null
    variable?: string | null
    config_type?: string | null
  }

  export type username_file_configUncheckedCreateInput = {
    id?: number
    folder_slug?: string | null
    path?: string | null
    variable?: string | null
    config_type?: string | null
  }

  export type username_file_configUpdateInput = {
    folder_slug?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    variable?: NullableStringFieldUpdateOperationsInput | string | null
    config_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type username_file_configUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    folder_slug?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    variable?: NullableStringFieldUpdateOperationsInput | string | null
    config_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type username_file_configCreateManyInput = {
    id?: number
    folder_slug?: string | null
    path?: string | null
    variable?: string | null
    config_type?: string | null
  }

  export type username_file_configUpdateManyMutationInput = {
    folder_slug?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    variable?: NullableStringFieldUpdateOperationsInput | string | null
    config_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type username_file_configUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    folder_slug?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    variable?: NullableStringFieldUpdateOperationsInput | string | null
    config_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_settingsCreateInput = {
    local_games_dir: string
    user: userCreateNestedOneWithoutUser_settingsInput
  }

  export type user_settingsUncheckedCreateInput = {
    id?: number
    user_id: string
    local_games_dir: string
  }

  export type user_settingsUpdateInput = {
    local_games_dir?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutUser_settingsNestedInput
  }

  export type user_settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    local_games_dir?: StringFieldUpdateOperationsInput | string
  }

  export type user_settingsCreateManyInput = {
    id?: number
    user_id: string
    local_games_dir: string
  }

  export type user_settingsUpdateManyMutationInput = {
    local_games_dir?: StringFieldUpdateOperationsInput | string
  }

  export type user_settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    local_games_dir?: StringFieldUpdateOperationsInput | string
  }

  export type game_sessionCreateInput = {
    id?: string
    game_slug: string
    start_time: Date | string
    end_time?: Date | string | null
    total_seconds?: number | null
    user: userCreateNestedOneWithoutGame_sessionInput
  }

  export type game_sessionUncheckedCreateInput = {
    id?: string
    user_id: string
    game_slug: string
    start_time: Date | string
    end_time?: Date | string | null
    total_seconds?: number | null
  }

  export type game_sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    user?: userUpdateOneRequiredWithoutGame_sessionNestedInput
  }

  export type game_sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type game_sessionCreateManyInput = {
    id?: string
    user_id: string
    game_slug: string
    start_time: Date | string
    end_time?: Date | string | null
    total_seconds?: number | null
  }

  export type game_sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type game_sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventCreateInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    location?: string | null
    image_url?: string | null
    creator: userCreateNestedOneWithoutEvent_createdInput
    updater: userCreateNestedOneWithoutEvent_updatedInput
  }

  export type eventUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
    location?: string | null
    image_url?: string | null
  }

  export type eventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: userUpdateOneRequiredWithoutEvent_createdNestedInput
    updater?: userUpdateOneRequiredWithoutEvent_updatedNestedInput
  }

  export type eventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
    location?: string | null
    image_url?: string | null
  }

  export type eventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type global_settingsCreateInput = {
    key: string
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type global_settingsUncheckedCreateInput = {
    id?: number
    key: string
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type global_settingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type global_settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type global_settingsCreateManyInput = {
    id?: number
    key: string
    value?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type global_settingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type global_settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type gameCreateInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    createdBy: userCreateNestedOneWithoutGamesCreatedInput
    updatedBy: userCreateNestedOneWithoutGamesUpdatedInput
  }

  export type gameUncheckedCreateInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type gameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: userUpdateOneRequiredWithoutGamesCreatedNestedInput
    updatedBy?: userUpdateOneRequiredWithoutGamesUpdatedNestedInput
  }

  export type gameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type gameCreateManyInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type gameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type gameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type game_serverCreateInput = {
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: userCreateNestedOneWithoutGame_server_createdInput
    updater: userCreateNestedOneWithoutGame_server_updatedInput
  }

  export type game_serverUncheckedCreateInput = {
    id?: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type game_serverUpdateInput = {
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutGame_server_createdNestedInput
    updater?: userUpdateOneRequiredWithoutGame_server_updatedNestedInput
  }

  export type game_serverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type game_serverCreateManyInput = {
    id?: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type game_serverUpdateManyMutationInput = {
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_serverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type roleCreateInput = {
    name: string
    nameplate_decoration_animated?: string | null
    nameplate_decoration_static?: string | null
    avatar_decoration_animated?: string | null
    avatar_decoration_static?: string | null
  }

  export type roleUncheckedCreateInput = {
    name: string
    nameplate_decoration_animated?: string | null
    nameplate_decoration_static?: string | null
    avatar_decoration_animated?: string | null
    avatar_decoration_static?: string | null
  }

  export type roleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    nameplate_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    nameplate_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    nameplate_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    nameplate_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleCreateManyInput = {
    name: string
    nameplate_decoration_animated?: string | null
    nameplate_decoration_static?: string | null
    avatar_decoration_animated?: string | null
    avatar_decoration_static?: string | null
  }

  export type roleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    nameplate_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    nameplate_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    nameplate_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    nameplate_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_animated?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_decoration_static?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_gameCreateInput = {
    user_id: string
    game_slug: string
    installed_at?: Date | string | null
  }

  export type user_gameUncheckedCreateInput = {
    user_id: string
    game_slug: string
    installed_at?: Date | string | null
  }

  export type user_gameUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    installed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_gameUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    installed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_gameCreateManyInput = {
    user_id: string
    game_slug: string
    installed_at?: Date | string | null
  }

  export type user_gameUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    installed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_gameUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    installed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_game_favoriteCreateInput = {
    user_id: string
    game_slug: string
    addedAt?: Date | string
  }

  export type user_game_favoriteUncheckedCreateInput = {
    user_id: string
    game_slug: string
    addedAt?: Date | string
  }

  export type user_game_favoriteUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_game_favoriteUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_game_favoriteCreateManyInput = {
    user_id: string
    game_slug: string
    addedAt?: Date | string
  }

  export type user_game_favoriteUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_game_favoriteUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqCreateInput = {
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    creator: userCreateNestedOneWithoutFaq_createdInput
    updater: userCreateNestedOneWithoutFaq_updatedInput
  }

  export type faqUncheckedCreateInput = {
    id?: number
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type faqUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutFaq_createdNestedInput
    updater?: userUpdateOneRequiredWithoutFaq_updatedNestedInput
  }

  export type faqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type faqCreateManyInput = {
    id?: number
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    updated_by: string
  }

  export type faqUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type guildCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelCreateNestedManyWithoutGuildInput
    owner: userCreateNestedOneWithoutGuildInput
    members?: guild_memberCreateNestedManyWithoutGuildInput
    room?: roomCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelUncheckedCreateNestedManyWithoutGuildInput
    members?: guild_memberUncheckedCreateNestedManyWithoutGuildInput
    room?: roomUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUpdateManyWithoutGuildNestedInput
    owner?: userUpdateOneRequiredWithoutGuildNestedInput
    members?: guild_memberUpdateManyWithoutGuildNestedInput
    room?: roomUpdateManyWithoutGuildNestedInput
  }

  export type guildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUncheckedUpdateManyWithoutGuildNestedInput
    members?: guild_memberUncheckedUpdateManyWithoutGuildNestedInput
    room?: roomUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type guildCreateManyInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type guildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberCreateInput = {
    id?: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
    guild: guildCreateNestedOneWithoutMembersInput
    user: userCreateNestedOneWithoutGuild_membershipsInput
  }

  export type guild_memberUncheckedCreateInput = {
    id?: string
    guildId: string
    userId: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
  }

  export type guild_memberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutMembersNestedInput
    user?: userUpdateOneRequiredWithoutGuild_membershipsNestedInput
  }

  export type guild_memberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberCreateManyInput = {
    id?: string
    guildId: string
    userId: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
  }

  export type guild_memberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channelCreateInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guild: guildCreateNestedOneWithoutChannelsInput
    parent?: channelCreateNestedOneWithoutChildrenInput
    children?: channelCreateNestedManyWithoutParentInput
    members?: channel_memberCreateNestedManyWithoutChannelInput
    room?: roomCreateNestedOneWithoutChannelInput
  }

  export type channelUncheckedCreateInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: channelUncheckedCreateNestedManyWithoutParentInput
    members?: channel_memberUncheckedCreateNestedManyWithoutChannelInput
    room?: roomUncheckedCreateNestedOneWithoutChannelInput
  }

  export type channelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutChannelsNestedInput
    parent?: channelUpdateOneWithoutChildrenNestedInput
    children?: channelUpdateManyWithoutParentNestedInput
    members?: channel_memberUpdateManyWithoutChannelNestedInput
    room?: roomUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: channelUncheckedUpdateManyWithoutParentNestedInput
    members?: channel_memberUncheckedUpdateManyWithoutChannelNestedInput
    room?: roomUncheckedUpdateOneWithoutChannelNestedInput
  }

  export type channelCreateManyInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type channelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channel_memberCreateInput = {
    addedAt?: Date | string
    channel: channelCreateNestedOneWithoutMembersInput
    user: userCreateNestedOneWithoutChannel_membershipsInput
  }

  export type channel_memberUncheckedCreateInput = {
    channelId: string
    userId: string
    addedAt?: Date | string
  }

  export type channel_memberUpdateInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: channelUpdateOneRequiredWithoutMembersNestedInput
    user?: userUpdateOneRequiredWithoutChannel_membershipsNestedInput
  }

  export type channel_memberUncheckedUpdateInput = {
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channel_memberCreateManyInput = {
    channelId: string
    userId: string
    addedAt?: Date | string
  }

  export type channel_memberUpdateManyMutationInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channel_memberUncheckedUpdateManyInput = {
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roomCreateInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    messages?: messageCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    messages?: messageUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type roomCreateManyInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type roomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_participantCreateInput = {
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
    room: roomCreateNestedOneWithoutParticipantsInput
    user: userCreateNestedOneWithoutRoom_participationsInput
  }

  export type room_participantUncheckedCreateInput = {
    roomId: string
    userId: string
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_participantUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    room?: roomUpdateOneRequiredWithoutParticipantsNestedInput
    user?: userUpdateOneRequiredWithoutRoom_participationsNestedInput
  }

  export type room_participantUncheckedUpdateInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_participantCreateManyInput = {
    roomId: string
    userId: string
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_participantUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_participantUncheckedUpdateManyInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type dm_pair_uniqueCreateInput = {
    id?: string
    userA: string
    userB: string
    room: roomCreateNestedOneWithoutDm_pair_uniqueInput
  }

  export type dm_pair_uniqueUncheckedCreateInput = {
    id?: string
    userA: string
    userB: string
    roomId: string
  }

  export type dm_pair_uniqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
    room?: roomUpdateOneRequiredWithoutDm_pair_uniqueNestedInput
  }

  export type dm_pair_uniqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type dm_pair_uniqueCreateManyInput = {
    id?: string
    userA: string
    userB: string
    roomId: string
  }

  export type dm_pair_uniqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
  }

  export type dm_pair_uniqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type messageCreateInput = {
    id?: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    author: userCreateNestedOneWithoutMessagesInput
    room: roomCreateNestedOneWithoutMessagesInput
    reactions?: message_reactionCreateNestedManyWithoutMessageInput
    reads?: message_readCreateNestedManyWithoutMessageInput
  }

  export type messageUncheckedCreateInput = {
    id?: string
    roomId: string
    authorId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    reactions?: message_reactionUncheckedCreateNestedManyWithoutMessageInput
    reads?: message_readUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: userUpdateOneRequiredWithoutMessagesNestedInput
    room?: roomUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: message_reactionUpdateManyWithoutMessageNestedInput
    reads?: message_readUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactions?: message_reactionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: message_readUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type messageCreateManyInput = {
    id?: string
    roomId: string
    authorId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type messageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type message_readCreateInput = {
    readAt?: Date | string
    message: messageCreateNestedOneWithoutReadsInput
    user: userCreateNestedOneWithoutMessage_readsInput
  }

  export type message_readUncheckedCreateInput = {
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type message_readUpdateInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUpdateOneRequiredWithoutReadsNestedInput
    user?: userUpdateOneRequiredWithoutMessage_readsNestedInput
  }

  export type message_readUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_readCreateManyInput = {
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type message_readUpdateManyMutationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_readUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_reactionCreateInput = {
    emoji: string
    createdAt?: Date | string
    message: messageCreateNestedOneWithoutReactionsInput
    user: userCreateNestedOneWithoutMessage_reactionsInput
  }

  export type message_reactionUncheckedCreateInput = {
    messageId: string
    userId: string
    emoji: string
    createdAt?: Date | string
  }

  export type message_reactionUpdateInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUpdateOneRequiredWithoutReactionsNestedInput
    user?: userUpdateOneRequiredWithoutMessage_reactionsNestedInput
  }

  export type message_reactionUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_reactionCreateManyInput = {
    messageId: string
    userId: string
    emoji: string
    createdAt?: Date | string
  }

  export type message_reactionUpdateManyMutationInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_reactionUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_viewCreateInput = {
    lastSeenAt?: Date | string
    room: roomCreateNestedOneWithoutRoom_viewInput
    user: userCreateNestedOneWithoutRoom_viewInput
  }

  export type room_viewUncheckedCreateInput = {
    roomId: string
    userId: string
    lastSeenAt?: Date | string
  }

  export type room_viewUpdateInput = {
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: roomUpdateOneRequiredWithoutRoom_viewNestedInput
    user?: userUpdateOneRequiredWithoutRoom_viewNestedInput
  }

  export type room_viewUncheckedUpdateInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_viewCreateManyInput = {
    roomId: string
    userId: string
    lastSeenAt?: Date | string
  }

  export type room_viewUpdateManyMutationInput = {
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_viewUncheckedUpdateManyInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EFMigrationsHistoryCreateInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUncheckedCreateInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUpdateInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryUncheckedUpdateInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryCreateManyInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUpdateManyMutationInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryUncheckedUpdateManyInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type editionCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: userCreateNestedOneWithoutEdition_createdInput
    updater: userCreateNestedOneWithoutEdition_updatedInput
    rooms?: edition_roomCreateNestedManyWithoutEditionInput
  }

  export type editionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy: string
    rooms?: edition_roomUncheckedCreateNestedManyWithoutEditionInput
  }

  export type editionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutEdition_createdNestedInput
    updater?: userUpdateOneRequiredWithoutEdition_updatedNestedInput
    rooms?: edition_roomUpdateManyWithoutEditionNestedInput
  }

  export type editionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    rooms?: edition_roomUncheckedUpdateManyWithoutEditionNestedInput
  }

  export type editionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy: string
  }

  export type editionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type editionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type edition_roomCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    edition: editionCreateNestedOneWithoutRoomsInput
    tables?: tableCreateNestedManyWithoutRoomInput
  }

  export type edition_roomUncheckedCreateInput = {
    id?: string
    editionId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: tableUncheckedCreateNestedManyWithoutRoomInput
  }

  export type edition_roomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edition?: editionUpdateOneRequiredWithoutRoomsNestedInput
    tables?: tableUpdateManyWithoutRoomNestedInput
  }

  export type edition_roomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    editionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: tableUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type edition_roomCreateManyInput = {
    id?: string
    editionId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type edition_roomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type edition_roomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    editionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tableCreateInput = {
    id?: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    room: edition_roomCreateNestedOneWithoutTablesInput
    seats?: table_seatCreateNestedManyWithoutTableInput
  }

  export type tableUncheckedCreateInput = {
    id?: string
    roomId: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: table_seatUncheckedCreateNestedManyWithoutTableInput
  }

  export type tableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: edition_roomUpdateOneRequiredWithoutTablesNestedInput
    seats?: table_seatUpdateManyWithoutTableNestedInput
  }

  export type tableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: table_seatUncheckedUpdateManyWithoutTableNestedInput
  }

  export type tableCreateManyInput = {
    id?: string
    roomId: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatCreateInput = {
    id?: string
    seatIndex: number
    createdAt?: Date | string
    updatedAt?: Date | string
    table: tableCreateNestedOneWithoutSeatsInput
    user?: userCreateNestedOneWithoutTable_seatsInput
  }

  export type table_seatUncheckedCreateInput = {
    id?: string
    tableId: string
    seatIndex: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type table_seatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: tableUpdateOneRequiredWithoutSeatsNestedInput
    user?: userUpdateOneWithoutTable_seatsNestedInput
  }

  export type table_seatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatCreateManyInput = {
    id?: string
    tableId: string
    seatIndex: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type table_seatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accountOrderByRelevanceInput = {
    fields: accountOrderByRelevanceFieldEnum | accountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type invitationOrderByRelevanceInput = {
    fields: invitationOrderByRelevanceFieldEnum | invitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type invitationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type invitationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type invitationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type jwksOrderByRelevanceInput = {
    fields: jwksOrderByRelevanceFieldEnum | jwksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jwksCountOrderByAggregateInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type jwksMaxOrderByAggregateInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type jwksMinOrderByAggregateInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type memberOrderByRelevanceInput = {
    fields: memberOrderByRelevanceFieldEnum | memberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type memberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type memberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type memberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type organizationOrderByRelevanceInput = {
    fields: organizationOrderByRelevanceFieldEnum | organizationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type organizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type organizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type organizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type sessionOrderByRelevanceInput = {
    fields: sessionOrderByRelevanceFieldEnum | sessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
    activeOrganizationId?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
    activeOrganizationId?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
    activeOrganizationId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Channel_memberListRelationFilter = {
    every?: channel_memberWhereInput
    some?: channel_memberWhereInput
    none?: channel_memberWhereInput
  }

  export type EventListRelationFilter = {
    every?: eventWhereInput
    some?: eventWhereInput
    none?: eventWhereInput
  }

  export type FaqListRelationFilter = {
    every?: faqWhereInput
    some?: faqWhereInput
    none?: faqWhereInput
  }

  export type GameListRelationFilter = {
    every?: gameWhereInput
    some?: gameWhereInput
    none?: gameWhereInput
  }

  export type Game_sessionListRelationFilter = {
    every?: game_sessionWhereInput
    some?: game_sessionWhereInput
    none?: game_sessionWhereInput
  }

  export type GuildListRelationFilter = {
    every?: guildWhereInput
    some?: guildWhereInput
    none?: guildWhereInput
  }

  export type Guild_memberListRelationFilter = {
    every?: guild_memberWhereInput
    some?: guild_memberWhereInput
    none?: guild_memberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type Message_reactionListRelationFilter = {
    every?: message_reactionWhereInput
    some?: message_reactionWhereInput
    none?: message_reactionWhereInput
  }

  export type Message_readListRelationFilter = {
    every?: message_readWhereInput
    some?: message_readWhereInput
    none?: message_readWhereInput
  }

  export type RoomListRelationFilter = {
    every?: roomWhereInput
    some?: roomWhereInput
    none?: roomWhereInput
  }

  export type Room_participantListRelationFilter = {
    every?: room_participantWhereInput
    some?: room_participantWhereInput
    none?: room_participantWhereInput
  }

  export type Room_viewListRelationFilter = {
    every?: room_viewWhereInput
    some?: room_viewWhereInput
    none?: room_viewWhereInput
  }

  export type User_settingsNullableScalarRelationFilter = {
    is?: user_settingsWhereInput | null
    isNot?: user_settingsWhereInput | null
  }

  export type EditionListRelationFilter = {
    every?: editionWhereInput
    some?: editionWhereInput
    none?: editionWhereInput
  }

  export type Table_seatListRelationFilter = {
    every?: table_seatWhereInput
    some?: table_seatWhereInput
    none?: table_seatWhereInput
  }

  export type Game_serverListRelationFilter = {
    every?: game_serverWhereInput
    some?: game_serverWhereInput
    none?: game_serverWhereInput
  }

  export type channel_memberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type eventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type faqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type game_sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guild_memberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type message_reactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type message_readOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type room_participantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type room_viewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type editionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type table_seatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type game_serverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    displayUsername?: SortOrder
    lastLogin?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    displayUsername?: SortOrder
    lastLogin?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    displayUsername?: SortOrder
    lastLogin?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type verificationOrderByRelevanceInput = {
    fields: verificationOrderByRelevanceFieldEnum | verificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type verificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type sidelinkOrderByRelevanceInput = {
    fields: sidelinkOrderByRelevanceFieldEnum | sidelinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sidelinkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    hidden?: SortOrder
  }

  export type sidelinkAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sidelinkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    hidden?: SortOrder
  }

  export type sidelinkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    hidden?: SortOrder
  }

  export type sidelinkSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type username_file_configOrderByRelevanceInput = {
    fields: username_file_configOrderByRelevanceFieldEnum | username_file_configOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type username_file_configCountOrderByAggregateInput = {
    id?: SortOrder
    folder_slug?: SortOrder
    path?: SortOrder
    variable?: SortOrder
    config_type?: SortOrder
  }

  export type username_file_configAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type username_file_configMaxOrderByAggregateInput = {
    id?: SortOrder
    folder_slug?: SortOrder
    path?: SortOrder
    variable?: SortOrder
    config_type?: SortOrder
  }

  export type username_file_configMinOrderByAggregateInput = {
    id?: SortOrder
    folder_slug?: SortOrder
    path?: SortOrder
    variable?: SortOrder
    config_type?: SortOrder
  }

  export type username_file_configSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type user_settingsOrderByRelevanceInput = {
    fields: user_settingsOrderByRelevanceFieldEnum | user_settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    local_games_dir?: SortOrder
  }

  export type user_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    local_games_dir?: SortOrder
  }

  export type user_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    local_games_dir?: SortOrder
  }

  export type user_settingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type game_sessionOrderByRelevanceInput = {
    fields: game_sessionOrderByRelevanceFieldEnum | game_sessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type game_sessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_slug?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    total_seconds?: SortOrder
  }

  export type game_sessionAvgOrderByAggregateInput = {
    total_seconds?: SortOrder
  }

  export type game_sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_slug?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    total_seconds?: SortOrder
  }

  export type game_sessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    game_slug?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    total_seconds?: SortOrder
  }

  export type game_sessionSumOrderByAggregateInput = {
    total_seconds?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type eventOrderByRelevanceInput = {
    fields: eventOrderByRelevanceFieldEnum | eventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type eventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    location?: SortOrder
    image_url?: SortOrder
  }

  export type eventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    location?: SortOrder
    image_url?: SortOrder
  }

  export type eventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    location?: SortOrder
    image_url?: SortOrder
  }

  export type global_settingsOrderByRelevanceInput = {
    fields: global_settingsOrderByRelevanceFieldEnum | global_settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type global_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type global_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type global_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type global_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type global_settingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type gameOrderByRelevanceInput = {
    fields: gameOrderByRelevanceFieldEnum | gameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type gameCountOrderByAggregateInput = {
    id?: SortOrder
    size_gb?: SortOrder
    title?: SortOrder
    folder_slug?: SortOrder
    version?: SortOrder
    genres?: SortOrder
    platforms?: SortOrder
    game_modes?: SortOrder
    is_featured?: SortOrder
    date_updated?: SortOrder
    date_added?: SortOrder
    editor_name?: SortOrder
    main_process_name?: SortOrder
    cover?: SortOrder
    logo?: SortOrder
    screenshots?: SortOrder
    description?: SortOrder
    start_command?: SortOrder
    max_players?: SortOrder
    use_notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type gameAvgOrderByAggregateInput = {
    size_gb?: SortOrder
    max_players?: SortOrder
  }

  export type gameMaxOrderByAggregateInput = {
    id?: SortOrder
    size_gb?: SortOrder
    title?: SortOrder
    folder_slug?: SortOrder
    version?: SortOrder
    genres?: SortOrder
    platforms?: SortOrder
    game_modes?: SortOrder
    is_featured?: SortOrder
    date_updated?: SortOrder
    date_added?: SortOrder
    editor_name?: SortOrder
    main_process_name?: SortOrder
    cover?: SortOrder
    logo?: SortOrder
    screenshots?: SortOrder
    description?: SortOrder
    start_command?: SortOrder
    max_players?: SortOrder
    use_notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type gameMinOrderByAggregateInput = {
    id?: SortOrder
    size_gb?: SortOrder
    title?: SortOrder
    folder_slug?: SortOrder
    version?: SortOrder
    genres?: SortOrder
    platforms?: SortOrder
    game_modes?: SortOrder
    is_featured?: SortOrder
    date_updated?: SortOrder
    date_added?: SortOrder
    editor_name?: SortOrder
    main_process_name?: SortOrder
    cover?: SortOrder
    logo?: SortOrder
    screenshots?: SortOrder
    description?: SortOrder
    start_command?: SortOrder
    max_players?: SortOrder
    use_notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type gameSumOrderByAggregateInput = {
    size_gb?: SortOrder
    max_players?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type game_serverOrderByRelevanceInput = {
    fields: game_serverOrderByRelevanceFieldEnum | game_serverOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type game_serverCountOrderByAggregateInput = {
    id?: SortOrder
    game_slug?: SortOrder
    game_title?: SortOrder
    type?: SortOrder
    port?: SortOrder
    description?: SortOrder
    name?: SortOrder
    monitor?: SortOrder
    last_detection_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type game_serverAvgOrderByAggregateInput = {
    id?: SortOrder
    port?: SortOrder
  }

  export type game_serverMaxOrderByAggregateInput = {
    id?: SortOrder
    game_slug?: SortOrder
    game_title?: SortOrder
    type?: SortOrder
    port?: SortOrder
    description?: SortOrder
    name?: SortOrder
    monitor?: SortOrder
    last_detection_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type game_serverMinOrderByAggregateInput = {
    id?: SortOrder
    game_slug?: SortOrder
    game_title?: SortOrder
    type?: SortOrder
    port?: SortOrder
    description?: SortOrder
    name?: SortOrder
    monitor?: SortOrder
    last_detection_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type game_serverSumOrderByAggregateInput = {
    id?: SortOrder
    port?: SortOrder
  }

  export type roleOrderByRelevanceInput = {
    fields: roleOrderByRelevanceFieldEnum | roleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type roleCountOrderByAggregateInput = {
    name?: SortOrder
    nameplate_decoration_animated?: SortOrder
    nameplate_decoration_static?: SortOrder
    avatar_decoration_animated?: SortOrder
    avatar_decoration_static?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    name?: SortOrder
    nameplate_decoration_animated?: SortOrder
    nameplate_decoration_static?: SortOrder
    avatar_decoration_animated?: SortOrder
    avatar_decoration_static?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    name?: SortOrder
    nameplate_decoration_animated?: SortOrder
    nameplate_decoration_static?: SortOrder
    avatar_decoration_animated?: SortOrder
    avatar_decoration_static?: SortOrder
  }

  export type user_gameOrderByRelevanceInput = {
    fields: user_gameOrderByRelevanceFieldEnum | user_gameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_gameUser_idGame_slugCompoundUniqueInput = {
    user_id: string
    game_slug: string
  }

  export type user_gameCountOrderByAggregateInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    installed_at?: SortOrder
  }

  export type user_gameMaxOrderByAggregateInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    installed_at?: SortOrder
  }

  export type user_gameMinOrderByAggregateInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    installed_at?: SortOrder
  }

  export type user_game_favoriteOrderByRelevanceInput = {
    fields: user_game_favoriteOrderByRelevanceFieldEnum | user_game_favoriteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_game_favoriteUser_idGame_slugCompoundUniqueInput = {
    user_id: string
    game_slug: string
  }

  export type user_game_favoriteCountOrderByAggregateInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    addedAt?: SortOrder
  }

  export type user_game_favoriteMaxOrderByAggregateInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    addedAt?: SortOrder
  }

  export type user_game_favoriteMinOrderByAggregateInput = {
    user_id?: SortOrder
    game_slug?: SortOrder
    addedAt?: SortOrder
  }

  export type faqOrderByRelevanceInput = {
    fields: faqOrderByRelevanceFieldEnum | faqOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type faqCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    published?: SortOrder
    position?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type faqAvgOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
  }

  export type faqMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    published?: SortOrder
    position?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type faqMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    published?: SortOrder
    position?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type faqSumOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
  }

  export type ChannelListRelationFilter = {
    every?: channelWhereInput
    some?: channelWhereInput
    none?: channelWhereInput
  }

  export type channelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guildOrderByRelevanceInput = {
    fields: guildOrderByRelevanceFieldEnum | guildOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type guildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type guildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type guildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildScalarRelationFilter = {
    is?: guildWhereInput
    isNot?: guildWhereInput
  }

  export type guild_memberOrderByRelevanceInput = {
    fields: guild_memberOrderByRelevanceFieldEnum | guild_memberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type guild_memberGuildIdUserIdCompoundUniqueInput = {
    guildId: string
    userId: string
  }

  export type guild_memberCountOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    roles?: SortOrder
    joinedAt?: SortOrder
  }

  export type guild_memberMaxOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    roles?: SortOrder
    joinedAt?: SortOrder
  }

  export type guild_memberMinOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    userId?: SortOrder
    nickname?: SortOrder
    roles?: SortOrder
    joinedAt?: SortOrder
  }

  export type Enumchannel_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.channel_type | Enumchannel_typeFieldRefInput<$PrismaModel>
    in?: $Enums.channel_type[]
    notIn?: $Enums.channel_type[]
    not?: NestedEnumchannel_typeFilter<$PrismaModel> | $Enums.channel_type
  }

  export type ChannelNullableScalarRelationFilter = {
    is?: channelWhereInput | null
    isNot?: channelWhereInput | null
  }

  export type RoomNullableScalarRelationFilter = {
    is?: roomWhereInput | null
    isNot?: roomWhereInput | null
  }

  export type channelOrderByRelevanceInput = {
    fields: channelOrderByRelevanceFieldEnum | channelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type channelGuildIdSlugCompoundUniqueInput = {
    guildId: string
    slug: string
  }

  export type channelCountOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    topic?: SortOrder
    position?: SortOrder
    isPrivate?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type channelAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type channelMaxOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    topic?: SortOrder
    position?: SortOrder
    isPrivate?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type channelMinOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    topic?: SortOrder
    position?: SortOrder
    isPrivate?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type channelSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type Enumchannel_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.channel_type | Enumchannel_typeFieldRefInput<$PrismaModel>
    in?: $Enums.channel_type[]
    notIn?: $Enums.channel_type[]
    not?: NestedEnumchannel_typeWithAggregatesFilter<$PrismaModel> | $Enums.channel_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumchannel_typeFilter<$PrismaModel>
    _max?: NestedEnumchannel_typeFilter<$PrismaModel>
  }

  export type ChannelScalarRelationFilter = {
    is?: channelWhereInput
    isNot?: channelWhereInput
  }

  export type channel_memberOrderByRelevanceInput = {
    fields: channel_memberOrderByRelevanceFieldEnum | channel_memberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type channel_memberChannelIdUserIdCompoundUniqueInput = {
    channelId: string
    userId: string
  }

  export type channel_memberCountOrderByAggregateInput = {
    channelId?: SortOrder
    userId?: SortOrder
    addedAt?: SortOrder
  }

  export type channel_memberMaxOrderByAggregateInput = {
    channelId?: SortOrder
    userId?: SortOrder
    addedAt?: SortOrder
  }

  export type channel_memberMinOrderByAggregateInput = {
    channelId?: SortOrder
    userId?: SortOrder
    addedAt?: SortOrder
  }

  export type Enumroom_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.room_type | Enumroom_typeFieldRefInput<$PrismaModel>
    in?: $Enums.room_type[]
    notIn?: $Enums.room_type[]
    not?: NestedEnumroom_typeFilter<$PrismaModel> | $Enums.room_type
  }

  export type Dm_pair_uniqueListRelationFilter = {
    every?: dm_pair_uniqueWhereInput
    some?: dm_pair_uniqueWhereInput
    none?: dm_pair_uniqueWhereInput
  }

  export type GuildNullableScalarRelationFilter = {
    is?: guildWhereInput | null
    isNot?: guildWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type dm_pair_uniqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roomOrderByRelevanceInput = {
    fields: roomOrderByRelevanceFieldEnum | roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type roomCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    guildId?: SortOrder
    channelId?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type roomMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    guildId?: SortOrder
    channelId?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type roomMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    guildId?: SortOrder
    channelId?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumroom_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.room_type | Enumroom_typeFieldRefInput<$PrismaModel>
    in?: $Enums.room_type[]
    notIn?: $Enums.room_type[]
    not?: NestedEnumroom_typeWithAggregatesFilter<$PrismaModel> | $Enums.room_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroom_typeFilter<$PrismaModel>
    _max?: NestedEnumroom_typeFilter<$PrismaModel>
  }

  export type RoomScalarRelationFilter = {
    is?: roomWhereInput
    isNot?: roomWhereInput
  }

  export type room_participantOrderByRelevanceInput = {
    fields: room_participantOrderByRelevanceFieldEnum | room_participantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type room_participantRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type room_participantCountOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isMuted?: SortOrder
    isPinned?: SortOrder
  }

  export type room_participantMaxOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isMuted?: SortOrder
    isPinned?: SortOrder
  }

  export type room_participantMinOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isMuted?: SortOrder
    isPinned?: SortOrder
  }

  export type dm_pair_uniqueOrderByRelevanceInput = {
    fields: dm_pair_uniqueOrderByRelevanceFieldEnum | dm_pair_uniqueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type dm_pair_uniqueUserAUserBCompoundUniqueInput = {
    userA: string
    userB: string
  }

  export type dm_pair_uniqueCountOrderByAggregateInput = {
    id?: SortOrder
    userA?: SortOrder
    userB?: SortOrder
    roomId?: SortOrder
  }

  export type dm_pair_uniqueMaxOrderByAggregateInput = {
    id?: SortOrder
    userA?: SortOrder
    userB?: SortOrder
    roomId?: SortOrder
  }

  export type dm_pair_uniqueMinOrderByAggregateInput = {
    id?: SortOrder
    userA?: SortOrder
    userB?: SortOrder
    roomId?: SortOrder
  }

  export type Enummessage_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.message_type | Enummessage_typeFieldRefInput<$PrismaModel>
    in?: $Enums.message_type[]
    notIn?: $Enums.message_type[]
    not?: NestedEnummessage_typeFilter<$PrismaModel> | $Enums.message_type
  }

  export type messageOrderByRelevanceInput = {
    fields: messageOrderByRelevanceFieldEnum | messageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type messageCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type Enummessage_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.message_type | Enummessage_typeFieldRefInput<$PrismaModel>
    in?: $Enums.message_type[]
    notIn?: $Enums.message_type[]
    not?: NestedEnummessage_typeWithAggregatesFilter<$PrismaModel> | $Enums.message_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummessage_typeFilter<$PrismaModel>
    _max?: NestedEnummessage_typeFilter<$PrismaModel>
  }

  export type MessageScalarRelationFilter = {
    is?: messageWhereInput
    isNot?: messageWhereInput
  }

  export type message_readOrderByRelevanceInput = {
    fields: message_readOrderByRelevanceFieldEnum | message_readOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type message_readMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type message_readCountOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type message_readMaxOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type message_readMinOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type message_reactionOrderByRelevanceInput = {
    fields: message_reactionOrderByRelevanceFieldEnum | message_reactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type message_reactionMessageIdUserIdEmojiCompoundUniqueInput = {
    messageId: string
    userId: string
    emoji: string
  }

  export type message_reactionCountOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
  }

  export type message_reactionMaxOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
  }

  export type message_reactionMinOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
  }

  export type room_viewOrderByRelevanceInput = {
    fields: room_viewOrderByRelevanceFieldEnum | room_viewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type room_viewRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type room_viewCountOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type room_viewMaxOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type room_viewMinOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type EFMigrationsHistoryOrderByRelevanceInput = {
    fields: EFMigrationsHistoryOrderByRelevanceFieldEnum | EFMigrationsHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EFMigrationsHistoryCountOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryMaxOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryMinOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type Edition_roomListRelationFilter = {
    every?: edition_roomWhereInput
    some?: edition_roomWhereInput
    none?: edition_roomWhereInput
  }

  export type edition_roomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type editionOrderByRelevanceInput = {
    fields: editionOrderByRelevanceFieldEnum | editionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type editionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type editionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type editionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EditionScalarRelationFilter = {
    is?: editionWhereInput
    isNot?: editionWhereInput
  }

  export type TableListRelationFilter = {
    every?: tableWhereInput
    some?: tableWhereInput
    none?: tableWhereInput
  }

  export type tableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type edition_roomOrderByRelevanceInput = {
    fields: edition_roomOrderByRelevanceFieldEnum | edition_roomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type edition_roomEditionIdNameCompoundUniqueInput = {
    editionId: string
    name: string
  }

  export type edition_roomCountOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type edition_roomMaxOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type edition_roomMinOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Edition_roomScalarRelationFilter = {
    is?: edition_roomWhereInput
    isNot?: edition_roomWhereInput
  }

  export type tableOrderByRelevanceInput = {
    fields: tableOrderByRelevanceFieldEnum | tableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tableCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tableAvgOrderByAggregateInput = {
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
  }

  export type tableMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tableMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tableSumOrderByAggregateInput = {
    positionX?: SortOrder
    positionY?: SortOrder
    width?: SortOrder
    height?: SortOrder
    capacity?: SortOrder
  }

  export type TableScalarRelationFilter = {
    is?: tableWhereInput
    isNot?: tableWhereInput
  }

  export type table_seatOrderByRelevanceInput = {
    fields: table_seatOrderByRelevanceFieldEnum | table_seatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type table_seatTableIdSeatIndexCompoundUniqueInput = {
    tableId: string
    seatIndex: number
  }

  export type table_seatCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    seatIndex?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type table_seatAvgOrderByAggregateInput = {
    seatIndex?: SortOrder
  }

  export type table_seatMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    seatIndex?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type table_seatMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    seatIndex?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type table_seatSumOrderByAggregateInput = {
    seatIndex?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type channel_memberCreateNestedManyWithoutUserInput = {
    create?: XOR<channel_memberCreateWithoutUserInput, channel_memberUncheckedCreateWithoutUserInput> | channel_memberCreateWithoutUserInput[] | channel_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutUserInput | channel_memberCreateOrConnectWithoutUserInput[]
    createMany?: channel_memberCreateManyUserInputEnvelope
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
  }

  export type eventCreateNestedManyWithoutCreatorInput = {
    create?: XOR<eventCreateWithoutCreatorInput, eventUncheckedCreateWithoutCreatorInput> | eventCreateWithoutCreatorInput[] | eventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: eventCreateOrConnectWithoutCreatorInput | eventCreateOrConnectWithoutCreatorInput[]
    createMany?: eventCreateManyCreatorInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type eventCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<eventCreateWithoutUpdaterInput, eventUncheckedCreateWithoutUpdaterInput> | eventCreateWithoutUpdaterInput[] | eventUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUpdaterInput | eventCreateOrConnectWithoutUpdaterInput[]
    createMany?: eventCreateManyUpdaterInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type faqCreateNestedManyWithoutCreatorInput = {
    create?: XOR<faqCreateWithoutCreatorInput, faqUncheckedCreateWithoutCreatorInput> | faqCreateWithoutCreatorInput[] | faqUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: faqCreateOrConnectWithoutCreatorInput | faqCreateOrConnectWithoutCreatorInput[]
    createMany?: faqCreateManyCreatorInputEnvelope
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
  }

  export type faqCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<faqCreateWithoutUpdaterInput, faqUncheckedCreateWithoutUpdaterInput> | faqCreateWithoutUpdaterInput[] | faqUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: faqCreateOrConnectWithoutUpdaterInput | faqCreateOrConnectWithoutUpdaterInput[]
    createMany?: faqCreateManyUpdaterInputEnvelope
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
  }

  export type gameCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<gameCreateWithoutCreatedByInput, gameUncheckedCreateWithoutCreatedByInput> | gameCreateWithoutCreatedByInput[] | gameUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutCreatedByInput | gameCreateOrConnectWithoutCreatedByInput[]
    createMany?: gameCreateManyCreatedByInputEnvelope
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
  }

  export type gameCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<gameCreateWithoutUpdatedByInput, gameUncheckedCreateWithoutUpdatedByInput> | gameCreateWithoutUpdatedByInput[] | gameUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutUpdatedByInput | gameCreateOrConnectWithoutUpdatedByInput[]
    createMany?: gameCreateManyUpdatedByInputEnvelope
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
  }

  export type game_sessionCreateNestedManyWithoutUserInput = {
    create?: XOR<game_sessionCreateWithoutUserInput, game_sessionUncheckedCreateWithoutUserInput> | game_sessionCreateWithoutUserInput[] | game_sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_sessionCreateOrConnectWithoutUserInput | game_sessionCreateOrConnectWithoutUserInput[]
    createMany?: game_sessionCreateManyUserInputEnvelope
    connect?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
  }

  export type guildCreateNestedManyWithoutOwnerInput = {
    create?: XOR<guildCreateWithoutOwnerInput, guildUncheckedCreateWithoutOwnerInput> | guildCreateWithoutOwnerInput[] | guildUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: guildCreateOrConnectWithoutOwnerInput | guildCreateOrConnectWithoutOwnerInput[]
    createMany?: guildCreateManyOwnerInputEnvelope
    connect?: guildWhereUniqueInput | guildWhereUniqueInput[]
  }

  export type guild_memberCreateNestedManyWithoutUserInput = {
    create?: XOR<guild_memberCreateWithoutUserInput, guild_memberUncheckedCreateWithoutUserInput> | guild_memberCreateWithoutUserInput[] | guild_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutUserInput | guild_memberCreateOrConnectWithoutUserInput[]
    createMany?: guild_memberCreateManyUserInputEnvelope
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<messageCreateWithoutAuthorInput, messageUncheckedCreateWithoutAuthorInput> | messageCreateWithoutAuthorInput[] | messageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: messageCreateOrConnectWithoutAuthorInput | messageCreateOrConnectWithoutAuthorInput[]
    createMany?: messageCreateManyAuthorInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type message_reactionCreateNestedManyWithoutUserInput = {
    create?: XOR<message_reactionCreateWithoutUserInput, message_reactionUncheckedCreateWithoutUserInput> | message_reactionCreateWithoutUserInput[] | message_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutUserInput | message_reactionCreateOrConnectWithoutUserInput[]
    createMany?: message_reactionCreateManyUserInputEnvelope
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
  }

  export type message_readCreateNestedManyWithoutUserInput = {
    create?: XOR<message_readCreateWithoutUserInput, message_readUncheckedCreateWithoutUserInput> | message_readCreateWithoutUserInput[] | message_readUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutUserInput | message_readCreateOrConnectWithoutUserInput[]
    createMany?: message_readCreateManyUserInputEnvelope
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
  }

  export type roomCreateNestedManyWithoutOwnerInput = {
    create?: XOR<roomCreateWithoutOwnerInput, roomUncheckedCreateWithoutOwnerInput> | roomCreateWithoutOwnerInput[] | roomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: roomCreateOrConnectWithoutOwnerInput | roomCreateOrConnectWithoutOwnerInput[]
    createMany?: roomCreateManyOwnerInputEnvelope
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
  }

  export type room_participantCreateNestedManyWithoutUserInput = {
    create?: XOR<room_participantCreateWithoutUserInput, room_participantUncheckedCreateWithoutUserInput> | room_participantCreateWithoutUserInput[] | room_participantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutUserInput | room_participantCreateOrConnectWithoutUserInput[]
    createMany?: room_participantCreateManyUserInputEnvelope
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
  }

  export type room_viewCreateNestedManyWithoutUserInput = {
    create?: XOR<room_viewCreateWithoutUserInput, room_viewUncheckedCreateWithoutUserInput> | room_viewCreateWithoutUserInput[] | room_viewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutUserInput | room_viewCreateOrConnectWithoutUserInput[]
    createMany?: room_viewCreateManyUserInputEnvelope
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
  }

  export type user_settingsCreateNestedOneWithoutUserInput = {
    create?: XOR<user_settingsCreateWithoutUserInput, user_settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_settingsCreateOrConnectWithoutUserInput
    connect?: user_settingsWhereUniqueInput
  }

  export type editionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<editionCreateWithoutCreatorInput, editionUncheckedCreateWithoutCreatorInput> | editionCreateWithoutCreatorInput[] | editionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: editionCreateOrConnectWithoutCreatorInput | editionCreateOrConnectWithoutCreatorInput[]
    createMany?: editionCreateManyCreatorInputEnvelope
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
  }

  export type editionCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<editionCreateWithoutUpdaterInput, editionUncheckedCreateWithoutUpdaterInput> | editionCreateWithoutUpdaterInput[] | editionUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: editionCreateOrConnectWithoutUpdaterInput | editionCreateOrConnectWithoutUpdaterInput[]
    createMany?: editionCreateManyUpdaterInputEnvelope
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
  }

  export type table_seatCreateNestedManyWithoutUserInput = {
    create?: XOR<table_seatCreateWithoutUserInput, table_seatUncheckedCreateWithoutUserInput> | table_seatCreateWithoutUserInput[] | table_seatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutUserInput | table_seatCreateOrConnectWithoutUserInput[]
    createMany?: table_seatCreateManyUserInputEnvelope
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
  }

  export type game_serverCreateNestedManyWithoutCreatorInput = {
    create?: XOR<game_serverCreateWithoutCreatorInput, game_serverUncheckedCreateWithoutCreatorInput> | game_serverCreateWithoutCreatorInput[] | game_serverUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutCreatorInput | game_serverCreateOrConnectWithoutCreatorInput[]
    createMany?: game_serverCreateManyCreatorInputEnvelope
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
  }

  export type game_serverCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<game_serverCreateWithoutUpdaterInput, game_serverUncheckedCreateWithoutUpdaterInput> | game_serverCreateWithoutUpdaterInput[] | game_serverUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutUpdaterInput | game_serverCreateOrConnectWithoutUpdaterInput[]
    createMany?: game_serverCreateManyUpdaterInputEnvelope
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
  }

  export type channel_memberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<channel_memberCreateWithoutUserInput, channel_memberUncheckedCreateWithoutUserInput> | channel_memberCreateWithoutUserInput[] | channel_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutUserInput | channel_memberCreateOrConnectWithoutUserInput[]
    createMany?: channel_memberCreateManyUserInputEnvelope
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
  }

  export type eventUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<eventCreateWithoutCreatorInput, eventUncheckedCreateWithoutCreatorInput> | eventCreateWithoutCreatorInput[] | eventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: eventCreateOrConnectWithoutCreatorInput | eventCreateOrConnectWithoutCreatorInput[]
    createMany?: eventCreateManyCreatorInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type eventUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<eventCreateWithoutUpdaterInput, eventUncheckedCreateWithoutUpdaterInput> | eventCreateWithoutUpdaterInput[] | eventUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUpdaterInput | eventCreateOrConnectWithoutUpdaterInput[]
    createMany?: eventCreateManyUpdaterInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type faqUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<faqCreateWithoutCreatorInput, faqUncheckedCreateWithoutCreatorInput> | faqCreateWithoutCreatorInput[] | faqUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: faqCreateOrConnectWithoutCreatorInput | faqCreateOrConnectWithoutCreatorInput[]
    createMany?: faqCreateManyCreatorInputEnvelope
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
  }

  export type faqUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<faqCreateWithoutUpdaterInput, faqUncheckedCreateWithoutUpdaterInput> | faqCreateWithoutUpdaterInput[] | faqUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: faqCreateOrConnectWithoutUpdaterInput | faqCreateOrConnectWithoutUpdaterInput[]
    createMany?: faqCreateManyUpdaterInputEnvelope
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
  }

  export type gameUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<gameCreateWithoutCreatedByInput, gameUncheckedCreateWithoutCreatedByInput> | gameCreateWithoutCreatedByInput[] | gameUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutCreatedByInput | gameCreateOrConnectWithoutCreatedByInput[]
    createMany?: gameCreateManyCreatedByInputEnvelope
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
  }

  export type gameUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<gameCreateWithoutUpdatedByInput, gameUncheckedCreateWithoutUpdatedByInput> | gameCreateWithoutUpdatedByInput[] | gameUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutUpdatedByInput | gameCreateOrConnectWithoutUpdatedByInput[]
    createMany?: gameCreateManyUpdatedByInputEnvelope
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
  }

  export type game_sessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<game_sessionCreateWithoutUserInput, game_sessionUncheckedCreateWithoutUserInput> | game_sessionCreateWithoutUserInput[] | game_sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_sessionCreateOrConnectWithoutUserInput | game_sessionCreateOrConnectWithoutUserInput[]
    createMany?: game_sessionCreateManyUserInputEnvelope
    connect?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
  }

  export type guildUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<guildCreateWithoutOwnerInput, guildUncheckedCreateWithoutOwnerInput> | guildCreateWithoutOwnerInput[] | guildUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: guildCreateOrConnectWithoutOwnerInput | guildCreateOrConnectWithoutOwnerInput[]
    createMany?: guildCreateManyOwnerInputEnvelope
    connect?: guildWhereUniqueInput | guildWhereUniqueInput[]
  }

  export type guild_memberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<guild_memberCreateWithoutUserInput, guild_memberUncheckedCreateWithoutUserInput> | guild_memberCreateWithoutUserInput[] | guild_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutUserInput | guild_memberCreateOrConnectWithoutUserInput[]
    createMany?: guild_memberCreateManyUserInputEnvelope
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<messageCreateWithoutAuthorInput, messageUncheckedCreateWithoutAuthorInput> | messageCreateWithoutAuthorInput[] | messageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: messageCreateOrConnectWithoutAuthorInput | messageCreateOrConnectWithoutAuthorInput[]
    createMany?: messageCreateManyAuthorInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type message_reactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<message_reactionCreateWithoutUserInput, message_reactionUncheckedCreateWithoutUserInput> | message_reactionCreateWithoutUserInput[] | message_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutUserInput | message_reactionCreateOrConnectWithoutUserInput[]
    createMany?: message_reactionCreateManyUserInputEnvelope
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
  }

  export type message_readUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<message_readCreateWithoutUserInput, message_readUncheckedCreateWithoutUserInput> | message_readCreateWithoutUserInput[] | message_readUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutUserInput | message_readCreateOrConnectWithoutUserInput[]
    createMany?: message_readCreateManyUserInputEnvelope
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
  }

  export type roomUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<roomCreateWithoutOwnerInput, roomUncheckedCreateWithoutOwnerInput> | roomCreateWithoutOwnerInput[] | roomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: roomCreateOrConnectWithoutOwnerInput | roomCreateOrConnectWithoutOwnerInput[]
    createMany?: roomCreateManyOwnerInputEnvelope
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
  }

  export type room_participantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<room_participantCreateWithoutUserInput, room_participantUncheckedCreateWithoutUserInput> | room_participantCreateWithoutUserInput[] | room_participantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutUserInput | room_participantCreateOrConnectWithoutUserInput[]
    createMany?: room_participantCreateManyUserInputEnvelope
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
  }

  export type room_viewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<room_viewCreateWithoutUserInput, room_viewUncheckedCreateWithoutUserInput> | room_viewCreateWithoutUserInput[] | room_viewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutUserInput | room_viewCreateOrConnectWithoutUserInput[]
    createMany?: room_viewCreateManyUserInputEnvelope
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
  }

  export type user_settingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<user_settingsCreateWithoutUserInput, user_settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_settingsCreateOrConnectWithoutUserInput
    connect?: user_settingsWhereUniqueInput
  }

  export type editionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<editionCreateWithoutCreatorInput, editionUncheckedCreateWithoutCreatorInput> | editionCreateWithoutCreatorInput[] | editionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: editionCreateOrConnectWithoutCreatorInput | editionCreateOrConnectWithoutCreatorInput[]
    createMany?: editionCreateManyCreatorInputEnvelope
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
  }

  export type editionUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<editionCreateWithoutUpdaterInput, editionUncheckedCreateWithoutUpdaterInput> | editionCreateWithoutUpdaterInput[] | editionUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: editionCreateOrConnectWithoutUpdaterInput | editionCreateOrConnectWithoutUpdaterInput[]
    createMany?: editionCreateManyUpdaterInputEnvelope
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
  }

  export type table_seatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<table_seatCreateWithoutUserInput, table_seatUncheckedCreateWithoutUserInput> | table_seatCreateWithoutUserInput[] | table_seatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutUserInput | table_seatCreateOrConnectWithoutUserInput[]
    createMany?: table_seatCreateManyUserInputEnvelope
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
  }

  export type game_serverUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<game_serverCreateWithoutCreatorInput, game_serverUncheckedCreateWithoutCreatorInput> | game_serverCreateWithoutCreatorInput[] | game_serverUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutCreatorInput | game_serverCreateOrConnectWithoutCreatorInput[]
    createMany?: game_serverCreateManyCreatorInputEnvelope
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
  }

  export type game_serverUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<game_serverCreateWithoutUpdaterInput, game_serverUncheckedCreateWithoutUpdaterInput> | game_serverCreateWithoutUpdaterInput[] | game_serverUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutUpdaterInput | game_serverCreateOrConnectWithoutUpdaterInput[]
    createMany?: game_serverCreateManyUpdaterInputEnvelope
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type channel_memberUpdateManyWithoutUserNestedInput = {
    create?: XOR<channel_memberCreateWithoutUserInput, channel_memberUncheckedCreateWithoutUserInput> | channel_memberCreateWithoutUserInput[] | channel_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutUserInput | channel_memberCreateOrConnectWithoutUserInput[]
    upsert?: channel_memberUpsertWithWhereUniqueWithoutUserInput | channel_memberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: channel_memberCreateManyUserInputEnvelope
    set?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    disconnect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    delete?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    update?: channel_memberUpdateWithWhereUniqueWithoutUserInput | channel_memberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: channel_memberUpdateManyWithWhereWithoutUserInput | channel_memberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: channel_memberScalarWhereInput | channel_memberScalarWhereInput[]
  }

  export type eventUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<eventCreateWithoutCreatorInput, eventUncheckedCreateWithoutCreatorInput> | eventCreateWithoutCreatorInput[] | eventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: eventCreateOrConnectWithoutCreatorInput | eventCreateOrConnectWithoutCreatorInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutCreatorInput | eventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: eventCreateManyCreatorInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutCreatorInput | eventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: eventUpdateManyWithWhereWithoutCreatorInput | eventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type eventUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<eventCreateWithoutUpdaterInput, eventUncheckedCreateWithoutUpdaterInput> | eventCreateWithoutUpdaterInput[] | eventUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUpdaterInput | eventCreateOrConnectWithoutUpdaterInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutUpdaterInput | eventUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: eventCreateManyUpdaterInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutUpdaterInput | eventUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: eventUpdateManyWithWhereWithoutUpdaterInput | eventUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type faqUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<faqCreateWithoutCreatorInput, faqUncheckedCreateWithoutCreatorInput> | faqCreateWithoutCreatorInput[] | faqUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: faqCreateOrConnectWithoutCreatorInput | faqCreateOrConnectWithoutCreatorInput[]
    upsert?: faqUpsertWithWhereUniqueWithoutCreatorInput | faqUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: faqCreateManyCreatorInputEnvelope
    set?: faqWhereUniqueInput | faqWhereUniqueInput[]
    disconnect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    delete?: faqWhereUniqueInput | faqWhereUniqueInput[]
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    update?: faqUpdateWithWhereUniqueWithoutCreatorInput | faqUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: faqUpdateManyWithWhereWithoutCreatorInput | faqUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: faqScalarWhereInput | faqScalarWhereInput[]
  }

  export type faqUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<faqCreateWithoutUpdaterInput, faqUncheckedCreateWithoutUpdaterInput> | faqCreateWithoutUpdaterInput[] | faqUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: faqCreateOrConnectWithoutUpdaterInput | faqCreateOrConnectWithoutUpdaterInput[]
    upsert?: faqUpsertWithWhereUniqueWithoutUpdaterInput | faqUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: faqCreateManyUpdaterInputEnvelope
    set?: faqWhereUniqueInput | faqWhereUniqueInput[]
    disconnect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    delete?: faqWhereUniqueInput | faqWhereUniqueInput[]
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    update?: faqUpdateWithWhereUniqueWithoutUpdaterInput | faqUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: faqUpdateManyWithWhereWithoutUpdaterInput | faqUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: faqScalarWhereInput | faqScalarWhereInput[]
  }

  export type gameUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<gameCreateWithoutCreatedByInput, gameUncheckedCreateWithoutCreatedByInput> | gameCreateWithoutCreatedByInput[] | gameUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutCreatedByInput | gameCreateOrConnectWithoutCreatedByInput[]
    upsert?: gameUpsertWithWhereUniqueWithoutCreatedByInput | gameUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: gameCreateManyCreatedByInputEnvelope
    set?: gameWhereUniqueInput | gameWhereUniqueInput[]
    disconnect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    delete?: gameWhereUniqueInput | gameWhereUniqueInput[]
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    update?: gameUpdateWithWhereUniqueWithoutCreatedByInput | gameUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: gameUpdateManyWithWhereWithoutCreatedByInput | gameUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: gameScalarWhereInput | gameScalarWhereInput[]
  }

  export type gameUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<gameCreateWithoutUpdatedByInput, gameUncheckedCreateWithoutUpdatedByInput> | gameCreateWithoutUpdatedByInput[] | gameUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutUpdatedByInput | gameCreateOrConnectWithoutUpdatedByInput[]
    upsert?: gameUpsertWithWhereUniqueWithoutUpdatedByInput | gameUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: gameCreateManyUpdatedByInputEnvelope
    set?: gameWhereUniqueInput | gameWhereUniqueInput[]
    disconnect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    delete?: gameWhereUniqueInput | gameWhereUniqueInput[]
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    update?: gameUpdateWithWhereUniqueWithoutUpdatedByInput | gameUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: gameUpdateManyWithWhereWithoutUpdatedByInput | gameUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: gameScalarWhereInput | gameScalarWhereInput[]
  }

  export type game_sessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<game_sessionCreateWithoutUserInput, game_sessionUncheckedCreateWithoutUserInput> | game_sessionCreateWithoutUserInput[] | game_sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_sessionCreateOrConnectWithoutUserInput | game_sessionCreateOrConnectWithoutUserInput[]
    upsert?: game_sessionUpsertWithWhereUniqueWithoutUserInput | game_sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: game_sessionCreateManyUserInputEnvelope
    set?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    disconnect?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    delete?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    connect?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    update?: game_sessionUpdateWithWhereUniqueWithoutUserInput | game_sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: game_sessionUpdateManyWithWhereWithoutUserInput | game_sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: game_sessionScalarWhereInput | game_sessionScalarWhereInput[]
  }

  export type guildUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<guildCreateWithoutOwnerInput, guildUncheckedCreateWithoutOwnerInput> | guildCreateWithoutOwnerInput[] | guildUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: guildCreateOrConnectWithoutOwnerInput | guildCreateOrConnectWithoutOwnerInput[]
    upsert?: guildUpsertWithWhereUniqueWithoutOwnerInput | guildUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: guildCreateManyOwnerInputEnvelope
    set?: guildWhereUniqueInput | guildWhereUniqueInput[]
    disconnect?: guildWhereUniqueInput | guildWhereUniqueInput[]
    delete?: guildWhereUniqueInput | guildWhereUniqueInput[]
    connect?: guildWhereUniqueInput | guildWhereUniqueInput[]
    update?: guildUpdateWithWhereUniqueWithoutOwnerInput | guildUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: guildUpdateManyWithWhereWithoutOwnerInput | guildUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: guildScalarWhereInput | guildScalarWhereInput[]
  }

  export type guild_memberUpdateManyWithoutUserNestedInput = {
    create?: XOR<guild_memberCreateWithoutUserInput, guild_memberUncheckedCreateWithoutUserInput> | guild_memberCreateWithoutUserInput[] | guild_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutUserInput | guild_memberCreateOrConnectWithoutUserInput[]
    upsert?: guild_memberUpsertWithWhereUniqueWithoutUserInput | guild_memberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: guild_memberCreateManyUserInputEnvelope
    set?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    disconnect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    delete?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    update?: guild_memberUpdateWithWhereUniqueWithoutUserInput | guild_memberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: guild_memberUpdateManyWithWhereWithoutUserInput | guild_memberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: guild_memberScalarWhereInput | guild_memberScalarWhereInput[]
  }

  export type messageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<messageCreateWithoutAuthorInput, messageUncheckedCreateWithoutAuthorInput> | messageCreateWithoutAuthorInput[] | messageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: messageCreateOrConnectWithoutAuthorInput | messageCreateOrConnectWithoutAuthorInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutAuthorInput | messageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: messageCreateManyAuthorInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutAuthorInput | messageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: messageUpdateManyWithWhereWithoutAuthorInput | messageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type message_reactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<message_reactionCreateWithoutUserInput, message_reactionUncheckedCreateWithoutUserInput> | message_reactionCreateWithoutUserInput[] | message_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutUserInput | message_reactionCreateOrConnectWithoutUserInput[]
    upsert?: message_reactionUpsertWithWhereUniqueWithoutUserInput | message_reactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: message_reactionCreateManyUserInputEnvelope
    set?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    disconnect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    delete?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    update?: message_reactionUpdateWithWhereUniqueWithoutUserInput | message_reactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: message_reactionUpdateManyWithWhereWithoutUserInput | message_reactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: message_reactionScalarWhereInput | message_reactionScalarWhereInput[]
  }

  export type message_readUpdateManyWithoutUserNestedInput = {
    create?: XOR<message_readCreateWithoutUserInput, message_readUncheckedCreateWithoutUserInput> | message_readCreateWithoutUserInput[] | message_readUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutUserInput | message_readCreateOrConnectWithoutUserInput[]
    upsert?: message_readUpsertWithWhereUniqueWithoutUserInput | message_readUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: message_readCreateManyUserInputEnvelope
    set?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    disconnect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    delete?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    update?: message_readUpdateWithWhereUniqueWithoutUserInput | message_readUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: message_readUpdateManyWithWhereWithoutUserInput | message_readUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: message_readScalarWhereInput | message_readScalarWhereInput[]
  }

  export type roomUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<roomCreateWithoutOwnerInput, roomUncheckedCreateWithoutOwnerInput> | roomCreateWithoutOwnerInput[] | roomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: roomCreateOrConnectWithoutOwnerInput | roomCreateOrConnectWithoutOwnerInput[]
    upsert?: roomUpsertWithWhereUniqueWithoutOwnerInput | roomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: roomCreateManyOwnerInputEnvelope
    set?: roomWhereUniqueInput | roomWhereUniqueInput[]
    disconnect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    delete?: roomWhereUniqueInput | roomWhereUniqueInput[]
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    update?: roomUpdateWithWhereUniqueWithoutOwnerInput | roomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: roomUpdateManyWithWhereWithoutOwnerInput | roomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: roomScalarWhereInput | roomScalarWhereInput[]
  }

  export type room_participantUpdateManyWithoutUserNestedInput = {
    create?: XOR<room_participantCreateWithoutUserInput, room_participantUncheckedCreateWithoutUserInput> | room_participantCreateWithoutUserInput[] | room_participantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutUserInput | room_participantCreateOrConnectWithoutUserInput[]
    upsert?: room_participantUpsertWithWhereUniqueWithoutUserInput | room_participantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: room_participantCreateManyUserInputEnvelope
    set?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    disconnect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    delete?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    update?: room_participantUpdateWithWhereUniqueWithoutUserInput | room_participantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: room_participantUpdateManyWithWhereWithoutUserInput | room_participantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: room_participantScalarWhereInput | room_participantScalarWhereInput[]
  }

  export type room_viewUpdateManyWithoutUserNestedInput = {
    create?: XOR<room_viewCreateWithoutUserInput, room_viewUncheckedCreateWithoutUserInput> | room_viewCreateWithoutUserInput[] | room_viewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutUserInput | room_viewCreateOrConnectWithoutUserInput[]
    upsert?: room_viewUpsertWithWhereUniqueWithoutUserInput | room_viewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: room_viewCreateManyUserInputEnvelope
    set?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    disconnect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    delete?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    update?: room_viewUpdateWithWhereUniqueWithoutUserInput | room_viewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: room_viewUpdateManyWithWhereWithoutUserInput | room_viewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: room_viewScalarWhereInput | room_viewScalarWhereInput[]
  }

  export type user_settingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<user_settingsCreateWithoutUserInput, user_settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_settingsCreateOrConnectWithoutUserInput
    upsert?: user_settingsUpsertWithoutUserInput
    disconnect?: user_settingsWhereInput | boolean
    delete?: user_settingsWhereInput | boolean
    connect?: user_settingsWhereUniqueInput
    update?: XOR<XOR<user_settingsUpdateToOneWithWhereWithoutUserInput, user_settingsUpdateWithoutUserInput>, user_settingsUncheckedUpdateWithoutUserInput>
  }

  export type editionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<editionCreateWithoutCreatorInput, editionUncheckedCreateWithoutCreatorInput> | editionCreateWithoutCreatorInput[] | editionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: editionCreateOrConnectWithoutCreatorInput | editionCreateOrConnectWithoutCreatorInput[]
    upsert?: editionUpsertWithWhereUniqueWithoutCreatorInput | editionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: editionCreateManyCreatorInputEnvelope
    set?: editionWhereUniqueInput | editionWhereUniqueInput[]
    disconnect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    delete?: editionWhereUniqueInput | editionWhereUniqueInput[]
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    update?: editionUpdateWithWhereUniqueWithoutCreatorInput | editionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: editionUpdateManyWithWhereWithoutCreatorInput | editionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: editionScalarWhereInput | editionScalarWhereInput[]
  }

  export type editionUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<editionCreateWithoutUpdaterInput, editionUncheckedCreateWithoutUpdaterInput> | editionCreateWithoutUpdaterInput[] | editionUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: editionCreateOrConnectWithoutUpdaterInput | editionCreateOrConnectWithoutUpdaterInput[]
    upsert?: editionUpsertWithWhereUniqueWithoutUpdaterInput | editionUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: editionCreateManyUpdaterInputEnvelope
    set?: editionWhereUniqueInput | editionWhereUniqueInput[]
    disconnect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    delete?: editionWhereUniqueInput | editionWhereUniqueInput[]
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    update?: editionUpdateWithWhereUniqueWithoutUpdaterInput | editionUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: editionUpdateManyWithWhereWithoutUpdaterInput | editionUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: editionScalarWhereInput | editionScalarWhereInput[]
  }

  export type table_seatUpdateManyWithoutUserNestedInput = {
    create?: XOR<table_seatCreateWithoutUserInput, table_seatUncheckedCreateWithoutUserInput> | table_seatCreateWithoutUserInput[] | table_seatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutUserInput | table_seatCreateOrConnectWithoutUserInput[]
    upsert?: table_seatUpsertWithWhereUniqueWithoutUserInput | table_seatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: table_seatCreateManyUserInputEnvelope
    set?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    disconnect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    delete?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    update?: table_seatUpdateWithWhereUniqueWithoutUserInput | table_seatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: table_seatUpdateManyWithWhereWithoutUserInput | table_seatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: table_seatScalarWhereInput | table_seatScalarWhereInput[]
  }

  export type game_serverUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<game_serverCreateWithoutCreatorInput, game_serverUncheckedCreateWithoutCreatorInput> | game_serverCreateWithoutCreatorInput[] | game_serverUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutCreatorInput | game_serverCreateOrConnectWithoutCreatorInput[]
    upsert?: game_serverUpsertWithWhereUniqueWithoutCreatorInput | game_serverUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: game_serverCreateManyCreatorInputEnvelope
    set?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    disconnect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    delete?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    update?: game_serverUpdateWithWhereUniqueWithoutCreatorInput | game_serverUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: game_serverUpdateManyWithWhereWithoutCreatorInput | game_serverUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: game_serverScalarWhereInput | game_serverScalarWhereInput[]
  }

  export type game_serverUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<game_serverCreateWithoutUpdaterInput, game_serverUncheckedCreateWithoutUpdaterInput> | game_serverCreateWithoutUpdaterInput[] | game_serverUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutUpdaterInput | game_serverCreateOrConnectWithoutUpdaterInput[]
    upsert?: game_serverUpsertWithWhereUniqueWithoutUpdaterInput | game_serverUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: game_serverCreateManyUpdaterInputEnvelope
    set?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    disconnect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    delete?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    update?: game_serverUpdateWithWhereUniqueWithoutUpdaterInput | game_serverUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: game_serverUpdateManyWithWhereWithoutUpdaterInput | game_serverUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: game_serverScalarWhereInput | game_serverScalarWhereInput[]
  }

  export type channel_memberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<channel_memberCreateWithoutUserInput, channel_memberUncheckedCreateWithoutUserInput> | channel_memberCreateWithoutUserInput[] | channel_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutUserInput | channel_memberCreateOrConnectWithoutUserInput[]
    upsert?: channel_memberUpsertWithWhereUniqueWithoutUserInput | channel_memberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: channel_memberCreateManyUserInputEnvelope
    set?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    disconnect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    delete?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    update?: channel_memberUpdateWithWhereUniqueWithoutUserInput | channel_memberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: channel_memberUpdateManyWithWhereWithoutUserInput | channel_memberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: channel_memberScalarWhereInput | channel_memberScalarWhereInput[]
  }

  export type eventUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<eventCreateWithoutCreatorInput, eventUncheckedCreateWithoutCreatorInput> | eventCreateWithoutCreatorInput[] | eventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: eventCreateOrConnectWithoutCreatorInput | eventCreateOrConnectWithoutCreatorInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutCreatorInput | eventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: eventCreateManyCreatorInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutCreatorInput | eventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: eventUpdateManyWithWhereWithoutCreatorInput | eventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type eventUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<eventCreateWithoutUpdaterInput, eventUncheckedCreateWithoutUpdaterInput> | eventCreateWithoutUpdaterInput[] | eventUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUpdaterInput | eventCreateOrConnectWithoutUpdaterInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutUpdaterInput | eventUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: eventCreateManyUpdaterInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutUpdaterInput | eventUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: eventUpdateManyWithWhereWithoutUpdaterInput | eventUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type faqUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<faqCreateWithoutCreatorInput, faqUncheckedCreateWithoutCreatorInput> | faqCreateWithoutCreatorInput[] | faqUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: faqCreateOrConnectWithoutCreatorInput | faqCreateOrConnectWithoutCreatorInput[]
    upsert?: faqUpsertWithWhereUniqueWithoutCreatorInput | faqUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: faqCreateManyCreatorInputEnvelope
    set?: faqWhereUniqueInput | faqWhereUniqueInput[]
    disconnect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    delete?: faqWhereUniqueInput | faqWhereUniqueInput[]
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    update?: faqUpdateWithWhereUniqueWithoutCreatorInput | faqUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: faqUpdateManyWithWhereWithoutCreatorInput | faqUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: faqScalarWhereInput | faqScalarWhereInput[]
  }

  export type faqUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<faqCreateWithoutUpdaterInput, faqUncheckedCreateWithoutUpdaterInput> | faqCreateWithoutUpdaterInput[] | faqUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: faqCreateOrConnectWithoutUpdaterInput | faqCreateOrConnectWithoutUpdaterInput[]
    upsert?: faqUpsertWithWhereUniqueWithoutUpdaterInput | faqUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: faqCreateManyUpdaterInputEnvelope
    set?: faqWhereUniqueInput | faqWhereUniqueInput[]
    disconnect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    delete?: faqWhereUniqueInput | faqWhereUniqueInput[]
    connect?: faqWhereUniqueInput | faqWhereUniqueInput[]
    update?: faqUpdateWithWhereUniqueWithoutUpdaterInput | faqUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: faqUpdateManyWithWhereWithoutUpdaterInput | faqUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: faqScalarWhereInput | faqScalarWhereInput[]
  }

  export type gameUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<gameCreateWithoutCreatedByInput, gameUncheckedCreateWithoutCreatedByInput> | gameCreateWithoutCreatedByInput[] | gameUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutCreatedByInput | gameCreateOrConnectWithoutCreatedByInput[]
    upsert?: gameUpsertWithWhereUniqueWithoutCreatedByInput | gameUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: gameCreateManyCreatedByInputEnvelope
    set?: gameWhereUniqueInput | gameWhereUniqueInput[]
    disconnect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    delete?: gameWhereUniqueInput | gameWhereUniqueInput[]
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    update?: gameUpdateWithWhereUniqueWithoutCreatedByInput | gameUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: gameUpdateManyWithWhereWithoutCreatedByInput | gameUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: gameScalarWhereInput | gameScalarWhereInput[]
  }

  export type gameUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<gameCreateWithoutUpdatedByInput, gameUncheckedCreateWithoutUpdatedByInput> | gameCreateWithoutUpdatedByInput[] | gameUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: gameCreateOrConnectWithoutUpdatedByInput | gameCreateOrConnectWithoutUpdatedByInput[]
    upsert?: gameUpsertWithWhereUniqueWithoutUpdatedByInput | gameUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: gameCreateManyUpdatedByInputEnvelope
    set?: gameWhereUniqueInput | gameWhereUniqueInput[]
    disconnect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    delete?: gameWhereUniqueInput | gameWhereUniqueInput[]
    connect?: gameWhereUniqueInput | gameWhereUniqueInput[]
    update?: gameUpdateWithWhereUniqueWithoutUpdatedByInput | gameUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: gameUpdateManyWithWhereWithoutUpdatedByInput | gameUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: gameScalarWhereInput | gameScalarWhereInput[]
  }

  export type game_sessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<game_sessionCreateWithoutUserInput, game_sessionUncheckedCreateWithoutUserInput> | game_sessionCreateWithoutUserInput[] | game_sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: game_sessionCreateOrConnectWithoutUserInput | game_sessionCreateOrConnectWithoutUserInput[]
    upsert?: game_sessionUpsertWithWhereUniqueWithoutUserInput | game_sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: game_sessionCreateManyUserInputEnvelope
    set?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    disconnect?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    delete?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    connect?: game_sessionWhereUniqueInput | game_sessionWhereUniqueInput[]
    update?: game_sessionUpdateWithWhereUniqueWithoutUserInput | game_sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: game_sessionUpdateManyWithWhereWithoutUserInput | game_sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: game_sessionScalarWhereInput | game_sessionScalarWhereInput[]
  }

  export type guildUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<guildCreateWithoutOwnerInput, guildUncheckedCreateWithoutOwnerInput> | guildCreateWithoutOwnerInput[] | guildUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: guildCreateOrConnectWithoutOwnerInput | guildCreateOrConnectWithoutOwnerInput[]
    upsert?: guildUpsertWithWhereUniqueWithoutOwnerInput | guildUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: guildCreateManyOwnerInputEnvelope
    set?: guildWhereUniqueInput | guildWhereUniqueInput[]
    disconnect?: guildWhereUniqueInput | guildWhereUniqueInput[]
    delete?: guildWhereUniqueInput | guildWhereUniqueInput[]
    connect?: guildWhereUniqueInput | guildWhereUniqueInput[]
    update?: guildUpdateWithWhereUniqueWithoutOwnerInput | guildUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: guildUpdateManyWithWhereWithoutOwnerInput | guildUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: guildScalarWhereInput | guildScalarWhereInput[]
  }

  export type guild_memberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<guild_memberCreateWithoutUserInput, guild_memberUncheckedCreateWithoutUserInput> | guild_memberCreateWithoutUserInput[] | guild_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutUserInput | guild_memberCreateOrConnectWithoutUserInput[]
    upsert?: guild_memberUpsertWithWhereUniqueWithoutUserInput | guild_memberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: guild_memberCreateManyUserInputEnvelope
    set?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    disconnect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    delete?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    update?: guild_memberUpdateWithWhereUniqueWithoutUserInput | guild_memberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: guild_memberUpdateManyWithWhereWithoutUserInput | guild_memberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: guild_memberScalarWhereInput | guild_memberScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<messageCreateWithoutAuthorInput, messageUncheckedCreateWithoutAuthorInput> | messageCreateWithoutAuthorInput[] | messageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: messageCreateOrConnectWithoutAuthorInput | messageCreateOrConnectWithoutAuthorInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutAuthorInput | messageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: messageCreateManyAuthorInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutAuthorInput | messageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: messageUpdateManyWithWhereWithoutAuthorInput | messageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type message_reactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<message_reactionCreateWithoutUserInput, message_reactionUncheckedCreateWithoutUserInput> | message_reactionCreateWithoutUserInput[] | message_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutUserInput | message_reactionCreateOrConnectWithoutUserInput[]
    upsert?: message_reactionUpsertWithWhereUniqueWithoutUserInput | message_reactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: message_reactionCreateManyUserInputEnvelope
    set?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    disconnect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    delete?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    update?: message_reactionUpdateWithWhereUniqueWithoutUserInput | message_reactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: message_reactionUpdateManyWithWhereWithoutUserInput | message_reactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: message_reactionScalarWhereInput | message_reactionScalarWhereInput[]
  }

  export type message_readUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<message_readCreateWithoutUserInput, message_readUncheckedCreateWithoutUserInput> | message_readCreateWithoutUserInput[] | message_readUncheckedCreateWithoutUserInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutUserInput | message_readCreateOrConnectWithoutUserInput[]
    upsert?: message_readUpsertWithWhereUniqueWithoutUserInput | message_readUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: message_readCreateManyUserInputEnvelope
    set?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    disconnect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    delete?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    update?: message_readUpdateWithWhereUniqueWithoutUserInput | message_readUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: message_readUpdateManyWithWhereWithoutUserInput | message_readUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: message_readScalarWhereInput | message_readScalarWhereInput[]
  }

  export type roomUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<roomCreateWithoutOwnerInput, roomUncheckedCreateWithoutOwnerInput> | roomCreateWithoutOwnerInput[] | roomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: roomCreateOrConnectWithoutOwnerInput | roomCreateOrConnectWithoutOwnerInput[]
    upsert?: roomUpsertWithWhereUniqueWithoutOwnerInput | roomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: roomCreateManyOwnerInputEnvelope
    set?: roomWhereUniqueInput | roomWhereUniqueInput[]
    disconnect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    delete?: roomWhereUniqueInput | roomWhereUniqueInput[]
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    update?: roomUpdateWithWhereUniqueWithoutOwnerInput | roomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: roomUpdateManyWithWhereWithoutOwnerInput | roomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: roomScalarWhereInput | roomScalarWhereInput[]
  }

  export type room_participantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<room_participantCreateWithoutUserInput, room_participantUncheckedCreateWithoutUserInput> | room_participantCreateWithoutUserInput[] | room_participantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutUserInput | room_participantCreateOrConnectWithoutUserInput[]
    upsert?: room_participantUpsertWithWhereUniqueWithoutUserInput | room_participantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: room_participantCreateManyUserInputEnvelope
    set?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    disconnect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    delete?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    update?: room_participantUpdateWithWhereUniqueWithoutUserInput | room_participantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: room_participantUpdateManyWithWhereWithoutUserInput | room_participantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: room_participantScalarWhereInput | room_participantScalarWhereInput[]
  }

  export type room_viewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<room_viewCreateWithoutUserInput, room_viewUncheckedCreateWithoutUserInput> | room_viewCreateWithoutUserInput[] | room_viewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutUserInput | room_viewCreateOrConnectWithoutUserInput[]
    upsert?: room_viewUpsertWithWhereUniqueWithoutUserInput | room_viewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: room_viewCreateManyUserInputEnvelope
    set?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    disconnect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    delete?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    update?: room_viewUpdateWithWhereUniqueWithoutUserInput | room_viewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: room_viewUpdateManyWithWhereWithoutUserInput | room_viewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: room_viewScalarWhereInput | room_viewScalarWhereInput[]
  }

  export type user_settingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<user_settingsCreateWithoutUserInput, user_settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_settingsCreateOrConnectWithoutUserInput
    upsert?: user_settingsUpsertWithoutUserInput
    disconnect?: user_settingsWhereInput | boolean
    delete?: user_settingsWhereInput | boolean
    connect?: user_settingsWhereUniqueInput
    update?: XOR<XOR<user_settingsUpdateToOneWithWhereWithoutUserInput, user_settingsUpdateWithoutUserInput>, user_settingsUncheckedUpdateWithoutUserInput>
  }

  export type editionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<editionCreateWithoutCreatorInput, editionUncheckedCreateWithoutCreatorInput> | editionCreateWithoutCreatorInput[] | editionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: editionCreateOrConnectWithoutCreatorInput | editionCreateOrConnectWithoutCreatorInput[]
    upsert?: editionUpsertWithWhereUniqueWithoutCreatorInput | editionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: editionCreateManyCreatorInputEnvelope
    set?: editionWhereUniqueInput | editionWhereUniqueInput[]
    disconnect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    delete?: editionWhereUniqueInput | editionWhereUniqueInput[]
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    update?: editionUpdateWithWhereUniqueWithoutCreatorInput | editionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: editionUpdateManyWithWhereWithoutCreatorInput | editionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: editionScalarWhereInput | editionScalarWhereInput[]
  }

  export type editionUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<editionCreateWithoutUpdaterInput, editionUncheckedCreateWithoutUpdaterInput> | editionCreateWithoutUpdaterInput[] | editionUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: editionCreateOrConnectWithoutUpdaterInput | editionCreateOrConnectWithoutUpdaterInput[]
    upsert?: editionUpsertWithWhereUniqueWithoutUpdaterInput | editionUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: editionCreateManyUpdaterInputEnvelope
    set?: editionWhereUniqueInput | editionWhereUniqueInput[]
    disconnect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    delete?: editionWhereUniqueInput | editionWhereUniqueInput[]
    connect?: editionWhereUniqueInput | editionWhereUniqueInput[]
    update?: editionUpdateWithWhereUniqueWithoutUpdaterInput | editionUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: editionUpdateManyWithWhereWithoutUpdaterInput | editionUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: editionScalarWhereInput | editionScalarWhereInput[]
  }

  export type table_seatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<table_seatCreateWithoutUserInput, table_seatUncheckedCreateWithoutUserInput> | table_seatCreateWithoutUserInput[] | table_seatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutUserInput | table_seatCreateOrConnectWithoutUserInput[]
    upsert?: table_seatUpsertWithWhereUniqueWithoutUserInput | table_seatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: table_seatCreateManyUserInputEnvelope
    set?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    disconnect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    delete?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    update?: table_seatUpdateWithWhereUniqueWithoutUserInput | table_seatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: table_seatUpdateManyWithWhereWithoutUserInput | table_seatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: table_seatScalarWhereInput | table_seatScalarWhereInput[]
  }

  export type game_serverUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<game_serverCreateWithoutCreatorInput, game_serverUncheckedCreateWithoutCreatorInput> | game_serverCreateWithoutCreatorInput[] | game_serverUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutCreatorInput | game_serverCreateOrConnectWithoutCreatorInput[]
    upsert?: game_serverUpsertWithWhereUniqueWithoutCreatorInput | game_serverUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: game_serverCreateManyCreatorInputEnvelope
    set?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    disconnect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    delete?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    update?: game_serverUpdateWithWhereUniqueWithoutCreatorInput | game_serverUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: game_serverUpdateManyWithWhereWithoutCreatorInput | game_serverUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: game_serverScalarWhereInput | game_serverScalarWhereInput[]
  }

  export type game_serverUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<game_serverCreateWithoutUpdaterInput, game_serverUncheckedCreateWithoutUpdaterInput> | game_serverCreateWithoutUpdaterInput[] | game_serverUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: game_serverCreateOrConnectWithoutUpdaterInput | game_serverCreateOrConnectWithoutUpdaterInput[]
    upsert?: game_serverUpsertWithWhereUniqueWithoutUpdaterInput | game_serverUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: game_serverCreateManyUpdaterInputEnvelope
    set?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    disconnect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    delete?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    connect?: game_serverWhereUniqueInput | game_serverWhereUniqueInput[]
    update?: game_serverUpdateWithWhereUniqueWithoutUpdaterInput | game_serverUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: game_serverUpdateManyWithWhereWithoutUpdaterInput | game_serverUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: game_serverScalarWhereInput | game_serverScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutUser_settingsInput = {
    create?: XOR<userCreateWithoutUser_settingsInput, userUncheckedCreateWithoutUser_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_settingsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUser_settingsNestedInput = {
    create?: XOR<userCreateWithoutUser_settingsInput, userUncheckedCreateWithoutUser_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_settingsInput
    upsert?: userUpsertWithoutUser_settingsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUser_settingsInput, userUpdateWithoutUser_settingsInput>, userUncheckedUpdateWithoutUser_settingsInput>
  }

  export type userCreateNestedOneWithoutGame_sessionInput = {
    create?: XOR<userCreateWithoutGame_sessionInput, userUncheckedCreateWithoutGame_sessionInput>
    connectOrCreate?: userCreateOrConnectWithoutGame_sessionInput
    connect?: userWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUpdateOneRequiredWithoutGame_sessionNestedInput = {
    create?: XOR<userCreateWithoutGame_sessionInput, userUncheckedCreateWithoutGame_sessionInput>
    connectOrCreate?: userCreateOrConnectWithoutGame_sessionInput
    upsert?: userUpsertWithoutGame_sessionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGame_sessionInput, userUpdateWithoutGame_sessionInput>, userUncheckedUpdateWithoutGame_sessionInput>
  }

  export type userCreateNestedOneWithoutEvent_createdInput = {
    create?: XOR<userCreateWithoutEvent_createdInput, userUncheckedCreateWithoutEvent_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutEvent_createdInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEvent_updatedInput = {
    create?: XOR<userCreateWithoutEvent_updatedInput, userUncheckedCreateWithoutEvent_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutEvent_updatedInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutEvent_createdNestedInput = {
    create?: XOR<userCreateWithoutEvent_createdInput, userUncheckedCreateWithoutEvent_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutEvent_createdInput
    upsert?: userUpsertWithoutEvent_createdInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEvent_createdInput, userUpdateWithoutEvent_createdInput>, userUncheckedUpdateWithoutEvent_createdInput>
  }

  export type userUpdateOneRequiredWithoutEvent_updatedNestedInput = {
    create?: XOR<userCreateWithoutEvent_updatedInput, userUncheckedCreateWithoutEvent_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutEvent_updatedInput
    upsert?: userUpsertWithoutEvent_updatedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEvent_updatedInput, userUpdateWithoutEvent_updatedInput>, userUncheckedUpdateWithoutEvent_updatedInput>
  }

  export type userCreateNestedOneWithoutGamesCreatedInput = {
    create?: XOR<userCreateWithoutGamesCreatedInput, userUncheckedCreateWithoutGamesCreatedInput>
    connectOrCreate?: userCreateOrConnectWithoutGamesCreatedInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutGamesUpdatedInput = {
    create?: XOR<userCreateWithoutGamesUpdatedInput, userUncheckedCreateWithoutGamesUpdatedInput>
    connectOrCreate?: userCreateOrConnectWithoutGamesUpdatedInput
    connect?: userWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUpdateOneRequiredWithoutGamesCreatedNestedInput = {
    create?: XOR<userCreateWithoutGamesCreatedInput, userUncheckedCreateWithoutGamesCreatedInput>
    connectOrCreate?: userCreateOrConnectWithoutGamesCreatedInput
    upsert?: userUpsertWithoutGamesCreatedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGamesCreatedInput, userUpdateWithoutGamesCreatedInput>, userUncheckedUpdateWithoutGamesCreatedInput>
  }

  export type userUpdateOneRequiredWithoutGamesUpdatedNestedInput = {
    create?: XOR<userCreateWithoutGamesUpdatedInput, userUncheckedCreateWithoutGamesUpdatedInput>
    connectOrCreate?: userCreateOrConnectWithoutGamesUpdatedInput
    upsert?: userUpsertWithoutGamesUpdatedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGamesUpdatedInput, userUpdateWithoutGamesUpdatedInput>, userUncheckedUpdateWithoutGamesUpdatedInput>
  }

  export type userCreateNestedOneWithoutGame_server_createdInput = {
    create?: XOR<userCreateWithoutGame_server_createdInput, userUncheckedCreateWithoutGame_server_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutGame_server_createdInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutGame_server_updatedInput = {
    create?: XOR<userCreateWithoutGame_server_updatedInput, userUncheckedCreateWithoutGame_server_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutGame_server_updatedInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutGame_server_createdNestedInput = {
    create?: XOR<userCreateWithoutGame_server_createdInput, userUncheckedCreateWithoutGame_server_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutGame_server_createdInput
    upsert?: userUpsertWithoutGame_server_createdInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGame_server_createdInput, userUpdateWithoutGame_server_createdInput>, userUncheckedUpdateWithoutGame_server_createdInput>
  }

  export type userUpdateOneRequiredWithoutGame_server_updatedNestedInput = {
    create?: XOR<userCreateWithoutGame_server_updatedInput, userUncheckedCreateWithoutGame_server_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutGame_server_updatedInput
    upsert?: userUpsertWithoutGame_server_updatedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGame_server_updatedInput, userUpdateWithoutGame_server_updatedInput>, userUncheckedUpdateWithoutGame_server_updatedInput>
  }

  export type userCreateNestedOneWithoutFaq_createdInput = {
    create?: XOR<userCreateWithoutFaq_createdInput, userUncheckedCreateWithoutFaq_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutFaq_createdInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutFaq_updatedInput = {
    create?: XOR<userCreateWithoutFaq_updatedInput, userUncheckedCreateWithoutFaq_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutFaq_updatedInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutFaq_createdNestedInput = {
    create?: XOR<userCreateWithoutFaq_createdInput, userUncheckedCreateWithoutFaq_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutFaq_createdInput
    upsert?: userUpsertWithoutFaq_createdInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFaq_createdInput, userUpdateWithoutFaq_createdInput>, userUncheckedUpdateWithoutFaq_createdInput>
  }

  export type userUpdateOneRequiredWithoutFaq_updatedNestedInput = {
    create?: XOR<userCreateWithoutFaq_updatedInput, userUncheckedCreateWithoutFaq_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutFaq_updatedInput
    upsert?: userUpsertWithoutFaq_updatedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFaq_updatedInput, userUpdateWithoutFaq_updatedInput>, userUncheckedUpdateWithoutFaq_updatedInput>
  }

  export type channelCreateNestedManyWithoutGuildInput = {
    create?: XOR<channelCreateWithoutGuildInput, channelUncheckedCreateWithoutGuildInput> | channelCreateWithoutGuildInput[] | channelUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: channelCreateOrConnectWithoutGuildInput | channelCreateOrConnectWithoutGuildInput[]
    createMany?: channelCreateManyGuildInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutGuildInput = {
    create?: XOR<userCreateWithoutGuildInput, userUncheckedCreateWithoutGuildInput>
    connectOrCreate?: userCreateOrConnectWithoutGuildInput
    connect?: userWhereUniqueInput
  }

  export type guild_memberCreateNestedManyWithoutGuildInput = {
    create?: XOR<guild_memberCreateWithoutGuildInput, guild_memberUncheckedCreateWithoutGuildInput> | guild_memberCreateWithoutGuildInput[] | guild_memberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutGuildInput | guild_memberCreateOrConnectWithoutGuildInput[]
    createMany?: guild_memberCreateManyGuildInputEnvelope
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
  }

  export type roomCreateNestedManyWithoutGuildInput = {
    create?: XOR<roomCreateWithoutGuildInput, roomUncheckedCreateWithoutGuildInput> | roomCreateWithoutGuildInput[] | roomUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: roomCreateOrConnectWithoutGuildInput | roomCreateOrConnectWithoutGuildInput[]
    createMany?: roomCreateManyGuildInputEnvelope
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
  }

  export type channelUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<channelCreateWithoutGuildInput, channelUncheckedCreateWithoutGuildInput> | channelCreateWithoutGuildInput[] | channelUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: channelCreateOrConnectWithoutGuildInput | channelCreateOrConnectWithoutGuildInput[]
    createMany?: channelCreateManyGuildInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type guild_memberUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<guild_memberCreateWithoutGuildInput, guild_memberUncheckedCreateWithoutGuildInput> | guild_memberCreateWithoutGuildInput[] | guild_memberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutGuildInput | guild_memberCreateOrConnectWithoutGuildInput[]
    createMany?: guild_memberCreateManyGuildInputEnvelope
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
  }

  export type roomUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<roomCreateWithoutGuildInput, roomUncheckedCreateWithoutGuildInput> | roomCreateWithoutGuildInput[] | roomUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: roomCreateOrConnectWithoutGuildInput | roomCreateOrConnectWithoutGuildInput[]
    createMany?: roomCreateManyGuildInputEnvelope
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
  }

  export type channelUpdateManyWithoutGuildNestedInput = {
    create?: XOR<channelCreateWithoutGuildInput, channelUncheckedCreateWithoutGuildInput> | channelCreateWithoutGuildInput[] | channelUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: channelCreateOrConnectWithoutGuildInput | channelCreateOrConnectWithoutGuildInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutGuildInput | channelUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: channelCreateManyGuildInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutGuildInput | channelUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: channelUpdateManyWithWhereWithoutGuildInput | channelUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutGuildNestedInput = {
    create?: XOR<userCreateWithoutGuildInput, userUncheckedCreateWithoutGuildInput>
    connectOrCreate?: userCreateOrConnectWithoutGuildInput
    upsert?: userUpsertWithoutGuildInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGuildInput, userUpdateWithoutGuildInput>, userUncheckedUpdateWithoutGuildInput>
  }

  export type guild_memberUpdateManyWithoutGuildNestedInput = {
    create?: XOR<guild_memberCreateWithoutGuildInput, guild_memberUncheckedCreateWithoutGuildInput> | guild_memberCreateWithoutGuildInput[] | guild_memberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutGuildInput | guild_memberCreateOrConnectWithoutGuildInput[]
    upsert?: guild_memberUpsertWithWhereUniqueWithoutGuildInput | guild_memberUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: guild_memberCreateManyGuildInputEnvelope
    set?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    disconnect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    delete?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    update?: guild_memberUpdateWithWhereUniqueWithoutGuildInput | guild_memberUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: guild_memberUpdateManyWithWhereWithoutGuildInput | guild_memberUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: guild_memberScalarWhereInput | guild_memberScalarWhereInput[]
  }

  export type roomUpdateManyWithoutGuildNestedInput = {
    create?: XOR<roomCreateWithoutGuildInput, roomUncheckedCreateWithoutGuildInput> | roomCreateWithoutGuildInput[] | roomUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: roomCreateOrConnectWithoutGuildInput | roomCreateOrConnectWithoutGuildInput[]
    upsert?: roomUpsertWithWhereUniqueWithoutGuildInput | roomUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: roomCreateManyGuildInputEnvelope
    set?: roomWhereUniqueInput | roomWhereUniqueInput[]
    disconnect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    delete?: roomWhereUniqueInput | roomWhereUniqueInput[]
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    update?: roomUpdateWithWhereUniqueWithoutGuildInput | roomUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: roomUpdateManyWithWhereWithoutGuildInput | roomUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: roomScalarWhereInput | roomScalarWhereInput[]
  }

  export type channelUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<channelCreateWithoutGuildInput, channelUncheckedCreateWithoutGuildInput> | channelCreateWithoutGuildInput[] | channelUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: channelCreateOrConnectWithoutGuildInput | channelCreateOrConnectWithoutGuildInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutGuildInput | channelUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: channelCreateManyGuildInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutGuildInput | channelUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: channelUpdateManyWithWhereWithoutGuildInput | channelUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type guild_memberUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<guild_memberCreateWithoutGuildInput, guild_memberUncheckedCreateWithoutGuildInput> | guild_memberCreateWithoutGuildInput[] | guild_memberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: guild_memberCreateOrConnectWithoutGuildInput | guild_memberCreateOrConnectWithoutGuildInput[]
    upsert?: guild_memberUpsertWithWhereUniqueWithoutGuildInput | guild_memberUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: guild_memberCreateManyGuildInputEnvelope
    set?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    disconnect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    delete?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    connect?: guild_memberWhereUniqueInput | guild_memberWhereUniqueInput[]
    update?: guild_memberUpdateWithWhereUniqueWithoutGuildInput | guild_memberUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: guild_memberUpdateManyWithWhereWithoutGuildInput | guild_memberUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: guild_memberScalarWhereInput | guild_memberScalarWhereInput[]
  }

  export type roomUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<roomCreateWithoutGuildInput, roomUncheckedCreateWithoutGuildInput> | roomCreateWithoutGuildInput[] | roomUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: roomCreateOrConnectWithoutGuildInput | roomCreateOrConnectWithoutGuildInput[]
    upsert?: roomUpsertWithWhereUniqueWithoutGuildInput | roomUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: roomCreateManyGuildInputEnvelope
    set?: roomWhereUniqueInput | roomWhereUniqueInput[]
    disconnect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    delete?: roomWhereUniqueInput | roomWhereUniqueInput[]
    connect?: roomWhereUniqueInput | roomWhereUniqueInput[]
    update?: roomUpdateWithWhereUniqueWithoutGuildInput | roomUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: roomUpdateManyWithWhereWithoutGuildInput | roomUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: roomScalarWhereInput | roomScalarWhereInput[]
  }

  export type guildCreateNestedOneWithoutMembersInput = {
    create?: XOR<guildCreateWithoutMembersInput, guildUncheckedCreateWithoutMembersInput>
    connectOrCreate?: guildCreateOrConnectWithoutMembersInput
    connect?: guildWhereUniqueInput
  }

  export type userCreateNestedOneWithoutGuild_membershipsInput = {
    create?: XOR<userCreateWithoutGuild_membershipsInput, userUncheckedCreateWithoutGuild_membershipsInput>
    connectOrCreate?: userCreateOrConnectWithoutGuild_membershipsInput
    connect?: userWhereUniqueInput
  }

  export type guildUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<guildCreateWithoutMembersInput, guildUncheckedCreateWithoutMembersInput>
    connectOrCreate?: guildCreateOrConnectWithoutMembersInput
    upsert?: guildUpsertWithoutMembersInput
    connect?: guildWhereUniqueInput
    update?: XOR<XOR<guildUpdateToOneWithWhereWithoutMembersInput, guildUpdateWithoutMembersInput>, guildUncheckedUpdateWithoutMembersInput>
  }

  export type userUpdateOneRequiredWithoutGuild_membershipsNestedInput = {
    create?: XOR<userCreateWithoutGuild_membershipsInput, userUncheckedCreateWithoutGuild_membershipsInput>
    connectOrCreate?: userCreateOrConnectWithoutGuild_membershipsInput
    upsert?: userUpsertWithoutGuild_membershipsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGuild_membershipsInput, userUpdateWithoutGuild_membershipsInput>, userUncheckedUpdateWithoutGuild_membershipsInput>
  }

  export type guildCreateNestedOneWithoutChannelsInput = {
    create?: XOR<guildCreateWithoutChannelsInput, guildUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: guildCreateOrConnectWithoutChannelsInput
    connect?: guildWhereUniqueInput
  }

  export type channelCreateNestedOneWithoutChildrenInput = {
    create?: XOR<channelCreateWithoutChildrenInput, channelUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: channelCreateOrConnectWithoutChildrenInput
    connect?: channelWhereUniqueInput
  }

  export type channelCreateNestedManyWithoutParentInput = {
    create?: XOR<channelCreateWithoutParentInput, channelUncheckedCreateWithoutParentInput> | channelCreateWithoutParentInput[] | channelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: channelCreateOrConnectWithoutParentInput | channelCreateOrConnectWithoutParentInput[]
    createMany?: channelCreateManyParentInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type channel_memberCreateNestedManyWithoutChannelInput = {
    create?: XOR<channel_memberCreateWithoutChannelInput, channel_memberUncheckedCreateWithoutChannelInput> | channel_memberCreateWithoutChannelInput[] | channel_memberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutChannelInput | channel_memberCreateOrConnectWithoutChannelInput[]
    createMany?: channel_memberCreateManyChannelInputEnvelope
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
  }

  export type roomCreateNestedOneWithoutChannelInput = {
    create?: XOR<roomCreateWithoutChannelInput, roomUncheckedCreateWithoutChannelInput>
    connectOrCreate?: roomCreateOrConnectWithoutChannelInput
    connect?: roomWhereUniqueInput
  }

  export type channelUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<channelCreateWithoutParentInput, channelUncheckedCreateWithoutParentInput> | channelCreateWithoutParentInput[] | channelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: channelCreateOrConnectWithoutParentInput | channelCreateOrConnectWithoutParentInput[]
    createMany?: channelCreateManyParentInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type channel_memberUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<channel_memberCreateWithoutChannelInput, channel_memberUncheckedCreateWithoutChannelInput> | channel_memberCreateWithoutChannelInput[] | channel_memberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutChannelInput | channel_memberCreateOrConnectWithoutChannelInput[]
    createMany?: channel_memberCreateManyChannelInputEnvelope
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
  }

  export type roomUncheckedCreateNestedOneWithoutChannelInput = {
    create?: XOR<roomCreateWithoutChannelInput, roomUncheckedCreateWithoutChannelInput>
    connectOrCreate?: roomCreateOrConnectWithoutChannelInput
    connect?: roomWhereUniqueInput
  }

  export type Enumchannel_typeFieldUpdateOperationsInput = {
    set?: $Enums.channel_type
  }

  export type guildUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<guildCreateWithoutChannelsInput, guildUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: guildCreateOrConnectWithoutChannelsInput
    upsert?: guildUpsertWithoutChannelsInput
    connect?: guildWhereUniqueInput
    update?: XOR<XOR<guildUpdateToOneWithWhereWithoutChannelsInput, guildUpdateWithoutChannelsInput>, guildUncheckedUpdateWithoutChannelsInput>
  }

  export type channelUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<channelCreateWithoutChildrenInput, channelUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: channelCreateOrConnectWithoutChildrenInput
    upsert?: channelUpsertWithoutChildrenInput
    disconnect?: channelWhereInput | boolean
    delete?: channelWhereInput | boolean
    connect?: channelWhereUniqueInput
    update?: XOR<XOR<channelUpdateToOneWithWhereWithoutChildrenInput, channelUpdateWithoutChildrenInput>, channelUncheckedUpdateWithoutChildrenInput>
  }

  export type channelUpdateManyWithoutParentNestedInput = {
    create?: XOR<channelCreateWithoutParentInput, channelUncheckedCreateWithoutParentInput> | channelCreateWithoutParentInput[] | channelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: channelCreateOrConnectWithoutParentInput | channelCreateOrConnectWithoutParentInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutParentInput | channelUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: channelCreateManyParentInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutParentInput | channelUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: channelUpdateManyWithWhereWithoutParentInput | channelUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type channel_memberUpdateManyWithoutChannelNestedInput = {
    create?: XOR<channel_memberCreateWithoutChannelInput, channel_memberUncheckedCreateWithoutChannelInput> | channel_memberCreateWithoutChannelInput[] | channel_memberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutChannelInput | channel_memberCreateOrConnectWithoutChannelInput[]
    upsert?: channel_memberUpsertWithWhereUniqueWithoutChannelInput | channel_memberUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: channel_memberCreateManyChannelInputEnvelope
    set?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    disconnect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    delete?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    update?: channel_memberUpdateWithWhereUniqueWithoutChannelInput | channel_memberUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: channel_memberUpdateManyWithWhereWithoutChannelInput | channel_memberUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: channel_memberScalarWhereInput | channel_memberScalarWhereInput[]
  }

  export type roomUpdateOneWithoutChannelNestedInput = {
    create?: XOR<roomCreateWithoutChannelInput, roomUncheckedCreateWithoutChannelInput>
    connectOrCreate?: roomCreateOrConnectWithoutChannelInput
    upsert?: roomUpsertWithoutChannelInput
    disconnect?: roomWhereInput | boolean
    delete?: roomWhereInput | boolean
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutChannelInput, roomUpdateWithoutChannelInput>, roomUncheckedUpdateWithoutChannelInput>
  }

  export type channelUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<channelCreateWithoutParentInput, channelUncheckedCreateWithoutParentInput> | channelCreateWithoutParentInput[] | channelUncheckedCreateWithoutParentInput[]
    connectOrCreate?: channelCreateOrConnectWithoutParentInput | channelCreateOrConnectWithoutParentInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutParentInput | channelUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: channelCreateManyParentInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutParentInput | channelUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: channelUpdateManyWithWhereWithoutParentInput | channelUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type channel_memberUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<channel_memberCreateWithoutChannelInput, channel_memberUncheckedCreateWithoutChannelInput> | channel_memberCreateWithoutChannelInput[] | channel_memberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: channel_memberCreateOrConnectWithoutChannelInput | channel_memberCreateOrConnectWithoutChannelInput[]
    upsert?: channel_memberUpsertWithWhereUniqueWithoutChannelInput | channel_memberUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: channel_memberCreateManyChannelInputEnvelope
    set?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    disconnect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    delete?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    connect?: channel_memberWhereUniqueInput | channel_memberWhereUniqueInput[]
    update?: channel_memberUpdateWithWhereUniqueWithoutChannelInput | channel_memberUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: channel_memberUpdateManyWithWhereWithoutChannelInput | channel_memberUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: channel_memberScalarWhereInput | channel_memberScalarWhereInput[]
  }

  export type roomUncheckedUpdateOneWithoutChannelNestedInput = {
    create?: XOR<roomCreateWithoutChannelInput, roomUncheckedCreateWithoutChannelInput>
    connectOrCreate?: roomCreateOrConnectWithoutChannelInput
    upsert?: roomUpsertWithoutChannelInput
    disconnect?: roomWhereInput | boolean
    delete?: roomWhereInput | boolean
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutChannelInput, roomUpdateWithoutChannelInput>, roomUncheckedUpdateWithoutChannelInput>
  }

  export type channelCreateNestedOneWithoutMembersInput = {
    create?: XOR<channelCreateWithoutMembersInput, channelUncheckedCreateWithoutMembersInput>
    connectOrCreate?: channelCreateOrConnectWithoutMembersInput
    connect?: channelWhereUniqueInput
  }

  export type userCreateNestedOneWithoutChannel_membershipsInput = {
    create?: XOR<userCreateWithoutChannel_membershipsInput, userUncheckedCreateWithoutChannel_membershipsInput>
    connectOrCreate?: userCreateOrConnectWithoutChannel_membershipsInput
    connect?: userWhereUniqueInput
  }

  export type channelUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<channelCreateWithoutMembersInput, channelUncheckedCreateWithoutMembersInput>
    connectOrCreate?: channelCreateOrConnectWithoutMembersInput
    upsert?: channelUpsertWithoutMembersInput
    connect?: channelWhereUniqueInput
    update?: XOR<XOR<channelUpdateToOneWithWhereWithoutMembersInput, channelUpdateWithoutMembersInput>, channelUncheckedUpdateWithoutMembersInput>
  }

  export type userUpdateOneRequiredWithoutChannel_membershipsNestedInput = {
    create?: XOR<userCreateWithoutChannel_membershipsInput, userUncheckedCreateWithoutChannel_membershipsInput>
    connectOrCreate?: userCreateOrConnectWithoutChannel_membershipsInput
    upsert?: userUpsertWithoutChannel_membershipsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutChannel_membershipsInput, userUpdateWithoutChannel_membershipsInput>, userUncheckedUpdateWithoutChannel_membershipsInput>
  }

  export type dm_pair_uniqueCreateNestedManyWithoutRoomInput = {
    create?: XOR<dm_pair_uniqueCreateWithoutRoomInput, dm_pair_uniqueUncheckedCreateWithoutRoomInput> | dm_pair_uniqueCreateWithoutRoomInput[] | dm_pair_uniqueUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: dm_pair_uniqueCreateOrConnectWithoutRoomInput | dm_pair_uniqueCreateOrConnectWithoutRoomInput[]
    createMany?: dm_pair_uniqueCreateManyRoomInputEnvelope
    connect?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutRoomInput = {
    create?: XOR<messageCreateWithoutRoomInput, messageUncheckedCreateWithoutRoomInput> | messageCreateWithoutRoomInput[] | messageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRoomInput | messageCreateOrConnectWithoutRoomInput[]
    createMany?: messageCreateManyRoomInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type channelCreateNestedOneWithoutRoomInput = {
    create?: XOR<channelCreateWithoutRoomInput, channelUncheckedCreateWithoutRoomInput>
    connectOrCreate?: channelCreateOrConnectWithoutRoomInput
    connect?: channelWhereUniqueInput
  }

  export type guildCreateNestedOneWithoutRoomInput = {
    create?: XOR<guildCreateWithoutRoomInput, guildUncheckedCreateWithoutRoomInput>
    connectOrCreate?: guildCreateOrConnectWithoutRoomInput
    connect?: guildWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRoomInput = {
    create?: XOR<userCreateWithoutRoomInput, userUncheckedCreateWithoutRoomInput>
    connectOrCreate?: userCreateOrConnectWithoutRoomInput
    connect?: userWhereUniqueInput
  }

  export type room_participantCreateNestedManyWithoutRoomInput = {
    create?: XOR<room_participantCreateWithoutRoomInput, room_participantUncheckedCreateWithoutRoomInput> | room_participantCreateWithoutRoomInput[] | room_participantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutRoomInput | room_participantCreateOrConnectWithoutRoomInput[]
    createMany?: room_participantCreateManyRoomInputEnvelope
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
  }

  export type room_viewCreateNestedManyWithoutRoomInput = {
    create?: XOR<room_viewCreateWithoutRoomInput, room_viewUncheckedCreateWithoutRoomInput> | room_viewCreateWithoutRoomInput[] | room_viewUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutRoomInput | room_viewCreateOrConnectWithoutRoomInput[]
    createMany?: room_viewCreateManyRoomInputEnvelope
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
  }

  export type dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<dm_pair_uniqueCreateWithoutRoomInput, dm_pair_uniqueUncheckedCreateWithoutRoomInput> | dm_pair_uniqueCreateWithoutRoomInput[] | dm_pair_uniqueUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: dm_pair_uniqueCreateOrConnectWithoutRoomInput | dm_pair_uniqueCreateOrConnectWithoutRoomInput[]
    createMany?: dm_pair_uniqueCreateManyRoomInputEnvelope
    connect?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<messageCreateWithoutRoomInput, messageUncheckedCreateWithoutRoomInput> | messageCreateWithoutRoomInput[] | messageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRoomInput | messageCreateOrConnectWithoutRoomInput[]
    createMany?: messageCreateManyRoomInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type room_participantUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<room_participantCreateWithoutRoomInput, room_participantUncheckedCreateWithoutRoomInput> | room_participantCreateWithoutRoomInput[] | room_participantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutRoomInput | room_participantCreateOrConnectWithoutRoomInput[]
    createMany?: room_participantCreateManyRoomInputEnvelope
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
  }

  export type room_viewUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<room_viewCreateWithoutRoomInput, room_viewUncheckedCreateWithoutRoomInput> | room_viewCreateWithoutRoomInput[] | room_viewUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutRoomInput | room_viewCreateOrConnectWithoutRoomInput[]
    createMany?: room_viewCreateManyRoomInputEnvelope
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
  }

  export type Enumroom_typeFieldUpdateOperationsInput = {
    set?: $Enums.room_type
  }

  export type dm_pair_uniqueUpdateManyWithoutRoomNestedInput = {
    create?: XOR<dm_pair_uniqueCreateWithoutRoomInput, dm_pair_uniqueUncheckedCreateWithoutRoomInput> | dm_pair_uniqueCreateWithoutRoomInput[] | dm_pair_uniqueUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: dm_pair_uniqueCreateOrConnectWithoutRoomInput | dm_pair_uniqueCreateOrConnectWithoutRoomInput[]
    upsert?: dm_pair_uniqueUpsertWithWhereUniqueWithoutRoomInput | dm_pair_uniqueUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: dm_pair_uniqueCreateManyRoomInputEnvelope
    set?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    disconnect?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    delete?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    connect?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    update?: dm_pair_uniqueUpdateWithWhereUniqueWithoutRoomInput | dm_pair_uniqueUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: dm_pair_uniqueUpdateManyWithWhereWithoutRoomInput | dm_pair_uniqueUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: dm_pair_uniqueScalarWhereInput | dm_pair_uniqueScalarWhereInput[]
  }

  export type messageUpdateManyWithoutRoomNestedInput = {
    create?: XOR<messageCreateWithoutRoomInput, messageUncheckedCreateWithoutRoomInput> | messageCreateWithoutRoomInput[] | messageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRoomInput | messageCreateOrConnectWithoutRoomInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutRoomInput | messageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: messageCreateManyRoomInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutRoomInput | messageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: messageUpdateManyWithWhereWithoutRoomInput | messageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type channelUpdateOneWithoutRoomNestedInput = {
    create?: XOR<channelCreateWithoutRoomInput, channelUncheckedCreateWithoutRoomInput>
    connectOrCreate?: channelCreateOrConnectWithoutRoomInput
    upsert?: channelUpsertWithoutRoomInput
    disconnect?: channelWhereInput | boolean
    delete?: channelWhereInput | boolean
    connect?: channelWhereUniqueInput
    update?: XOR<XOR<channelUpdateToOneWithWhereWithoutRoomInput, channelUpdateWithoutRoomInput>, channelUncheckedUpdateWithoutRoomInput>
  }

  export type guildUpdateOneWithoutRoomNestedInput = {
    create?: XOR<guildCreateWithoutRoomInput, guildUncheckedCreateWithoutRoomInput>
    connectOrCreate?: guildCreateOrConnectWithoutRoomInput
    upsert?: guildUpsertWithoutRoomInput
    disconnect?: guildWhereInput | boolean
    delete?: guildWhereInput | boolean
    connect?: guildWhereUniqueInput
    update?: XOR<XOR<guildUpdateToOneWithWhereWithoutRoomInput, guildUpdateWithoutRoomInput>, guildUncheckedUpdateWithoutRoomInput>
  }

  export type userUpdateOneWithoutRoomNestedInput = {
    create?: XOR<userCreateWithoutRoomInput, userUncheckedCreateWithoutRoomInput>
    connectOrCreate?: userCreateOrConnectWithoutRoomInput
    upsert?: userUpsertWithoutRoomInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRoomInput, userUpdateWithoutRoomInput>, userUncheckedUpdateWithoutRoomInput>
  }

  export type room_participantUpdateManyWithoutRoomNestedInput = {
    create?: XOR<room_participantCreateWithoutRoomInput, room_participantUncheckedCreateWithoutRoomInput> | room_participantCreateWithoutRoomInput[] | room_participantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutRoomInput | room_participantCreateOrConnectWithoutRoomInput[]
    upsert?: room_participantUpsertWithWhereUniqueWithoutRoomInput | room_participantUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: room_participantCreateManyRoomInputEnvelope
    set?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    disconnect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    delete?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    update?: room_participantUpdateWithWhereUniqueWithoutRoomInput | room_participantUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: room_participantUpdateManyWithWhereWithoutRoomInput | room_participantUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: room_participantScalarWhereInput | room_participantScalarWhereInput[]
  }

  export type room_viewUpdateManyWithoutRoomNestedInput = {
    create?: XOR<room_viewCreateWithoutRoomInput, room_viewUncheckedCreateWithoutRoomInput> | room_viewCreateWithoutRoomInput[] | room_viewUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutRoomInput | room_viewCreateOrConnectWithoutRoomInput[]
    upsert?: room_viewUpsertWithWhereUniqueWithoutRoomInput | room_viewUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: room_viewCreateManyRoomInputEnvelope
    set?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    disconnect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    delete?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    update?: room_viewUpdateWithWhereUniqueWithoutRoomInput | room_viewUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: room_viewUpdateManyWithWhereWithoutRoomInput | room_viewUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: room_viewScalarWhereInput | room_viewScalarWhereInput[]
  }

  export type dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<dm_pair_uniqueCreateWithoutRoomInput, dm_pair_uniqueUncheckedCreateWithoutRoomInput> | dm_pair_uniqueCreateWithoutRoomInput[] | dm_pair_uniqueUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: dm_pair_uniqueCreateOrConnectWithoutRoomInput | dm_pair_uniqueCreateOrConnectWithoutRoomInput[]
    upsert?: dm_pair_uniqueUpsertWithWhereUniqueWithoutRoomInput | dm_pair_uniqueUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: dm_pair_uniqueCreateManyRoomInputEnvelope
    set?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    disconnect?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    delete?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    connect?: dm_pair_uniqueWhereUniqueInput | dm_pair_uniqueWhereUniqueInput[]
    update?: dm_pair_uniqueUpdateWithWhereUniqueWithoutRoomInput | dm_pair_uniqueUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: dm_pair_uniqueUpdateManyWithWhereWithoutRoomInput | dm_pair_uniqueUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: dm_pair_uniqueScalarWhereInput | dm_pair_uniqueScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<messageCreateWithoutRoomInput, messageUncheckedCreateWithoutRoomInput> | messageCreateWithoutRoomInput[] | messageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRoomInput | messageCreateOrConnectWithoutRoomInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutRoomInput | messageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: messageCreateManyRoomInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutRoomInput | messageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: messageUpdateManyWithWhereWithoutRoomInput | messageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type room_participantUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<room_participantCreateWithoutRoomInput, room_participantUncheckedCreateWithoutRoomInput> | room_participantCreateWithoutRoomInput[] | room_participantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_participantCreateOrConnectWithoutRoomInput | room_participantCreateOrConnectWithoutRoomInput[]
    upsert?: room_participantUpsertWithWhereUniqueWithoutRoomInput | room_participantUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: room_participantCreateManyRoomInputEnvelope
    set?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    disconnect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    delete?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    connect?: room_participantWhereUniqueInput | room_participantWhereUniqueInput[]
    update?: room_participantUpdateWithWhereUniqueWithoutRoomInput | room_participantUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: room_participantUpdateManyWithWhereWithoutRoomInput | room_participantUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: room_participantScalarWhereInput | room_participantScalarWhereInput[]
  }

  export type room_viewUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<room_viewCreateWithoutRoomInput, room_viewUncheckedCreateWithoutRoomInput> | room_viewCreateWithoutRoomInput[] | room_viewUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: room_viewCreateOrConnectWithoutRoomInput | room_viewCreateOrConnectWithoutRoomInput[]
    upsert?: room_viewUpsertWithWhereUniqueWithoutRoomInput | room_viewUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: room_viewCreateManyRoomInputEnvelope
    set?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    disconnect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    delete?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    connect?: room_viewWhereUniqueInput | room_viewWhereUniqueInput[]
    update?: room_viewUpdateWithWhereUniqueWithoutRoomInput | room_viewUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: room_viewUpdateManyWithWhereWithoutRoomInput | room_viewUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: room_viewScalarWhereInput | room_viewScalarWhereInput[]
  }

  export type roomCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<roomCreateWithoutParticipantsInput, roomUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: roomCreateOrConnectWithoutParticipantsInput
    connect?: roomWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRoom_participationsInput = {
    create?: XOR<userCreateWithoutRoom_participationsInput, userUncheckedCreateWithoutRoom_participationsInput>
    connectOrCreate?: userCreateOrConnectWithoutRoom_participationsInput
    connect?: userWhereUniqueInput
  }

  export type roomUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<roomCreateWithoutParticipantsInput, roomUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: roomCreateOrConnectWithoutParticipantsInput
    upsert?: roomUpsertWithoutParticipantsInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutParticipantsInput, roomUpdateWithoutParticipantsInput>, roomUncheckedUpdateWithoutParticipantsInput>
  }

  export type userUpdateOneRequiredWithoutRoom_participationsNestedInput = {
    create?: XOR<userCreateWithoutRoom_participationsInput, userUncheckedCreateWithoutRoom_participationsInput>
    connectOrCreate?: userCreateOrConnectWithoutRoom_participationsInput
    upsert?: userUpsertWithoutRoom_participationsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRoom_participationsInput, userUpdateWithoutRoom_participationsInput>, userUncheckedUpdateWithoutRoom_participationsInput>
  }

  export type roomCreateNestedOneWithoutDm_pair_uniqueInput = {
    create?: XOR<roomCreateWithoutDm_pair_uniqueInput, roomUncheckedCreateWithoutDm_pair_uniqueInput>
    connectOrCreate?: roomCreateOrConnectWithoutDm_pair_uniqueInput
    connect?: roomWhereUniqueInput
  }

  export type roomUpdateOneRequiredWithoutDm_pair_uniqueNestedInput = {
    create?: XOR<roomCreateWithoutDm_pair_uniqueInput, roomUncheckedCreateWithoutDm_pair_uniqueInput>
    connectOrCreate?: roomCreateOrConnectWithoutDm_pair_uniqueInput
    upsert?: roomUpsertWithoutDm_pair_uniqueInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutDm_pair_uniqueInput, roomUpdateWithoutDm_pair_uniqueInput>, roomUncheckedUpdateWithoutDm_pair_uniqueInput>
  }

  export type userCreateNestedOneWithoutMessagesInput = {
    create?: XOR<userCreateWithoutMessagesInput, userUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: userCreateOrConnectWithoutMessagesInput
    connect?: userWhereUniqueInput
  }

  export type roomCreateNestedOneWithoutMessagesInput = {
    create?: XOR<roomCreateWithoutMessagesInput, roomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: roomCreateOrConnectWithoutMessagesInput
    connect?: roomWhereUniqueInput
  }

  export type message_reactionCreateNestedManyWithoutMessageInput = {
    create?: XOR<message_reactionCreateWithoutMessageInput, message_reactionUncheckedCreateWithoutMessageInput> | message_reactionCreateWithoutMessageInput[] | message_reactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutMessageInput | message_reactionCreateOrConnectWithoutMessageInput[]
    createMany?: message_reactionCreateManyMessageInputEnvelope
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
  }

  export type message_readCreateNestedManyWithoutMessageInput = {
    create?: XOR<message_readCreateWithoutMessageInput, message_readUncheckedCreateWithoutMessageInput> | message_readCreateWithoutMessageInput[] | message_readUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutMessageInput | message_readCreateOrConnectWithoutMessageInput[]
    createMany?: message_readCreateManyMessageInputEnvelope
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
  }

  export type message_reactionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<message_reactionCreateWithoutMessageInput, message_reactionUncheckedCreateWithoutMessageInput> | message_reactionCreateWithoutMessageInput[] | message_reactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutMessageInput | message_reactionCreateOrConnectWithoutMessageInput[]
    createMany?: message_reactionCreateManyMessageInputEnvelope
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
  }

  export type message_readUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<message_readCreateWithoutMessageInput, message_readUncheckedCreateWithoutMessageInput> | message_readCreateWithoutMessageInput[] | message_readUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutMessageInput | message_readCreateOrConnectWithoutMessageInput[]
    createMany?: message_readCreateManyMessageInputEnvelope
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
  }

  export type Enummessage_typeFieldUpdateOperationsInput = {
    set?: $Enums.message_type
  }

  export type userUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<userCreateWithoutMessagesInput, userUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: userCreateOrConnectWithoutMessagesInput
    upsert?: userUpsertWithoutMessagesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessagesInput, userUpdateWithoutMessagesInput>, userUncheckedUpdateWithoutMessagesInput>
  }

  export type roomUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<roomCreateWithoutMessagesInput, roomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: roomCreateOrConnectWithoutMessagesInput
    upsert?: roomUpsertWithoutMessagesInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutMessagesInput, roomUpdateWithoutMessagesInput>, roomUncheckedUpdateWithoutMessagesInput>
  }

  export type message_reactionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<message_reactionCreateWithoutMessageInput, message_reactionUncheckedCreateWithoutMessageInput> | message_reactionCreateWithoutMessageInput[] | message_reactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutMessageInput | message_reactionCreateOrConnectWithoutMessageInput[]
    upsert?: message_reactionUpsertWithWhereUniqueWithoutMessageInput | message_reactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: message_reactionCreateManyMessageInputEnvelope
    set?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    disconnect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    delete?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    update?: message_reactionUpdateWithWhereUniqueWithoutMessageInput | message_reactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: message_reactionUpdateManyWithWhereWithoutMessageInput | message_reactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: message_reactionScalarWhereInput | message_reactionScalarWhereInput[]
  }

  export type message_readUpdateManyWithoutMessageNestedInput = {
    create?: XOR<message_readCreateWithoutMessageInput, message_readUncheckedCreateWithoutMessageInput> | message_readCreateWithoutMessageInput[] | message_readUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutMessageInput | message_readCreateOrConnectWithoutMessageInput[]
    upsert?: message_readUpsertWithWhereUniqueWithoutMessageInput | message_readUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: message_readCreateManyMessageInputEnvelope
    set?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    disconnect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    delete?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    update?: message_readUpdateWithWhereUniqueWithoutMessageInput | message_readUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: message_readUpdateManyWithWhereWithoutMessageInput | message_readUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: message_readScalarWhereInput | message_readScalarWhereInput[]
  }

  export type message_reactionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<message_reactionCreateWithoutMessageInput, message_reactionUncheckedCreateWithoutMessageInput> | message_reactionCreateWithoutMessageInput[] | message_reactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_reactionCreateOrConnectWithoutMessageInput | message_reactionCreateOrConnectWithoutMessageInput[]
    upsert?: message_reactionUpsertWithWhereUniqueWithoutMessageInput | message_reactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: message_reactionCreateManyMessageInputEnvelope
    set?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    disconnect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    delete?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    connect?: message_reactionWhereUniqueInput | message_reactionWhereUniqueInput[]
    update?: message_reactionUpdateWithWhereUniqueWithoutMessageInput | message_reactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: message_reactionUpdateManyWithWhereWithoutMessageInput | message_reactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: message_reactionScalarWhereInput | message_reactionScalarWhereInput[]
  }

  export type message_readUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<message_readCreateWithoutMessageInput, message_readUncheckedCreateWithoutMessageInput> | message_readCreateWithoutMessageInput[] | message_readUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: message_readCreateOrConnectWithoutMessageInput | message_readCreateOrConnectWithoutMessageInput[]
    upsert?: message_readUpsertWithWhereUniqueWithoutMessageInput | message_readUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: message_readCreateManyMessageInputEnvelope
    set?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    disconnect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    delete?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    connect?: message_readWhereUniqueInput | message_readWhereUniqueInput[]
    update?: message_readUpdateWithWhereUniqueWithoutMessageInput | message_readUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: message_readUpdateManyWithWhereWithoutMessageInput | message_readUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: message_readScalarWhereInput | message_readScalarWhereInput[]
  }

  export type messageCreateNestedOneWithoutReadsInput = {
    create?: XOR<messageCreateWithoutReadsInput, messageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: messageCreateOrConnectWithoutReadsInput
    connect?: messageWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessage_readsInput = {
    create?: XOR<userCreateWithoutMessage_readsInput, userUncheckedCreateWithoutMessage_readsInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_readsInput
    connect?: userWhereUniqueInput
  }

  export type messageUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<messageCreateWithoutReadsInput, messageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: messageCreateOrConnectWithoutReadsInput
    upsert?: messageUpsertWithoutReadsInput
    connect?: messageWhereUniqueInput
    update?: XOR<XOR<messageUpdateToOneWithWhereWithoutReadsInput, messageUpdateWithoutReadsInput>, messageUncheckedUpdateWithoutReadsInput>
  }

  export type userUpdateOneRequiredWithoutMessage_readsNestedInput = {
    create?: XOR<userCreateWithoutMessage_readsInput, userUncheckedCreateWithoutMessage_readsInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_readsInput
    upsert?: userUpsertWithoutMessage_readsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessage_readsInput, userUpdateWithoutMessage_readsInput>, userUncheckedUpdateWithoutMessage_readsInput>
  }

  export type messageCreateNestedOneWithoutReactionsInput = {
    create?: XOR<messageCreateWithoutReactionsInput, messageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: messageCreateOrConnectWithoutReactionsInput
    connect?: messageWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessage_reactionsInput = {
    create?: XOR<userCreateWithoutMessage_reactionsInput, userUncheckedCreateWithoutMessage_reactionsInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_reactionsInput
    connect?: userWhereUniqueInput
  }

  export type messageUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<messageCreateWithoutReactionsInput, messageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: messageCreateOrConnectWithoutReactionsInput
    upsert?: messageUpsertWithoutReactionsInput
    connect?: messageWhereUniqueInput
    update?: XOR<XOR<messageUpdateToOneWithWhereWithoutReactionsInput, messageUpdateWithoutReactionsInput>, messageUncheckedUpdateWithoutReactionsInput>
  }

  export type userUpdateOneRequiredWithoutMessage_reactionsNestedInput = {
    create?: XOR<userCreateWithoutMessage_reactionsInput, userUncheckedCreateWithoutMessage_reactionsInput>
    connectOrCreate?: userCreateOrConnectWithoutMessage_reactionsInput
    upsert?: userUpsertWithoutMessage_reactionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessage_reactionsInput, userUpdateWithoutMessage_reactionsInput>, userUncheckedUpdateWithoutMessage_reactionsInput>
  }

  export type roomCreateNestedOneWithoutRoom_viewInput = {
    create?: XOR<roomCreateWithoutRoom_viewInput, roomUncheckedCreateWithoutRoom_viewInput>
    connectOrCreate?: roomCreateOrConnectWithoutRoom_viewInput
    connect?: roomWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRoom_viewInput = {
    create?: XOR<userCreateWithoutRoom_viewInput, userUncheckedCreateWithoutRoom_viewInput>
    connectOrCreate?: userCreateOrConnectWithoutRoom_viewInput
    connect?: userWhereUniqueInput
  }

  export type roomUpdateOneRequiredWithoutRoom_viewNestedInput = {
    create?: XOR<roomCreateWithoutRoom_viewInput, roomUncheckedCreateWithoutRoom_viewInput>
    connectOrCreate?: roomCreateOrConnectWithoutRoom_viewInput
    upsert?: roomUpsertWithoutRoom_viewInput
    connect?: roomWhereUniqueInput
    update?: XOR<XOR<roomUpdateToOneWithWhereWithoutRoom_viewInput, roomUpdateWithoutRoom_viewInput>, roomUncheckedUpdateWithoutRoom_viewInput>
  }

  export type userUpdateOneRequiredWithoutRoom_viewNestedInput = {
    create?: XOR<userCreateWithoutRoom_viewInput, userUncheckedCreateWithoutRoom_viewInput>
    connectOrCreate?: userCreateOrConnectWithoutRoom_viewInput
    upsert?: userUpsertWithoutRoom_viewInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRoom_viewInput, userUpdateWithoutRoom_viewInput>, userUncheckedUpdateWithoutRoom_viewInput>
  }

  export type userCreateNestedOneWithoutEdition_createdInput = {
    create?: XOR<userCreateWithoutEdition_createdInput, userUncheckedCreateWithoutEdition_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutEdition_createdInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEdition_updatedInput = {
    create?: XOR<userCreateWithoutEdition_updatedInput, userUncheckedCreateWithoutEdition_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutEdition_updatedInput
    connect?: userWhereUniqueInput
  }

  export type edition_roomCreateNestedManyWithoutEditionInput = {
    create?: XOR<edition_roomCreateWithoutEditionInput, edition_roomUncheckedCreateWithoutEditionInput> | edition_roomCreateWithoutEditionInput[] | edition_roomUncheckedCreateWithoutEditionInput[]
    connectOrCreate?: edition_roomCreateOrConnectWithoutEditionInput | edition_roomCreateOrConnectWithoutEditionInput[]
    createMany?: edition_roomCreateManyEditionInputEnvelope
    connect?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
  }

  export type edition_roomUncheckedCreateNestedManyWithoutEditionInput = {
    create?: XOR<edition_roomCreateWithoutEditionInput, edition_roomUncheckedCreateWithoutEditionInput> | edition_roomCreateWithoutEditionInput[] | edition_roomUncheckedCreateWithoutEditionInput[]
    connectOrCreate?: edition_roomCreateOrConnectWithoutEditionInput | edition_roomCreateOrConnectWithoutEditionInput[]
    createMany?: edition_roomCreateManyEditionInputEnvelope
    connect?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutEdition_createdNestedInput = {
    create?: XOR<userCreateWithoutEdition_createdInput, userUncheckedCreateWithoutEdition_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutEdition_createdInput
    upsert?: userUpsertWithoutEdition_createdInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEdition_createdInput, userUpdateWithoutEdition_createdInput>, userUncheckedUpdateWithoutEdition_createdInput>
  }

  export type userUpdateOneRequiredWithoutEdition_updatedNestedInput = {
    create?: XOR<userCreateWithoutEdition_updatedInput, userUncheckedCreateWithoutEdition_updatedInput>
    connectOrCreate?: userCreateOrConnectWithoutEdition_updatedInput
    upsert?: userUpsertWithoutEdition_updatedInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEdition_updatedInput, userUpdateWithoutEdition_updatedInput>, userUncheckedUpdateWithoutEdition_updatedInput>
  }

  export type edition_roomUpdateManyWithoutEditionNestedInput = {
    create?: XOR<edition_roomCreateWithoutEditionInput, edition_roomUncheckedCreateWithoutEditionInput> | edition_roomCreateWithoutEditionInput[] | edition_roomUncheckedCreateWithoutEditionInput[]
    connectOrCreate?: edition_roomCreateOrConnectWithoutEditionInput | edition_roomCreateOrConnectWithoutEditionInput[]
    upsert?: edition_roomUpsertWithWhereUniqueWithoutEditionInput | edition_roomUpsertWithWhereUniqueWithoutEditionInput[]
    createMany?: edition_roomCreateManyEditionInputEnvelope
    set?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    disconnect?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    delete?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    connect?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    update?: edition_roomUpdateWithWhereUniqueWithoutEditionInput | edition_roomUpdateWithWhereUniqueWithoutEditionInput[]
    updateMany?: edition_roomUpdateManyWithWhereWithoutEditionInput | edition_roomUpdateManyWithWhereWithoutEditionInput[]
    deleteMany?: edition_roomScalarWhereInput | edition_roomScalarWhereInput[]
  }

  export type edition_roomUncheckedUpdateManyWithoutEditionNestedInput = {
    create?: XOR<edition_roomCreateWithoutEditionInput, edition_roomUncheckedCreateWithoutEditionInput> | edition_roomCreateWithoutEditionInput[] | edition_roomUncheckedCreateWithoutEditionInput[]
    connectOrCreate?: edition_roomCreateOrConnectWithoutEditionInput | edition_roomCreateOrConnectWithoutEditionInput[]
    upsert?: edition_roomUpsertWithWhereUniqueWithoutEditionInput | edition_roomUpsertWithWhereUniqueWithoutEditionInput[]
    createMany?: edition_roomCreateManyEditionInputEnvelope
    set?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    disconnect?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    delete?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    connect?: edition_roomWhereUniqueInput | edition_roomWhereUniqueInput[]
    update?: edition_roomUpdateWithWhereUniqueWithoutEditionInput | edition_roomUpdateWithWhereUniqueWithoutEditionInput[]
    updateMany?: edition_roomUpdateManyWithWhereWithoutEditionInput | edition_roomUpdateManyWithWhereWithoutEditionInput[]
    deleteMany?: edition_roomScalarWhereInput | edition_roomScalarWhereInput[]
  }

  export type editionCreateNestedOneWithoutRoomsInput = {
    create?: XOR<editionCreateWithoutRoomsInput, editionUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: editionCreateOrConnectWithoutRoomsInput
    connect?: editionWhereUniqueInput
  }

  export type tableCreateNestedManyWithoutRoomInput = {
    create?: XOR<tableCreateWithoutRoomInput, tableUncheckedCreateWithoutRoomInput> | tableCreateWithoutRoomInput[] | tableUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: tableCreateOrConnectWithoutRoomInput | tableCreateOrConnectWithoutRoomInput[]
    createMany?: tableCreateManyRoomInputEnvelope
    connect?: tableWhereUniqueInput | tableWhereUniqueInput[]
  }

  export type tableUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<tableCreateWithoutRoomInput, tableUncheckedCreateWithoutRoomInput> | tableCreateWithoutRoomInput[] | tableUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: tableCreateOrConnectWithoutRoomInput | tableCreateOrConnectWithoutRoomInput[]
    createMany?: tableCreateManyRoomInputEnvelope
    connect?: tableWhereUniqueInput | tableWhereUniqueInput[]
  }

  export type editionUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<editionCreateWithoutRoomsInput, editionUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: editionCreateOrConnectWithoutRoomsInput
    upsert?: editionUpsertWithoutRoomsInput
    connect?: editionWhereUniqueInput
    update?: XOR<XOR<editionUpdateToOneWithWhereWithoutRoomsInput, editionUpdateWithoutRoomsInput>, editionUncheckedUpdateWithoutRoomsInput>
  }

  export type tableUpdateManyWithoutRoomNestedInput = {
    create?: XOR<tableCreateWithoutRoomInput, tableUncheckedCreateWithoutRoomInput> | tableCreateWithoutRoomInput[] | tableUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: tableCreateOrConnectWithoutRoomInput | tableCreateOrConnectWithoutRoomInput[]
    upsert?: tableUpsertWithWhereUniqueWithoutRoomInput | tableUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: tableCreateManyRoomInputEnvelope
    set?: tableWhereUniqueInput | tableWhereUniqueInput[]
    disconnect?: tableWhereUniqueInput | tableWhereUniqueInput[]
    delete?: tableWhereUniqueInput | tableWhereUniqueInput[]
    connect?: tableWhereUniqueInput | tableWhereUniqueInput[]
    update?: tableUpdateWithWhereUniqueWithoutRoomInput | tableUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: tableUpdateManyWithWhereWithoutRoomInput | tableUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: tableScalarWhereInput | tableScalarWhereInput[]
  }

  export type tableUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<tableCreateWithoutRoomInput, tableUncheckedCreateWithoutRoomInput> | tableCreateWithoutRoomInput[] | tableUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: tableCreateOrConnectWithoutRoomInput | tableCreateOrConnectWithoutRoomInput[]
    upsert?: tableUpsertWithWhereUniqueWithoutRoomInput | tableUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: tableCreateManyRoomInputEnvelope
    set?: tableWhereUniqueInput | tableWhereUniqueInput[]
    disconnect?: tableWhereUniqueInput | tableWhereUniqueInput[]
    delete?: tableWhereUniqueInput | tableWhereUniqueInput[]
    connect?: tableWhereUniqueInput | tableWhereUniqueInput[]
    update?: tableUpdateWithWhereUniqueWithoutRoomInput | tableUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: tableUpdateManyWithWhereWithoutRoomInput | tableUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: tableScalarWhereInput | tableScalarWhereInput[]
  }

  export type edition_roomCreateNestedOneWithoutTablesInput = {
    create?: XOR<edition_roomCreateWithoutTablesInput, edition_roomUncheckedCreateWithoutTablesInput>
    connectOrCreate?: edition_roomCreateOrConnectWithoutTablesInput
    connect?: edition_roomWhereUniqueInput
  }

  export type table_seatCreateNestedManyWithoutTableInput = {
    create?: XOR<table_seatCreateWithoutTableInput, table_seatUncheckedCreateWithoutTableInput> | table_seatCreateWithoutTableInput[] | table_seatUncheckedCreateWithoutTableInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutTableInput | table_seatCreateOrConnectWithoutTableInput[]
    createMany?: table_seatCreateManyTableInputEnvelope
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
  }

  export type table_seatUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<table_seatCreateWithoutTableInput, table_seatUncheckedCreateWithoutTableInput> | table_seatCreateWithoutTableInput[] | table_seatUncheckedCreateWithoutTableInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutTableInput | table_seatCreateOrConnectWithoutTableInput[]
    createMany?: table_seatCreateManyTableInputEnvelope
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
  }

  export type edition_roomUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<edition_roomCreateWithoutTablesInput, edition_roomUncheckedCreateWithoutTablesInput>
    connectOrCreate?: edition_roomCreateOrConnectWithoutTablesInput
    upsert?: edition_roomUpsertWithoutTablesInput
    connect?: edition_roomWhereUniqueInput
    update?: XOR<XOR<edition_roomUpdateToOneWithWhereWithoutTablesInput, edition_roomUpdateWithoutTablesInput>, edition_roomUncheckedUpdateWithoutTablesInput>
  }

  export type table_seatUpdateManyWithoutTableNestedInput = {
    create?: XOR<table_seatCreateWithoutTableInput, table_seatUncheckedCreateWithoutTableInput> | table_seatCreateWithoutTableInput[] | table_seatUncheckedCreateWithoutTableInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutTableInput | table_seatCreateOrConnectWithoutTableInput[]
    upsert?: table_seatUpsertWithWhereUniqueWithoutTableInput | table_seatUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: table_seatCreateManyTableInputEnvelope
    set?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    disconnect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    delete?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    update?: table_seatUpdateWithWhereUniqueWithoutTableInput | table_seatUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: table_seatUpdateManyWithWhereWithoutTableInput | table_seatUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: table_seatScalarWhereInput | table_seatScalarWhereInput[]
  }

  export type table_seatUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<table_seatCreateWithoutTableInput, table_seatUncheckedCreateWithoutTableInput> | table_seatCreateWithoutTableInput[] | table_seatUncheckedCreateWithoutTableInput[]
    connectOrCreate?: table_seatCreateOrConnectWithoutTableInput | table_seatCreateOrConnectWithoutTableInput[]
    upsert?: table_seatUpsertWithWhereUniqueWithoutTableInput | table_seatUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: table_seatCreateManyTableInputEnvelope
    set?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    disconnect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    delete?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    connect?: table_seatWhereUniqueInput | table_seatWhereUniqueInput[]
    update?: table_seatUpdateWithWhereUniqueWithoutTableInput | table_seatUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: table_seatUpdateManyWithWhereWithoutTableInput | table_seatUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: table_seatScalarWhereInput | table_seatScalarWhereInput[]
  }

  export type tableCreateNestedOneWithoutSeatsInput = {
    create?: XOR<tableCreateWithoutSeatsInput, tableUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: tableCreateOrConnectWithoutSeatsInput
    connect?: tableWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTable_seatsInput = {
    create?: XOR<userCreateWithoutTable_seatsInput, userUncheckedCreateWithoutTable_seatsInput>
    connectOrCreate?: userCreateOrConnectWithoutTable_seatsInput
    connect?: userWhereUniqueInput
  }

  export type tableUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<tableCreateWithoutSeatsInput, tableUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: tableCreateOrConnectWithoutSeatsInput
    upsert?: tableUpsertWithoutSeatsInput
    connect?: tableWhereUniqueInput
    update?: XOR<XOR<tableUpdateToOneWithWhereWithoutSeatsInput, tableUpdateWithoutSeatsInput>, tableUncheckedUpdateWithoutSeatsInput>
  }

  export type userUpdateOneWithoutTable_seatsNestedInput = {
    create?: XOR<userCreateWithoutTable_seatsInput, userUncheckedCreateWithoutTable_seatsInput>
    connectOrCreate?: userCreateOrConnectWithoutTable_seatsInput
    upsert?: userUpsertWithoutTable_seatsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTable_seatsInput, userUpdateWithoutTable_seatsInput>, userUncheckedUpdateWithoutTable_seatsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumchannel_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.channel_type | Enumchannel_typeFieldRefInput<$PrismaModel>
    in?: $Enums.channel_type[]
    notIn?: $Enums.channel_type[]
    not?: NestedEnumchannel_typeFilter<$PrismaModel> | $Enums.channel_type
  }

  export type NestedEnumchannel_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.channel_type | Enumchannel_typeFieldRefInput<$PrismaModel>
    in?: $Enums.channel_type[]
    notIn?: $Enums.channel_type[]
    not?: NestedEnumchannel_typeWithAggregatesFilter<$PrismaModel> | $Enums.channel_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumchannel_typeFilter<$PrismaModel>
    _max?: NestedEnumchannel_typeFilter<$PrismaModel>
  }

  export type NestedEnumroom_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.room_type | Enumroom_typeFieldRefInput<$PrismaModel>
    in?: $Enums.room_type[]
    notIn?: $Enums.room_type[]
    not?: NestedEnumroom_typeFilter<$PrismaModel> | $Enums.room_type
  }

  export type NestedEnumroom_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.room_type | Enumroom_typeFieldRefInput<$PrismaModel>
    in?: $Enums.room_type[]
    notIn?: $Enums.room_type[]
    not?: NestedEnumroom_typeWithAggregatesFilter<$PrismaModel> | $Enums.room_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroom_typeFilter<$PrismaModel>
    _max?: NestedEnumroom_typeFilter<$PrismaModel>
  }

  export type NestedEnummessage_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.message_type | Enummessage_typeFieldRefInput<$PrismaModel>
    in?: $Enums.message_type[]
    notIn?: $Enums.message_type[]
    not?: NestedEnummessage_typeFilter<$PrismaModel> | $Enums.message_type
  }

  export type NestedEnummessage_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.message_type | Enummessage_typeFieldRefInput<$PrismaModel>
    in?: $Enums.message_type[]
    notIn?: $Enums.message_type[]
    not?: NestedEnummessage_typeWithAggregatesFilter<$PrismaModel> | $Enums.message_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummessage_typeFilter<$PrismaModel>
    _max?: NestedEnummessage_typeFilter<$PrismaModel>
  }

  export type channel_memberCreateWithoutUserInput = {
    addedAt?: Date | string
    channel: channelCreateNestedOneWithoutMembersInput
  }

  export type channel_memberUncheckedCreateWithoutUserInput = {
    channelId: string
    addedAt?: Date | string
  }

  export type channel_memberCreateOrConnectWithoutUserInput = {
    where: channel_memberWhereUniqueInput
    create: XOR<channel_memberCreateWithoutUserInput, channel_memberUncheckedCreateWithoutUserInput>
  }

  export type channel_memberCreateManyUserInputEnvelope = {
    data: channel_memberCreateManyUserInput | channel_memberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type eventCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    location?: string | null
    image_url?: string | null
    updater: userCreateNestedOneWithoutEvent_updatedInput
  }

  export type eventUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
    location?: string | null
    image_url?: string | null
  }

  export type eventCreateOrConnectWithoutCreatorInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutCreatorInput, eventUncheckedCreateWithoutCreatorInput>
  }

  export type eventCreateManyCreatorInputEnvelope = {
    data: eventCreateManyCreatorInput | eventCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type eventCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    location?: string | null
    image_url?: string | null
    creator: userCreateNestedOneWithoutEvent_createdInput
  }

  export type eventUncheckedCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    location?: string | null
    image_url?: string | null
  }

  export type eventCreateOrConnectWithoutUpdaterInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutUpdaterInput, eventUncheckedCreateWithoutUpdaterInput>
  }

  export type eventCreateManyUpdaterInputEnvelope = {
    data: eventCreateManyUpdaterInput | eventCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type faqCreateWithoutCreatorInput = {
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    updater: userCreateNestedOneWithoutFaq_updatedInput
  }

  export type faqUncheckedCreateWithoutCreatorInput = {
    id?: number
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
  }

  export type faqCreateOrConnectWithoutCreatorInput = {
    where: faqWhereUniqueInput
    create: XOR<faqCreateWithoutCreatorInput, faqUncheckedCreateWithoutCreatorInput>
  }

  export type faqCreateManyCreatorInputEnvelope = {
    data: faqCreateManyCreatorInput | faqCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type faqCreateWithoutUpdaterInput = {
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    creator: userCreateNestedOneWithoutFaq_createdInput
  }

  export type faqUncheckedCreateWithoutUpdaterInput = {
    id?: number
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
  }

  export type faqCreateOrConnectWithoutUpdaterInput = {
    where: faqWhereUniqueInput
    create: XOR<faqCreateWithoutUpdaterInput, faqUncheckedCreateWithoutUpdaterInput>
  }

  export type faqCreateManyUpdaterInputEnvelope = {
    data: faqCreateManyUpdaterInput | faqCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type gameCreateWithoutCreatedByInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    updatedBy: userCreateNestedOneWithoutGamesUpdatedInput
  }

  export type gameUncheckedCreateWithoutCreatedByInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
  }

  export type gameCreateOrConnectWithoutCreatedByInput = {
    where: gameWhereUniqueInput
    create: XOR<gameCreateWithoutCreatedByInput, gameUncheckedCreateWithoutCreatedByInput>
  }

  export type gameCreateManyCreatedByInputEnvelope = {
    data: gameCreateManyCreatedByInput | gameCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type gameCreateWithoutUpdatedByInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    createdBy: userCreateNestedOneWithoutGamesCreatedInput
  }

  export type gameUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
  }

  export type gameCreateOrConnectWithoutUpdatedByInput = {
    where: gameWhereUniqueInput
    create: XOR<gameCreateWithoutUpdatedByInput, gameUncheckedCreateWithoutUpdatedByInput>
  }

  export type gameCreateManyUpdatedByInputEnvelope = {
    data: gameCreateManyUpdatedByInput | gameCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type game_sessionCreateWithoutUserInput = {
    id?: string
    game_slug: string
    start_time: Date | string
    end_time?: Date | string | null
    total_seconds?: number | null
  }

  export type game_sessionUncheckedCreateWithoutUserInput = {
    id?: string
    game_slug: string
    start_time: Date | string
    end_time?: Date | string | null
    total_seconds?: number | null
  }

  export type game_sessionCreateOrConnectWithoutUserInput = {
    where: game_sessionWhereUniqueInput
    create: XOR<game_sessionCreateWithoutUserInput, game_sessionUncheckedCreateWithoutUserInput>
  }

  export type game_sessionCreateManyUserInputEnvelope = {
    data: game_sessionCreateManyUserInput | game_sessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type guildCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelCreateNestedManyWithoutGuildInput
    members?: guild_memberCreateNestedManyWithoutGuildInput
    room?: roomCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelUncheckedCreateNestedManyWithoutGuildInput
    members?: guild_memberUncheckedCreateNestedManyWithoutGuildInput
    room?: roomUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildCreateOrConnectWithoutOwnerInput = {
    where: guildWhereUniqueInput
    create: XOR<guildCreateWithoutOwnerInput, guildUncheckedCreateWithoutOwnerInput>
  }

  export type guildCreateManyOwnerInputEnvelope = {
    data: guildCreateManyOwnerInput | guildCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type guild_memberCreateWithoutUserInput = {
    id?: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
    guild: guildCreateNestedOneWithoutMembersInput
  }

  export type guild_memberUncheckedCreateWithoutUserInput = {
    id?: string
    guildId: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
  }

  export type guild_memberCreateOrConnectWithoutUserInput = {
    where: guild_memberWhereUniqueInput
    create: XOR<guild_memberCreateWithoutUserInput, guild_memberUncheckedCreateWithoutUserInput>
  }

  export type guild_memberCreateManyUserInputEnvelope = {
    data: guild_memberCreateManyUserInput | guild_memberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutAuthorInput = {
    id?: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    room: roomCreateNestedOneWithoutMessagesInput
    reactions?: message_reactionCreateNestedManyWithoutMessageInput
    reads?: message_readCreateNestedManyWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutAuthorInput = {
    id?: string
    roomId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    reactions?: message_reactionUncheckedCreateNestedManyWithoutMessageInput
    reads?: message_readUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageCreateOrConnectWithoutAuthorInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutAuthorInput, messageUncheckedCreateWithoutAuthorInput>
  }

  export type messageCreateManyAuthorInputEnvelope = {
    data: messageCreateManyAuthorInput | messageCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type message_reactionCreateWithoutUserInput = {
    emoji: string
    createdAt?: Date | string
    message: messageCreateNestedOneWithoutReactionsInput
  }

  export type message_reactionUncheckedCreateWithoutUserInput = {
    messageId: string
    emoji: string
    createdAt?: Date | string
  }

  export type message_reactionCreateOrConnectWithoutUserInput = {
    where: message_reactionWhereUniqueInput
    create: XOR<message_reactionCreateWithoutUserInput, message_reactionUncheckedCreateWithoutUserInput>
  }

  export type message_reactionCreateManyUserInputEnvelope = {
    data: message_reactionCreateManyUserInput | message_reactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type message_readCreateWithoutUserInput = {
    readAt?: Date | string
    message: messageCreateNestedOneWithoutReadsInput
  }

  export type message_readUncheckedCreateWithoutUserInput = {
    messageId: string
    readAt?: Date | string
  }

  export type message_readCreateOrConnectWithoutUserInput = {
    where: message_readWhereUniqueInput
    create: XOR<message_readCreateWithoutUserInput, message_readUncheckedCreateWithoutUserInput>
  }

  export type message_readCreateManyUserInputEnvelope = {
    data: message_readCreateManyUserInput | message_readCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type roomCreateWithoutOwnerInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    messages?: messageCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutOwnerInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutOwnerInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutOwnerInput, roomUncheckedCreateWithoutOwnerInput>
  }

  export type roomCreateManyOwnerInputEnvelope = {
    data: roomCreateManyOwnerInput | roomCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type room_participantCreateWithoutUserInput = {
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
    room: roomCreateNestedOneWithoutParticipantsInput
  }

  export type room_participantUncheckedCreateWithoutUserInput = {
    roomId: string
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_participantCreateOrConnectWithoutUserInput = {
    where: room_participantWhereUniqueInput
    create: XOR<room_participantCreateWithoutUserInput, room_participantUncheckedCreateWithoutUserInput>
  }

  export type room_participantCreateManyUserInputEnvelope = {
    data: room_participantCreateManyUserInput | room_participantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type room_viewCreateWithoutUserInput = {
    lastSeenAt?: Date | string
    room: roomCreateNestedOneWithoutRoom_viewInput
  }

  export type room_viewUncheckedCreateWithoutUserInput = {
    roomId: string
    lastSeenAt?: Date | string
  }

  export type room_viewCreateOrConnectWithoutUserInput = {
    where: room_viewWhereUniqueInput
    create: XOR<room_viewCreateWithoutUserInput, room_viewUncheckedCreateWithoutUserInput>
  }

  export type room_viewCreateManyUserInputEnvelope = {
    data: room_viewCreateManyUserInput | room_viewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_settingsCreateWithoutUserInput = {
    local_games_dir: string
  }

  export type user_settingsUncheckedCreateWithoutUserInput = {
    id?: number
    local_games_dir: string
  }

  export type user_settingsCreateOrConnectWithoutUserInput = {
    where: user_settingsWhereUniqueInput
    create: XOR<user_settingsCreateWithoutUserInput, user_settingsUncheckedCreateWithoutUserInput>
  }

  export type editionCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updater: userCreateNestedOneWithoutEdition_updatedInput
    rooms?: edition_roomCreateNestedManyWithoutEditionInput
  }

  export type editionUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy: string
    rooms?: edition_roomUncheckedCreateNestedManyWithoutEditionInput
  }

  export type editionCreateOrConnectWithoutCreatorInput = {
    where: editionWhereUniqueInput
    create: XOR<editionCreateWithoutCreatorInput, editionUncheckedCreateWithoutCreatorInput>
  }

  export type editionCreateManyCreatorInputEnvelope = {
    data: editionCreateManyCreatorInput | editionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type editionCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: userCreateNestedOneWithoutEdition_createdInput
    rooms?: edition_roomCreateNestedManyWithoutEditionInput
  }

  export type editionUncheckedCreateWithoutUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    rooms?: edition_roomUncheckedCreateNestedManyWithoutEditionInput
  }

  export type editionCreateOrConnectWithoutUpdaterInput = {
    where: editionWhereUniqueInput
    create: XOR<editionCreateWithoutUpdaterInput, editionUncheckedCreateWithoutUpdaterInput>
  }

  export type editionCreateManyUpdaterInputEnvelope = {
    data: editionCreateManyUpdaterInput | editionCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type table_seatCreateWithoutUserInput = {
    id?: string
    seatIndex: number
    createdAt?: Date | string
    updatedAt?: Date | string
    table: tableCreateNestedOneWithoutSeatsInput
  }

  export type table_seatUncheckedCreateWithoutUserInput = {
    id?: string
    tableId: string
    seatIndex: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type table_seatCreateOrConnectWithoutUserInput = {
    where: table_seatWhereUniqueInput
    create: XOR<table_seatCreateWithoutUserInput, table_seatUncheckedCreateWithoutUserInput>
  }

  export type table_seatCreateManyUserInputEnvelope = {
    data: table_seatCreateManyUserInput | table_seatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type game_serverCreateWithoutCreatorInput = {
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    updater: userCreateNestedOneWithoutGame_server_updatedInput
  }

  export type game_serverUncheckedCreateWithoutCreatorInput = {
    id?: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
  }

  export type game_serverCreateOrConnectWithoutCreatorInput = {
    where: game_serverWhereUniqueInput
    create: XOR<game_serverCreateWithoutCreatorInput, game_serverUncheckedCreateWithoutCreatorInput>
  }

  export type game_serverCreateManyCreatorInputEnvelope = {
    data: game_serverCreateManyCreatorInput | game_serverCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type game_serverCreateWithoutUpdaterInput = {
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: userCreateNestedOneWithoutGame_server_createdInput
  }

  export type game_serverUncheckedCreateWithoutUpdaterInput = {
    id?: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
  }

  export type game_serverCreateOrConnectWithoutUpdaterInput = {
    where: game_serverWhereUniqueInput
    create: XOR<game_serverCreateWithoutUpdaterInput, game_serverUncheckedCreateWithoutUpdaterInput>
  }

  export type game_serverCreateManyUpdaterInputEnvelope = {
    data: game_serverCreateManyUpdaterInput | game_serverCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type channel_memberUpsertWithWhereUniqueWithoutUserInput = {
    where: channel_memberWhereUniqueInput
    update: XOR<channel_memberUpdateWithoutUserInput, channel_memberUncheckedUpdateWithoutUserInput>
    create: XOR<channel_memberCreateWithoutUserInput, channel_memberUncheckedCreateWithoutUserInput>
  }

  export type channel_memberUpdateWithWhereUniqueWithoutUserInput = {
    where: channel_memberWhereUniqueInput
    data: XOR<channel_memberUpdateWithoutUserInput, channel_memberUncheckedUpdateWithoutUserInput>
  }

  export type channel_memberUpdateManyWithWhereWithoutUserInput = {
    where: channel_memberScalarWhereInput
    data: XOR<channel_memberUpdateManyMutationInput, channel_memberUncheckedUpdateManyWithoutUserInput>
  }

  export type channel_memberScalarWhereInput = {
    AND?: channel_memberScalarWhereInput | channel_memberScalarWhereInput[]
    OR?: channel_memberScalarWhereInput[]
    NOT?: channel_memberScalarWhereInput | channel_memberScalarWhereInput[]
    channelId?: StringFilter<"channel_member"> | string
    userId?: StringFilter<"channel_member"> | string
    addedAt?: DateTimeFilter<"channel_member"> | Date | string
  }

  export type eventUpsertWithWhereUniqueWithoutCreatorInput = {
    where: eventWhereUniqueInput
    update: XOR<eventUpdateWithoutCreatorInput, eventUncheckedUpdateWithoutCreatorInput>
    create: XOR<eventCreateWithoutCreatorInput, eventUncheckedCreateWithoutCreatorInput>
  }

  export type eventUpdateWithWhereUniqueWithoutCreatorInput = {
    where: eventWhereUniqueInput
    data: XOR<eventUpdateWithoutCreatorInput, eventUncheckedUpdateWithoutCreatorInput>
  }

  export type eventUpdateManyWithWhereWithoutCreatorInput = {
    where: eventScalarWhereInput
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyWithoutCreatorInput>
  }

  export type eventScalarWhereInput = {
    AND?: eventScalarWhereInput | eventScalarWhereInput[]
    OR?: eventScalarWhereInput[]
    NOT?: eventScalarWhereInput | eventScalarWhereInput[]
    id?: StringFilter<"event"> | string
    name?: StringFilter<"event"> | string
    description?: StringNullableFilter<"event"> | string | null
    url?: StringNullableFilter<"event"> | string | null
    start_time?: DateTimeFilter<"event"> | Date | string
    end_time?: DateTimeFilter<"event"> | Date | string
    created_at?: DateTimeFilter<"event"> | Date | string
    updated_at?: DateTimeFilter<"event"> | Date | string
    created_by?: StringFilter<"event"> | string
    updated_by?: StringFilter<"event"> | string
    location?: StringNullableFilter<"event"> | string | null
    image_url?: StringNullableFilter<"event"> | string | null
  }

  export type eventUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: eventWhereUniqueInput
    update: XOR<eventUpdateWithoutUpdaterInput, eventUncheckedUpdateWithoutUpdaterInput>
    create: XOR<eventCreateWithoutUpdaterInput, eventUncheckedCreateWithoutUpdaterInput>
  }

  export type eventUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: eventWhereUniqueInput
    data: XOR<eventUpdateWithoutUpdaterInput, eventUncheckedUpdateWithoutUpdaterInput>
  }

  export type eventUpdateManyWithWhereWithoutUpdaterInput = {
    where: eventScalarWhereInput
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type faqUpsertWithWhereUniqueWithoutCreatorInput = {
    where: faqWhereUniqueInput
    update: XOR<faqUpdateWithoutCreatorInput, faqUncheckedUpdateWithoutCreatorInput>
    create: XOR<faqCreateWithoutCreatorInput, faqUncheckedCreateWithoutCreatorInput>
  }

  export type faqUpdateWithWhereUniqueWithoutCreatorInput = {
    where: faqWhereUniqueInput
    data: XOR<faqUpdateWithoutCreatorInput, faqUncheckedUpdateWithoutCreatorInput>
  }

  export type faqUpdateManyWithWhereWithoutCreatorInput = {
    where: faqScalarWhereInput
    data: XOR<faqUpdateManyMutationInput, faqUncheckedUpdateManyWithoutCreatorInput>
  }

  export type faqScalarWhereInput = {
    AND?: faqScalarWhereInput | faqScalarWhereInput[]
    OR?: faqScalarWhereInput[]
    NOT?: faqScalarWhereInput | faqScalarWhereInput[]
    id?: IntFilter<"faq"> | number
    question?: StringFilter<"faq"> | string
    answer?: StringFilter<"faq"> | string
    published?: BoolFilter<"faq"> | boolean
    position?: IntFilter<"faq"> | number
    created_at?: DateTimeFilter<"faq"> | Date | string
    updated_at?: DateTimeFilter<"faq"> | Date | string
    created_by?: StringFilter<"faq"> | string
    updated_by?: StringFilter<"faq"> | string
  }

  export type faqUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: faqWhereUniqueInput
    update: XOR<faqUpdateWithoutUpdaterInput, faqUncheckedUpdateWithoutUpdaterInput>
    create: XOR<faqCreateWithoutUpdaterInput, faqUncheckedCreateWithoutUpdaterInput>
  }

  export type faqUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: faqWhereUniqueInput
    data: XOR<faqUpdateWithoutUpdaterInput, faqUncheckedUpdateWithoutUpdaterInput>
  }

  export type faqUpdateManyWithWhereWithoutUpdaterInput = {
    where: faqScalarWhereInput
    data: XOR<faqUpdateManyMutationInput, faqUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type gameUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: gameWhereUniqueInput
    update: XOR<gameUpdateWithoutCreatedByInput, gameUncheckedUpdateWithoutCreatedByInput>
    create: XOR<gameCreateWithoutCreatedByInput, gameUncheckedCreateWithoutCreatedByInput>
  }

  export type gameUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: gameWhereUniqueInput
    data: XOR<gameUpdateWithoutCreatedByInput, gameUncheckedUpdateWithoutCreatedByInput>
  }

  export type gameUpdateManyWithWhereWithoutCreatedByInput = {
    where: gameScalarWhereInput
    data: XOR<gameUpdateManyMutationInput, gameUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type gameScalarWhereInput = {
    AND?: gameScalarWhereInput | gameScalarWhereInput[]
    OR?: gameScalarWhereInput[]
    NOT?: gameScalarWhereInput | gameScalarWhereInput[]
    id?: StringFilter<"game"> | string
    size_gb?: FloatFilter<"game"> | number
    title?: StringFilter<"game"> | string
    folder_slug?: StringFilter<"game"> | string
    version?: StringNullableFilter<"game"> | string | null
    genres?: StringFilter<"game"> | string
    platforms?: StringNullableFilter<"game"> | string | null
    game_modes?: StringFilter<"game"> | string
    is_featured?: BoolFilter<"game"> | boolean
    date_updated?: DateTimeNullableFilter<"game"> | Date | string | null
    date_added?: DateTimeNullableFilter<"game"> | Date | string | null
    editor_name?: StringNullableFilter<"game"> | string | null
    main_process_name?: StringNullableFilter<"game"> | string | null
    cover?: StringNullableFilter<"game"> | string | null
    logo?: StringNullableFilter<"game"> | string | null
    screenshots?: StringFilter<"game"> | string
    description?: StringNullableFilter<"game"> | string | null
    start_command?: StringNullableFilter<"game"> | string | null
    max_players?: IntFilter<"game"> | number
    use_notifications?: BoolFilter<"game"> | boolean
    created_at?: DateTimeFilter<"game"> | Date | string
    updated_at?: DateTimeFilter<"game"> | Date | string
    created_by?: StringFilter<"game"> | string
    updated_by?: StringFilter<"game"> | string
  }

  export type gameUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: gameWhereUniqueInput
    update: XOR<gameUpdateWithoutUpdatedByInput, gameUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<gameCreateWithoutUpdatedByInput, gameUncheckedCreateWithoutUpdatedByInput>
  }

  export type gameUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: gameWhereUniqueInput
    data: XOR<gameUpdateWithoutUpdatedByInput, gameUncheckedUpdateWithoutUpdatedByInput>
  }

  export type gameUpdateManyWithWhereWithoutUpdatedByInput = {
    where: gameScalarWhereInput
    data: XOR<gameUpdateManyMutationInput, gameUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type game_sessionUpsertWithWhereUniqueWithoutUserInput = {
    where: game_sessionWhereUniqueInput
    update: XOR<game_sessionUpdateWithoutUserInput, game_sessionUncheckedUpdateWithoutUserInput>
    create: XOR<game_sessionCreateWithoutUserInput, game_sessionUncheckedCreateWithoutUserInput>
  }

  export type game_sessionUpdateWithWhereUniqueWithoutUserInput = {
    where: game_sessionWhereUniqueInput
    data: XOR<game_sessionUpdateWithoutUserInput, game_sessionUncheckedUpdateWithoutUserInput>
  }

  export type game_sessionUpdateManyWithWhereWithoutUserInput = {
    where: game_sessionScalarWhereInput
    data: XOR<game_sessionUpdateManyMutationInput, game_sessionUncheckedUpdateManyWithoutUserInput>
  }

  export type game_sessionScalarWhereInput = {
    AND?: game_sessionScalarWhereInput | game_sessionScalarWhereInput[]
    OR?: game_sessionScalarWhereInput[]
    NOT?: game_sessionScalarWhereInput | game_sessionScalarWhereInput[]
    id?: StringFilter<"game_session"> | string
    user_id?: StringFilter<"game_session"> | string
    game_slug?: StringFilter<"game_session"> | string
    start_time?: DateTimeFilter<"game_session"> | Date | string
    end_time?: DateTimeNullableFilter<"game_session"> | Date | string | null
    total_seconds?: IntNullableFilter<"game_session"> | number | null
  }

  export type guildUpsertWithWhereUniqueWithoutOwnerInput = {
    where: guildWhereUniqueInput
    update: XOR<guildUpdateWithoutOwnerInput, guildUncheckedUpdateWithoutOwnerInput>
    create: XOR<guildCreateWithoutOwnerInput, guildUncheckedCreateWithoutOwnerInput>
  }

  export type guildUpdateWithWhereUniqueWithoutOwnerInput = {
    where: guildWhereUniqueInput
    data: XOR<guildUpdateWithoutOwnerInput, guildUncheckedUpdateWithoutOwnerInput>
  }

  export type guildUpdateManyWithWhereWithoutOwnerInput = {
    where: guildScalarWhereInput
    data: XOR<guildUpdateManyMutationInput, guildUncheckedUpdateManyWithoutOwnerInput>
  }

  export type guildScalarWhereInput = {
    AND?: guildScalarWhereInput | guildScalarWhereInput[]
    OR?: guildScalarWhereInput[]
    NOT?: guildScalarWhereInput | guildScalarWhereInput[]
    id?: StringFilter<"guild"> | string
    name?: StringFilter<"guild"> | string
    slug?: StringFilter<"guild"> | string
    icon?: StringNullableFilter<"guild"> | string | null
    ownerId?: StringFilter<"guild"> | string
    createdAt?: DateTimeFilter<"guild"> | Date | string
    updatedAt?: DateTimeFilter<"guild"> | Date | string
  }

  export type guild_memberUpsertWithWhereUniqueWithoutUserInput = {
    where: guild_memberWhereUniqueInput
    update: XOR<guild_memberUpdateWithoutUserInput, guild_memberUncheckedUpdateWithoutUserInput>
    create: XOR<guild_memberCreateWithoutUserInput, guild_memberUncheckedCreateWithoutUserInput>
  }

  export type guild_memberUpdateWithWhereUniqueWithoutUserInput = {
    where: guild_memberWhereUniqueInput
    data: XOR<guild_memberUpdateWithoutUserInput, guild_memberUncheckedUpdateWithoutUserInput>
  }

  export type guild_memberUpdateManyWithWhereWithoutUserInput = {
    where: guild_memberScalarWhereInput
    data: XOR<guild_memberUpdateManyMutationInput, guild_memberUncheckedUpdateManyWithoutUserInput>
  }

  export type guild_memberScalarWhereInput = {
    AND?: guild_memberScalarWhereInput | guild_memberScalarWhereInput[]
    OR?: guild_memberScalarWhereInput[]
    NOT?: guild_memberScalarWhereInput | guild_memberScalarWhereInput[]
    id?: StringFilter<"guild_member"> | string
    guildId?: StringFilter<"guild_member"> | string
    userId?: StringFilter<"guild_member"> | string
    nickname?: StringNullableFilter<"guild_member"> | string | null
    roles?: StringNullableFilter<"guild_member"> | string | null
    joinedAt?: DateTimeFilter<"guild_member"> | Date | string
  }

  export type messageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutAuthorInput, messageUncheckedUpdateWithoutAuthorInput>
    create: XOR<messageCreateWithoutAuthorInput, messageUncheckedCreateWithoutAuthorInput>
  }

  export type messageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutAuthorInput, messageUncheckedUpdateWithoutAuthorInput>
  }

  export type messageUpdateManyWithWhereWithoutAuthorInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutAuthorInput>
  }

  export type messageScalarWhereInput = {
    AND?: messageScalarWhereInput | messageScalarWhereInput[]
    OR?: messageScalarWhereInput[]
    NOT?: messageScalarWhereInput | messageScalarWhereInput[]
    id?: StringFilter<"message"> | string
    roomId?: StringFilter<"message"> | string
    authorId?: StringFilter<"message"> | string
    type?: Enummessage_typeFilter<"message"> | $Enums.message_type
    content?: StringNullableFilter<"message"> | string | null
    attachments?: StringNullableFilter<"message"> | string | null
    createdAt?: DateTimeFilter<"message"> | Date | string
    editedAt?: DateTimeNullableFilter<"message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"message"> | Date | string | null
  }

  export type message_reactionUpsertWithWhereUniqueWithoutUserInput = {
    where: message_reactionWhereUniqueInput
    update: XOR<message_reactionUpdateWithoutUserInput, message_reactionUncheckedUpdateWithoutUserInput>
    create: XOR<message_reactionCreateWithoutUserInput, message_reactionUncheckedCreateWithoutUserInput>
  }

  export type message_reactionUpdateWithWhereUniqueWithoutUserInput = {
    where: message_reactionWhereUniqueInput
    data: XOR<message_reactionUpdateWithoutUserInput, message_reactionUncheckedUpdateWithoutUserInput>
  }

  export type message_reactionUpdateManyWithWhereWithoutUserInput = {
    where: message_reactionScalarWhereInput
    data: XOR<message_reactionUpdateManyMutationInput, message_reactionUncheckedUpdateManyWithoutUserInput>
  }

  export type message_reactionScalarWhereInput = {
    AND?: message_reactionScalarWhereInput | message_reactionScalarWhereInput[]
    OR?: message_reactionScalarWhereInput[]
    NOT?: message_reactionScalarWhereInput | message_reactionScalarWhereInput[]
    messageId?: StringFilter<"message_reaction"> | string
    userId?: StringFilter<"message_reaction"> | string
    emoji?: StringFilter<"message_reaction"> | string
    createdAt?: DateTimeFilter<"message_reaction"> | Date | string
  }

  export type message_readUpsertWithWhereUniqueWithoutUserInput = {
    where: message_readWhereUniqueInput
    update: XOR<message_readUpdateWithoutUserInput, message_readUncheckedUpdateWithoutUserInput>
    create: XOR<message_readCreateWithoutUserInput, message_readUncheckedCreateWithoutUserInput>
  }

  export type message_readUpdateWithWhereUniqueWithoutUserInput = {
    where: message_readWhereUniqueInput
    data: XOR<message_readUpdateWithoutUserInput, message_readUncheckedUpdateWithoutUserInput>
  }

  export type message_readUpdateManyWithWhereWithoutUserInput = {
    where: message_readScalarWhereInput
    data: XOR<message_readUpdateManyMutationInput, message_readUncheckedUpdateManyWithoutUserInput>
  }

  export type message_readScalarWhereInput = {
    AND?: message_readScalarWhereInput | message_readScalarWhereInput[]
    OR?: message_readScalarWhereInput[]
    NOT?: message_readScalarWhereInput | message_readScalarWhereInput[]
    messageId?: StringFilter<"message_read"> | string
    userId?: StringFilter<"message_read"> | string
    readAt?: DateTimeFilter<"message_read"> | Date | string
  }

  export type roomUpsertWithWhereUniqueWithoutOwnerInput = {
    where: roomWhereUniqueInput
    update: XOR<roomUpdateWithoutOwnerInput, roomUncheckedUpdateWithoutOwnerInput>
    create: XOR<roomCreateWithoutOwnerInput, roomUncheckedCreateWithoutOwnerInput>
  }

  export type roomUpdateWithWhereUniqueWithoutOwnerInput = {
    where: roomWhereUniqueInput
    data: XOR<roomUpdateWithoutOwnerInput, roomUncheckedUpdateWithoutOwnerInput>
  }

  export type roomUpdateManyWithWhereWithoutOwnerInput = {
    where: roomScalarWhereInput
    data: XOR<roomUpdateManyMutationInput, roomUncheckedUpdateManyWithoutOwnerInput>
  }

  export type roomScalarWhereInput = {
    AND?: roomScalarWhereInput | roomScalarWhereInput[]
    OR?: roomScalarWhereInput[]
    NOT?: roomScalarWhereInput | roomScalarWhereInput[]
    id?: StringFilter<"room"> | string
    type?: Enumroom_typeFilter<"room"> | $Enums.room_type
    name?: StringNullableFilter<"room"> | string | null
    ownerId?: StringNullableFilter<"room"> | string | null
    guildId?: StringNullableFilter<"room"> | string | null
    channelId?: StringNullableFilter<"room"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"room"> | Date | string | null
    createdAt?: DateTimeFilter<"room"> | Date | string
    updatedAt?: DateTimeFilter<"room"> | Date | string
  }

  export type room_participantUpsertWithWhereUniqueWithoutUserInput = {
    where: room_participantWhereUniqueInput
    update: XOR<room_participantUpdateWithoutUserInput, room_participantUncheckedUpdateWithoutUserInput>
    create: XOR<room_participantCreateWithoutUserInput, room_participantUncheckedCreateWithoutUserInput>
  }

  export type room_participantUpdateWithWhereUniqueWithoutUserInput = {
    where: room_participantWhereUniqueInput
    data: XOR<room_participantUpdateWithoutUserInput, room_participantUncheckedUpdateWithoutUserInput>
  }

  export type room_participantUpdateManyWithWhereWithoutUserInput = {
    where: room_participantScalarWhereInput
    data: XOR<room_participantUpdateManyMutationInput, room_participantUncheckedUpdateManyWithoutUserInput>
  }

  export type room_participantScalarWhereInput = {
    AND?: room_participantScalarWhereInput | room_participantScalarWhereInput[]
    OR?: room_participantScalarWhereInput[]
    NOT?: room_participantScalarWhereInput | room_participantScalarWhereInput[]
    roomId?: StringFilter<"room_participant"> | string
    userId?: StringFilter<"room_participant"> | string
    joinedAt?: DateTimeFilter<"room_participant"> | Date | string
    isMuted?: BoolFilter<"room_participant"> | boolean
    isPinned?: BoolFilter<"room_participant"> | boolean
  }

  export type room_viewUpsertWithWhereUniqueWithoutUserInput = {
    where: room_viewWhereUniqueInput
    update: XOR<room_viewUpdateWithoutUserInput, room_viewUncheckedUpdateWithoutUserInput>
    create: XOR<room_viewCreateWithoutUserInput, room_viewUncheckedCreateWithoutUserInput>
  }

  export type room_viewUpdateWithWhereUniqueWithoutUserInput = {
    where: room_viewWhereUniqueInput
    data: XOR<room_viewUpdateWithoutUserInput, room_viewUncheckedUpdateWithoutUserInput>
  }

  export type room_viewUpdateManyWithWhereWithoutUserInput = {
    where: room_viewScalarWhereInput
    data: XOR<room_viewUpdateManyMutationInput, room_viewUncheckedUpdateManyWithoutUserInput>
  }

  export type room_viewScalarWhereInput = {
    AND?: room_viewScalarWhereInput | room_viewScalarWhereInput[]
    OR?: room_viewScalarWhereInput[]
    NOT?: room_viewScalarWhereInput | room_viewScalarWhereInput[]
    roomId?: StringFilter<"room_view"> | string
    userId?: StringFilter<"room_view"> | string
    lastSeenAt?: DateTimeFilter<"room_view"> | Date | string
  }

  export type user_settingsUpsertWithoutUserInput = {
    update: XOR<user_settingsUpdateWithoutUserInput, user_settingsUncheckedUpdateWithoutUserInput>
    create: XOR<user_settingsCreateWithoutUserInput, user_settingsUncheckedCreateWithoutUserInput>
    where?: user_settingsWhereInput
  }

  export type user_settingsUpdateToOneWithWhereWithoutUserInput = {
    where?: user_settingsWhereInput
    data: XOR<user_settingsUpdateWithoutUserInput, user_settingsUncheckedUpdateWithoutUserInput>
  }

  export type user_settingsUpdateWithoutUserInput = {
    local_games_dir?: StringFieldUpdateOperationsInput | string
  }

  export type user_settingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    local_games_dir?: StringFieldUpdateOperationsInput | string
  }

  export type editionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: editionWhereUniqueInput
    update: XOR<editionUpdateWithoutCreatorInput, editionUncheckedUpdateWithoutCreatorInput>
    create: XOR<editionCreateWithoutCreatorInput, editionUncheckedCreateWithoutCreatorInput>
  }

  export type editionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: editionWhereUniqueInput
    data: XOR<editionUpdateWithoutCreatorInput, editionUncheckedUpdateWithoutCreatorInput>
  }

  export type editionUpdateManyWithWhereWithoutCreatorInput = {
    where: editionScalarWhereInput
    data: XOR<editionUpdateManyMutationInput, editionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type editionScalarWhereInput = {
    AND?: editionScalarWhereInput | editionScalarWhereInput[]
    OR?: editionScalarWhereInput[]
    NOT?: editionScalarWhereInput | editionScalarWhereInput[]
    id?: StringFilter<"edition"> | string
    name?: StringFilter<"edition"> | string
    description?: StringNullableFilter<"edition"> | string | null
    startDate?: DateTimeFilter<"edition"> | Date | string
    endDate?: DateTimeFilter<"edition"> | Date | string
    createdAt?: DateTimeFilter<"edition"> | Date | string
    updatedAt?: DateTimeFilter<"edition"> | Date | string
    createdBy?: StringFilter<"edition"> | string
    updatedBy?: StringFilter<"edition"> | string
  }

  export type editionUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: editionWhereUniqueInput
    update: XOR<editionUpdateWithoutUpdaterInput, editionUncheckedUpdateWithoutUpdaterInput>
    create: XOR<editionCreateWithoutUpdaterInput, editionUncheckedCreateWithoutUpdaterInput>
  }

  export type editionUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: editionWhereUniqueInput
    data: XOR<editionUpdateWithoutUpdaterInput, editionUncheckedUpdateWithoutUpdaterInput>
  }

  export type editionUpdateManyWithWhereWithoutUpdaterInput = {
    where: editionScalarWhereInput
    data: XOR<editionUpdateManyMutationInput, editionUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type table_seatUpsertWithWhereUniqueWithoutUserInput = {
    where: table_seatWhereUniqueInput
    update: XOR<table_seatUpdateWithoutUserInput, table_seatUncheckedUpdateWithoutUserInput>
    create: XOR<table_seatCreateWithoutUserInput, table_seatUncheckedCreateWithoutUserInput>
  }

  export type table_seatUpdateWithWhereUniqueWithoutUserInput = {
    where: table_seatWhereUniqueInput
    data: XOR<table_seatUpdateWithoutUserInput, table_seatUncheckedUpdateWithoutUserInput>
  }

  export type table_seatUpdateManyWithWhereWithoutUserInput = {
    where: table_seatScalarWhereInput
    data: XOR<table_seatUpdateManyMutationInput, table_seatUncheckedUpdateManyWithoutUserInput>
  }

  export type table_seatScalarWhereInput = {
    AND?: table_seatScalarWhereInput | table_seatScalarWhereInput[]
    OR?: table_seatScalarWhereInput[]
    NOT?: table_seatScalarWhereInput | table_seatScalarWhereInput[]
    id?: StringFilter<"table_seat"> | string
    tableId?: StringFilter<"table_seat"> | string
    seatIndex?: IntFilter<"table_seat"> | number
    userId?: StringNullableFilter<"table_seat"> | string | null
    createdAt?: DateTimeFilter<"table_seat"> | Date | string
    updatedAt?: DateTimeFilter<"table_seat"> | Date | string
  }

  export type game_serverUpsertWithWhereUniqueWithoutCreatorInput = {
    where: game_serverWhereUniqueInput
    update: XOR<game_serverUpdateWithoutCreatorInput, game_serverUncheckedUpdateWithoutCreatorInput>
    create: XOR<game_serverCreateWithoutCreatorInput, game_serverUncheckedCreateWithoutCreatorInput>
  }

  export type game_serverUpdateWithWhereUniqueWithoutCreatorInput = {
    where: game_serverWhereUniqueInput
    data: XOR<game_serverUpdateWithoutCreatorInput, game_serverUncheckedUpdateWithoutCreatorInput>
  }

  export type game_serverUpdateManyWithWhereWithoutCreatorInput = {
    where: game_serverScalarWhereInput
    data: XOR<game_serverUpdateManyMutationInput, game_serverUncheckedUpdateManyWithoutCreatorInput>
  }

  export type game_serverScalarWhereInput = {
    AND?: game_serverScalarWhereInput | game_serverScalarWhereInput[]
    OR?: game_serverScalarWhereInput[]
    NOT?: game_serverScalarWhereInput | game_serverScalarWhereInput[]
    id?: IntFilter<"game_server"> | number
    game_slug?: StringFilter<"game_server"> | string
    game_title?: StringFilter<"game_server"> | string
    type?: StringFilter<"game_server"> | string
    port?: IntFilter<"game_server"> | number
    description?: StringNullableFilter<"game_server"> | string | null
    name?: StringFilter<"game_server"> | string
    monitor?: BoolFilter<"game_server"> | boolean
    last_detection_at?: DateTimeNullableFilter<"game_server"> | Date | string | null
    created_at?: DateTimeFilter<"game_server"> | Date | string
    updated_at?: DateTimeFilter<"game_server"> | Date | string
    created_by?: StringFilter<"game_server"> | string
    updated_by?: StringFilter<"game_server"> | string
  }

  export type game_serverUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: game_serverWhereUniqueInput
    update: XOR<game_serverUpdateWithoutUpdaterInput, game_serverUncheckedUpdateWithoutUpdaterInput>
    create: XOR<game_serverCreateWithoutUpdaterInput, game_serverUncheckedCreateWithoutUpdaterInput>
  }

  export type game_serverUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: game_serverWhereUniqueInput
    data: XOR<game_serverUpdateWithoutUpdaterInput, game_serverUncheckedUpdateWithoutUpdaterInput>
  }

  export type game_serverUpdateManyWithWhereWithoutUpdaterInput = {
    where: game_serverScalarWhereInput
    data: XOR<game_serverUpdateManyMutationInput, game_serverUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type userCreateWithoutUser_settingsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutUser_settingsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutUser_settingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_settingsInput, userUncheckedCreateWithoutUser_settingsInput>
  }

  export type userUpsertWithoutUser_settingsInput = {
    update: XOR<userUpdateWithoutUser_settingsInput, userUncheckedUpdateWithoutUser_settingsInput>
    create: XOR<userCreateWithoutUser_settingsInput, userUncheckedCreateWithoutUser_settingsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUser_settingsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUser_settingsInput, userUncheckedUpdateWithoutUser_settingsInput>
  }

  export type userUpdateWithoutUser_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutUser_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userCreateWithoutGame_sessionInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutGame_sessionInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutGame_sessionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGame_sessionInput, userUncheckedCreateWithoutGame_sessionInput>
  }

  export type userUpsertWithoutGame_sessionInput = {
    update: XOR<userUpdateWithoutGame_sessionInput, userUncheckedUpdateWithoutGame_sessionInput>
    create: XOR<userCreateWithoutGame_sessionInput, userUncheckedCreateWithoutGame_sessionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGame_sessionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGame_sessionInput, userUncheckedUpdateWithoutGame_sessionInput>
  }

  export type userUpdateWithoutGame_sessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutGame_sessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userCreateWithoutEvent_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutEvent_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutEvent_createdInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEvent_createdInput, userUncheckedCreateWithoutEvent_createdInput>
  }

  export type userCreateWithoutEvent_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutEvent_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutEvent_updatedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEvent_updatedInput, userUncheckedCreateWithoutEvent_updatedInput>
  }

  export type userUpsertWithoutEvent_createdInput = {
    update: XOR<userUpdateWithoutEvent_createdInput, userUncheckedUpdateWithoutEvent_createdInput>
    create: XOR<userCreateWithoutEvent_createdInput, userUncheckedCreateWithoutEvent_createdInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEvent_createdInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEvent_createdInput, userUncheckedUpdateWithoutEvent_createdInput>
  }

  export type userUpdateWithoutEvent_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutEvent_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userUpsertWithoutEvent_updatedInput = {
    update: XOR<userUpdateWithoutEvent_updatedInput, userUncheckedUpdateWithoutEvent_updatedInput>
    create: XOR<userCreateWithoutEvent_updatedInput, userUncheckedCreateWithoutEvent_updatedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEvent_updatedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEvent_updatedInput, userUncheckedUpdateWithoutEvent_updatedInput>
  }

  export type userUpdateWithoutEvent_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutEvent_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userCreateWithoutGamesCreatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutGamesCreatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutGamesCreatedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGamesCreatedInput, userUncheckedCreateWithoutGamesCreatedInput>
  }

  export type userCreateWithoutGamesUpdatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutGamesUpdatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutGamesUpdatedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGamesUpdatedInput, userUncheckedCreateWithoutGamesUpdatedInput>
  }

  export type userUpsertWithoutGamesCreatedInput = {
    update: XOR<userUpdateWithoutGamesCreatedInput, userUncheckedUpdateWithoutGamesCreatedInput>
    create: XOR<userCreateWithoutGamesCreatedInput, userUncheckedCreateWithoutGamesCreatedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGamesCreatedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGamesCreatedInput, userUncheckedUpdateWithoutGamesCreatedInput>
  }

  export type userUpdateWithoutGamesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutGamesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userUpsertWithoutGamesUpdatedInput = {
    update: XOR<userUpdateWithoutGamesUpdatedInput, userUncheckedUpdateWithoutGamesUpdatedInput>
    create: XOR<userCreateWithoutGamesUpdatedInput, userUncheckedCreateWithoutGamesUpdatedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGamesUpdatedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGamesUpdatedInput, userUncheckedUpdateWithoutGamesUpdatedInput>
  }

  export type userUpdateWithoutGamesUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutGamesUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userCreateWithoutGame_server_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutGame_server_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutGame_server_createdInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGame_server_createdInput, userUncheckedCreateWithoutGame_server_createdInput>
  }

  export type userCreateWithoutGame_server_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
  }

  export type userUncheckedCreateWithoutGame_server_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type userCreateOrConnectWithoutGame_server_updatedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGame_server_updatedInput, userUncheckedCreateWithoutGame_server_updatedInput>
  }

  export type userUpsertWithoutGame_server_createdInput = {
    update: XOR<userUpdateWithoutGame_server_createdInput, userUncheckedUpdateWithoutGame_server_createdInput>
    create: XOR<userCreateWithoutGame_server_createdInput, userUncheckedCreateWithoutGame_server_createdInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGame_server_createdInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGame_server_createdInput, userUncheckedUpdateWithoutGame_server_createdInput>
  }

  export type userUpdateWithoutGame_server_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutGame_server_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userUpsertWithoutGame_server_updatedInput = {
    update: XOR<userUpdateWithoutGame_server_updatedInput, userUncheckedUpdateWithoutGame_server_updatedInput>
    create: XOR<userCreateWithoutGame_server_updatedInput, userUncheckedCreateWithoutGame_server_updatedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGame_server_updatedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGame_server_updatedInput, userUncheckedUpdateWithoutGame_server_updatedInput>
  }

  export type userUpdateWithoutGame_server_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
  }

  export type userUncheckedUpdateWithoutGame_server_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type userCreateWithoutFaq_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutFaq_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutFaq_createdInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFaq_createdInput, userUncheckedCreateWithoutFaq_createdInput>
  }

  export type userCreateWithoutFaq_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutFaq_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutFaq_updatedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFaq_updatedInput, userUncheckedCreateWithoutFaq_updatedInput>
  }

  export type userUpsertWithoutFaq_createdInput = {
    update: XOR<userUpdateWithoutFaq_createdInput, userUncheckedUpdateWithoutFaq_createdInput>
    create: XOR<userCreateWithoutFaq_createdInput, userUncheckedCreateWithoutFaq_createdInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFaq_createdInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFaq_createdInput, userUncheckedUpdateWithoutFaq_createdInput>
  }

  export type userUpdateWithoutFaq_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutFaq_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userUpsertWithoutFaq_updatedInput = {
    update: XOR<userUpdateWithoutFaq_updatedInput, userUncheckedUpdateWithoutFaq_updatedInput>
    create: XOR<userCreateWithoutFaq_updatedInput, userUncheckedCreateWithoutFaq_updatedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFaq_updatedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFaq_updatedInput, userUncheckedUpdateWithoutFaq_updatedInput>
  }

  export type userUpdateWithoutFaq_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutFaq_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type channelCreateWithoutGuildInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: channelCreateNestedOneWithoutChildrenInput
    children?: channelCreateNestedManyWithoutParentInput
    members?: channel_memberCreateNestedManyWithoutChannelInput
    room?: roomCreateNestedOneWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutGuildInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: channelUncheckedCreateNestedManyWithoutParentInput
    members?: channel_memberUncheckedCreateNestedManyWithoutChannelInput
    room?: roomUncheckedCreateNestedOneWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutGuildInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutGuildInput, channelUncheckedCreateWithoutGuildInput>
  }

  export type channelCreateManyGuildInputEnvelope = {
    data: channelCreateManyGuildInput | channelCreateManyGuildInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutGuildInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutGuildInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutGuildInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGuildInput, userUncheckedCreateWithoutGuildInput>
  }

  export type guild_memberCreateWithoutGuildInput = {
    id?: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
    user: userCreateNestedOneWithoutGuild_membershipsInput
  }

  export type guild_memberUncheckedCreateWithoutGuildInput = {
    id?: string
    userId: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
  }

  export type guild_memberCreateOrConnectWithoutGuildInput = {
    where: guild_memberWhereUniqueInput
    create: XOR<guild_memberCreateWithoutGuildInput, guild_memberUncheckedCreateWithoutGuildInput>
  }

  export type guild_memberCreateManyGuildInputEnvelope = {
    data: guild_memberCreateManyGuildInput | guild_memberCreateManyGuildInput[]
    skipDuplicates?: boolean
  }

  export type roomCreateWithoutGuildInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    messages?: messageCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutGuildInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutGuildInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutGuildInput, roomUncheckedCreateWithoutGuildInput>
  }

  export type roomCreateManyGuildInputEnvelope = {
    data: roomCreateManyGuildInput | roomCreateManyGuildInput[]
    skipDuplicates?: boolean
  }

  export type channelUpsertWithWhereUniqueWithoutGuildInput = {
    where: channelWhereUniqueInput
    update: XOR<channelUpdateWithoutGuildInput, channelUncheckedUpdateWithoutGuildInput>
    create: XOR<channelCreateWithoutGuildInput, channelUncheckedCreateWithoutGuildInput>
  }

  export type channelUpdateWithWhereUniqueWithoutGuildInput = {
    where: channelWhereUniqueInput
    data: XOR<channelUpdateWithoutGuildInput, channelUncheckedUpdateWithoutGuildInput>
  }

  export type channelUpdateManyWithWhereWithoutGuildInput = {
    where: channelScalarWhereInput
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyWithoutGuildInput>
  }

  export type channelScalarWhereInput = {
    AND?: channelScalarWhereInput | channelScalarWhereInput[]
    OR?: channelScalarWhereInput[]
    NOT?: channelScalarWhereInput | channelScalarWhereInput[]
    id?: StringFilter<"channel"> | string
    guildId?: StringFilter<"channel"> | string
    name?: StringFilter<"channel"> | string
    slug?: StringFilter<"channel"> | string
    type?: Enumchannel_typeFilter<"channel"> | $Enums.channel_type
    topic?: StringNullableFilter<"channel"> | string | null
    position?: IntFilter<"channel"> | number
    isPrivate?: BoolFilter<"channel"> | boolean
    parentId?: StringNullableFilter<"channel"> | string | null
    createdAt?: DateTimeFilter<"channel"> | Date | string
    updatedAt?: DateTimeFilter<"channel"> | Date | string
  }

  export type userUpsertWithoutGuildInput = {
    update: XOR<userUpdateWithoutGuildInput, userUncheckedUpdateWithoutGuildInput>
    create: XOR<userCreateWithoutGuildInput, userUncheckedCreateWithoutGuildInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGuildInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGuildInput, userUncheckedUpdateWithoutGuildInput>
  }

  export type userUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type guild_memberUpsertWithWhereUniqueWithoutGuildInput = {
    where: guild_memberWhereUniqueInput
    update: XOR<guild_memberUpdateWithoutGuildInput, guild_memberUncheckedUpdateWithoutGuildInput>
    create: XOR<guild_memberCreateWithoutGuildInput, guild_memberUncheckedCreateWithoutGuildInput>
  }

  export type guild_memberUpdateWithWhereUniqueWithoutGuildInput = {
    where: guild_memberWhereUniqueInput
    data: XOR<guild_memberUpdateWithoutGuildInput, guild_memberUncheckedUpdateWithoutGuildInput>
  }

  export type guild_memberUpdateManyWithWhereWithoutGuildInput = {
    where: guild_memberScalarWhereInput
    data: XOR<guild_memberUpdateManyMutationInput, guild_memberUncheckedUpdateManyWithoutGuildInput>
  }

  export type roomUpsertWithWhereUniqueWithoutGuildInput = {
    where: roomWhereUniqueInput
    update: XOR<roomUpdateWithoutGuildInput, roomUncheckedUpdateWithoutGuildInput>
    create: XOR<roomCreateWithoutGuildInput, roomUncheckedCreateWithoutGuildInput>
  }

  export type roomUpdateWithWhereUniqueWithoutGuildInput = {
    where: roomWhereUniqueInput
    data: XOR<roomUpdateWithoutGuildInput, roomUncheckedUpdateWithoutGuildInput>
  }

  export type roomUpdateManyWithWhereWithoutGuildInput = {
    where: roomScalarWhereInput
    data: XOR<roomUpdateManyMutationInput, roomUncheckedUpdateManyWithoutGuildInput>
  }

  export type guildCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelCreateNestedManyWithoutGuildInput
    owner: userCreateNestedOneWithoutGuildInput
    room?: roomCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelUncheckedCreateNestedManyWithoutGuildInput
    room?: roomUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildCreateOrConnectWithoutMembersInput = {
    where: guildWhereUniqueInput
    create: XOR<guildCreateWithoutMembersInput, guildUncheckedCreateWithoutMembersInput>
  }

  export type userCreateWithoutGuild_membershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutGuild_membershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutGuild_membershipsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGuild_membershipsInput, userUncheckedCreateWithoutGuild_membershipsInput>
  }

  export type guildUpsertWithoutMembersInput = {
    update: XOR<guildUpdateWithoutMembersInput, guildUncheckedUpdateWithoutMembersInput>
    create: XOR<guildCreateWithoutMembersInput, guildUncheckedCreateWithoutMembersInput>
    where?: guildWhereInput
  }

  export type guildUpdateToOneWithWhereWithoutMembersInput = {
    where?: guildWhereInput
    data: XOR<guildUpdateWithoutMembersInput, guildUncheckedUpdateWithoutMembersInput>
  }

  export type guildUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUpdateManyWithoutGuildNestedInput
    owner?: userUpdateOneRequiredWithoutGuildNestedInput
    room?: roomUpdateManyWithoutGuildNestedInput
  }

  export type guildUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUncheckedUpdateManyWithoutGuildNestedInput
    room?: roomUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type userUpsertWithoutGuild_membershipsInput = {
    update: XOR<userUpdateWithoutGuild_membershipsInput, userUncheckedUpdateWithoutGuild_membershipsInput>
    create: XOR<userCreateWithoutGuild_membershipsInput, userUncheckedCreateWithoutGuild_membershipsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGuild_membershipsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGuild_membershipsInput, userUncheckedUpdateWithoutGuild_membershipsInput>
  }

  export type userUpdateWithoutGuild_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutGuild_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type guildCreateWithoutChannelsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: userCreateNestedOneWithoutGuildInput
    members?: guild_memberCreateNestedManyWithoutGuildInput
    room?: roomCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: guild_memberUncheckedCreateNestedManyWithoutGuildInput
    room?: roomUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildCreateOrConnectWithoutChannelsInput = {
    where: guildWhereUniqueInput
    create: XOR<guildCreateWithoutChannelsInput, guildUncheckedCreateWithoutChannelsInput>
  }

  export type channelCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guild: guildCreateNestedOneWithoutChannelsInput
    parent?: channelCreateNestedOneWithoutChildrenInput
    members?: channel_memberCreateNestedManyWithoutChannelInput
    room?: roomCreateNestedOneWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutChildrenInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: channel_memberUncheckedCreateNestedManyWithoutChannelInput
    room?: roomUncheckedCreateNestedOneWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutChildrenInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutChildrenInput, channelUncheckedCreateWithoutChildrenInput>
  }

  export type channelCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guild: guildCreateNestedOneWithoutChannelsInput
    children?: channelCreateNestedManyWithoutParentInput
    members?: channel_memberCreateNestedManyWithoutChannelInput
    room?: roomCreateNestedOneWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutParentInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: channelUncheckedCreateNestedManyWithoutParentInput
    members?: channel_memberUncheckedCreateNestedManyWithoutChannelInput
    room?: roomUncheckedCreateNestedOneWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutParentInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutParentInput, channelUncheckedCreateWithoutParentInput>
  }

  export type channelCreateManyParentInputEnvelope = {
    data: channelCreateManyParentInput | channelCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type channel_memberCreateWithoutChannelInput = {
    addedAt?: Date | string
    user: userCreateNestedOneWithoutChannel_membershipsInput
  }

  export type channel_memberUncheckedCreateWithoutChannelInput = {
    userId: string
    addedAt?: Date | string
  }

  export type channel_memberCreateOrConnectWithoutChannelInput = {
    where: channel_memberWhereUniqueInput
    create: XOR<channel_memberCreateWithoutChannelInput, channel_memberUncheckedCreateWithoutChannelInput>
  }

  export type channel_memberCreateManyChannelInputEnvelope = {
    data: channel_memberCreateManyChannelInput | channel_memberCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type roomCreateWithoutChannelInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    messages?: messageCreateNestedManyWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutChannelInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutChannelInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutChannelInput, roomUncheckedCreateWithoutChannelInput>
  }

  export type guildUpsertWithoutChannelsInput = {
    update: XOR<guildUpdateWithoutChannelsInput, guildUncheckedUpdateWithoutChannelsInput>
    create: XOR<guildCreateWithoutChannelsInput, guildUncheckedCreateWithoutChannelsInput>
    where?: guildWhereInput
  }

  export type guildUpdateToOneWithWhereWithoutChannelsInput = {
    where?: guildWhereInput
    data: XOR<guildUpdateWithoutChannelsInput, guildUncheckedUpdateWithoutChannelsInput>
  }

  export type guildUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: userUpdateOneRequiredWithoutGuildNestedInput
    members?: guild_memberUpdateManyWithoutGuildNestedInput
    room?: roomUpdateManyWithoutGuildNestedInput
  }

  export type guildUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: guild_memberUncheckedUpdateManyWithoutGuildNestedInput
    room?: roomUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type channelUpsertWithoutChildrenInput = {
    update: XOR<channelUpdateWithoutChildrenInput, channelUncheckedUpdateWithoutChildrenInput>
    create: XOR<channelCreateWithoutChildrenInput, channelUncheckedCreateWithoutChildrenInput>
    where?: channelWhereInput
  }

  export type channelUpdateToOneWithWhereWithoutChildrenInput = {
    where?: channelWhereInput
    data: XOR<channelUpdateWithoutChildrenInput, channelUncheckedUpdateWithoutChildrenInput>
  }

  export type channelUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutChannelsNestedInput
    parent?: channelUpdateOneWithoutChildrenNestedInput
    members?: channel_memberUpdateManyWithoutChannelNestedInput
    room?: roomUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: channel_memberUncheckedUpdateManyWithoutChannelNestedInput
    room?: roomUncheckedUpdateOneWithoutChannelNestedInput
  }

  export type channelUpsertWithWhereUniqueWithoutParentInput = {
    where: channelWhereUniqueInput
    update: XOR<channelUpdateWithoutParentInput, channelUncheckedUpdateWithoutParentInput>
    create: XOR<channelCreateWithoutParentInput, channelUncheckedCreateWithoutParentInput>
  }

  export type channelUpdateWithWhereUniqueWithoutParentInput = {
    where: channelWhereUniqueInput
    data: XOR<channelUpdateWithoutParentInput, channelUncheckedUpdateWithoutParentInput>
  }

  export type channelUpdateManyWithWhereWithoutParentInput = {
    where: channelScalarWhereInput
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyWithoutParentInput>
  }

  export type channel_memberUpsertWithWhereUniqueWithoutChannelInput = {
    where: channel_memberWhereUniqueInput
    update: XOR<channel_memberUpdateWithoutChannelInput, channel_memberUncheckedUpdateWithoutChannelInput>
    create: XOR<channel_memberCreateWithoutChannelInput, channel_memberUncheckedCreateWithoutChannelInput>
  }

  export type channel_memberUpdateWithWhereUniqueWithoutChannelInput = {
    where: channel_memberWhereUniqueInput
    data: XOR<channel_memberUpdateWithoutChannelInput, channel_memberUncheckedUpdateWithoutChannelInput>
  }

  export type channel_memberUpdateManyWithWhereWithoutChannelInput = {
    where: channel_memberScalarWhereInput
    data: XOR<channel_memberUpdateManyMutationInput, channel_memberUncheckedUpdateManyWithoutChannelInput>
  }

  export type roomUpsertWithoutChannelInput = {
    update: XOR<roomUpdateWithoutChannelInput, roomUncheckedUpdateWithoutChannelInput>
    create: XOR<roomCreateWithoutChannelInput, roomUncheckedCreateWithoutChannelInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutChannelInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutChannelInput, roomUncheckedUpdateWithoutChannelInput>
  }

  export type roomUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    messages?: messageUpdateManyWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type channelCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guild: guildCreateNestedOneWithoutChannelsInput
    parent?: channelCreateNestedOneWithoutChildrenInput
    children?: channelCreateNestedManyWithoutParentInput
    room?: roomCreateNestedOneWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutMembersInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: channelUncheckedCreateNestedManyWithoutParentInput
    room?: roomUncheckedCreateNestedOneWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutMembersInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutMembersInput, channelUncheckedCreateWithoutMembersInput>
  }

  export type userCreateWithoutChannel_membershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutChannel_membershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutChannel_membershipsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutChannel_membershipsInput, userUncheckedCreateWithoutChannel_membershipsInput>
  }

  export type channelUpsertWithoutMembersInput = {
    update: XOR<channelUpdateWithoutMembersInput, channelUncheckedUpdateWithoutMembersInput>
    create: XOR<channelCreateWithoutMembersInput, channelUncheckedCreateWithoutMembersInput>
    where?: channelWhereInput
  }

  export type channelUpdateToOneWithWhereWithoutMembersInput = {
    where?: channelWhereInput
    data: XOR<channelUpdateWithoutMembersInput, channelUncheckedUpdateWithoutMembersInput>
  }

  export type channelUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutChannelsNestedInput
    parent?: channelUpdateOneWithoutChildrenNestedInput
    children?: channelUpdateManyWithoutParentNestedInput
    room?: roomUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: channelUncheckedUpdateManyWithoutParentNestedInput
    room?: roomUncheckedUpdateOneWithoutChannelNestedInput
  }

  export type userUpsertWithoutChannel_membershipsInput = {
    update: XOR<userUpdateWithoutChannel_membershipsInput, userUncheckedUpdateWithoutChannel_membershipsInput>
    create: XOR<userCreateWithoutChannel_membershipsInput, userUncheckedCreateWithoutChannel_membershipsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutChannel_membershipsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutChannel_membershipsInput, userUncheckedUpdateWithoutChannel_membershipsInput>
  }

  export type userUpdateWithoutChannel_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutChannel_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type dm_pair_uniqueCreateWithoutRoomInput = {
    id?: string
    userA: string
    userB: string
  }

  export type dm_pair_uniqueUncheckedCreateWithoutRoomInput = {
    id?: string
    userA: string
    userB: string
  }

  export type dm_pair_uniqueCreateOrConnectWithoutRoomInput = {
    where: dm_pair_uniqueWhereUniqueInput
    create: XOR<dm_pair_uniqueCreateWithoutRoomInput, dm_pair_uniqueUncheckedCreateWithoutRoomInput>
  }

  export type dm_pair_uniqueCreateManyRoomInputEnvelope = {
    data: dm_pair_uniqueCreateManyRoomInput | dm_pair_uniqueCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutRoomInput = {
    id?: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    author: userCreateNestedOneWithoutMessagesInput
    reactions?: message_reactionCreateNestedManyWithoutMessageInput
    reads?: message_readCreateNestedManyWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutRoomInput = {
    id?: string
    authorId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    reactions?: message_reactionUncheckedCreateNestedManyWithoutMessageInput
    reads?: message_readUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageCreateOrConnectWithoutRoomInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutRoomInput, messageUncheckedCreateWithoutRoomInput>
  }

  export type messageCreateManyRoomInputEnvelope = {
    data: messageCreateManyRoomInput | messageCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type channelCreateWithoutRoomInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guild: guildCreateNestedOneWithoutChannelsInput
    parent?: channelCreateNestedOneWithoutChildrenInput
    children?: channelCreateNestedManyWithoutParentInput
    members?: channel_memberCreateNestedManyWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutRoomInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: channelUncheckedCreateNestedManyWithoutParentInput
    members?: channel_memberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutRoomInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutRoomInput, channelUncheckedCreateWithoutRoomInput>
  }

  export type guildCreateWithoutRoomInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelCreateNestedManyWithoutGuildInput
    owner: userCreateNestedOneWithoutGuildInput
    members?: guild_memberCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateWithoutRoomInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: channelUncheckedCreateNestedManyWithoutGuildInput
    members?: guild_memberUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildCreateOrConnectWithoutRoomInput = {
    where: guildWhereUniqueInput
    create: XOR<guildCreateWithoutRoomInput, guildUncheckedCreateWithoutRoomInput>
  }

  export type userCreateWithoutRoomInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutRoomInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutRoomInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRoomInput, userUncheckedCreateWithoutRoomInput>
  }

  export type room_participantCreateWithoutRoomInput = {
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
    user: userCreateNestedOneWithoutRoom_participationsInput
  }

  export type room_participantUncheckedCreateWithoutRoomInput = {
    userId: string
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_participantCreateOrConnectWithoutRoomInput = {
    where: room_participantWhereUniqueInput
    create: XOR<room_participantCreateWithoutRoomInput, room_participantUncheckedCreateWithoutRoomInput>
  }

  export type room_participantCreateManyRoomInputEnvelope = {
    data: room_participantCreateManyRoomInput | room_participantCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type room_viewCreateWithoutRoomInput = {
    lastSeenAt?: Date | string
    user: userCreateNestedOneWithoutRoom_viewInput
  }

  export type room_viewUncheckedCreateWithoutRoomInput = {
    userId: string
    lastSeenAt?: Date | string
  }

  export type room_viewCreateOrConnectWithoutRoomInput = {
    where: room_viewWhereUniqueInput
    create: XOR<room_viewCreateWithoutRoomInput, room_viewUncheckedCreateWithoutRoomInput>
  }

  export type room_viewCreateManyRoomInputEnvelope = {
    data: room_viewCreateManyRoomInput | room_viewCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type dm_pair_uniqueUpsertWithWhereUniqueWithoutRoomInput = {
    where: dm_pair_uniqueWhereUniqueInput
    update: XOR<dm_pair_uniqueUpdateWithoutRoomInput, dm_pair_uniqueUncheckedUpdateWithoutRoomInput>
    create: XOR<dm_pair_uniqueCreateWithoutRoomInput, dm_pair_uniqueUncheckedCreateWithoutRoomInput>
  }

  export type dm_pair_uniqueUpdateWithWhereUniqueWithoutRoomInput = {
    where: dm_pair_uniqueWhereUniqueInput
    data: XOR<dm_pair_uniqueUpdateWithoutRoomInput, dm_pair_uniqueUncheckedUpdateWithoutRoomInput>
  }

  export type dm_pair_uniqueUpdateManyWithWhereWithoutRoomInput = {
    where: dm_pair_uniqueScalarWhereInput
    data: XOR<dm_pair_uniqueUpdateManyMutationInput, dm_pair_uniqueUncheckedUpdateManyWithoutRoomInput>
  }

  export type dm_pair_uniqueScalarWhereInput = {
    AND?: dm_pair_uniqueScalarWhereInput | dm_pair_uniqueScalarWhereInput[]
    OR?: dm_pair_uniqueScalarWhereInput[]
    NOT?: dm_pair_uniqueScalarWhereInput | dm_pair_uniqueScalarWhereInput[]
    id?: StringFilter<"dm_pair_unique"> | string
    userA?: StringFilter<"dm_pair_unique"> | string
    userB?: StringFilter<"dm_pair_unique"> | string
    roomId?: StringFilter<"dm_pair_unique"> | string
  }

  export type messageUpsertWithWhereUniqueWithoutRoomInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutRoomInput, messageUncheckedUpdateWithoutRoomInput>
    create: XOR<messageCreateWithoutRoomInput, messageUncheckedCreateWithoutRoomInput>
  }

  export type messageUpdateWithWhereUniqueWithoutRoomInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutRoomInput, messageUncheckedUpdateWithoutRoomInput>
  }

  export type messageUpdateManyWithWhereWithoutRoomInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutRoomInput>
  }

  export type channelUpsertWithoutRoomInput = {
    update: XOR<channelUpdateWithoutRoomInput, channelUncheckedUpdateWithoutRoomInput>
    create: XOR<channelCreateWithoutRoomInput, channelUncheckedCreateWithoutRoomInput>
    where?: channelWhereInput
  }

  export type channelUpdateToOneWithWhereWithoutRoomInput = {
    where?: channelWhereInput
    data: XOR<channelUpdateWithoutRoomInput, channelUncheckedUpdateWithoutRoomInput>
  }

  export type channelUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutChannelsNestedInput
    parent?: channelUpdateOneWithoutChildrenNestedInput
    children?: channelUpdateManyWithoutParentNestedInput
    members?: channel_memberUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: channelUncheckedUpdateManyWithoutParentNestedInput
    members?: channel_memberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type guildUpsertWithoutRoomInput = {
    update: XOR<guildUpdateWithoutRoomInput, guildUncheckedUpdateWithoutRoomInput>
    create: XOR<guildCreateWithoutRoomInput, guildUncheckedCreateWithoutRoomInput>
    where?: guildWhereInput
  }

  export type guildUpdateToOneWithWhereWithoutRoomInput = {
    where?: guildWhereInput
    data: XOR<guildUpdateWithoutRoomInput, guildUncheckedUpdateWithoutRoomInput>
  }

  export type guildUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUpdateManyWithoutGuildNestedInput
    owner?: userUpdateOneRequiredWithoutGuildNestedInput
    members?: guild_memberUpdateManyWithoutGuildNestedInput
  }

  export type guildUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUncheckedUpdateManyWithoutGuildNestedInput
    members?: guild_memberUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type userUpsertWithoutRoomInput = {
    update: XOR<userUpdateWithoutRoomInput, userUncheckedUpdateWithoutRoomInput>
    create: XOR<userCreateWithoutRoomInput, userUncheckedCreateWithoutRoomInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRoomInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRoomInput, userUncheckedUpdateWithoutRoomInput>
  }

  export type userUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type room_participantUpsertWithWhereUniqueWithoutRoomInput = {
    where: room_participantWhereUniqueInput
    update: XOR<room_participantUpdateWithoutRoomInput, room_participantUncheckedUpdateWithoutRoomInput>
    create: XOR<room_participantCreateWithoutRoomInput, room_participantUncheckedCreateWithoutRoomInput>
  }

  export type room_participantUpdateWithWhereUniqueWithoutRoomInput = {
    where: room_participantWhereUniqueInput
    data: XOR<room_participantUpdateWithoutRoomInput, room_participantUncheckedUpdateWithoutRoomInput>
  }

  export type room_participantUpdateManyWithWhereWithoutRoomInput = {
    where: room_participantScalarWhereInput
    data: XOR<room_participantUpdateManyMutationInput, room_participantUncheckedUpdateManyWithoutRoomInput>
  }

  export type room_viewUpsertWithWhereUniqueWithoutRoomInput = {
    where: room_viewWhereUniqueInput
    update: XOR<room_viewUpdateWithoutRoomInput, room_viewUncheckedUpdateWithoutRoomInput>
    create: XOR<room_viewCreateWithoutRoomInput, room_viewUncheckedCreateWithoutRoomInput>
  }

  export type room_viewUpdateWithWhereUniqueWithoutRoomInput = {
    where: room_viewWhereUniqueInput
    data: XOR<room_viewUpdateWithoutRoomInput, room_viewUncheckedUpdateWithoutRoomInput>
  }

  export type room_viewUpdateManyWithWhereWithoutRoomInput = {
    where: room_viewScalarWhereInput
    data: XOR<room_viewUpdateManyMutationInput, room_viewUncheckedUpdateManyWithoutRoomInput>
  }

  export type roomCreateWithoutParticipantsInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    messages?: messageCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutParticipantsInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutParticipantsInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutParticipantsInput, roomUncheckedCreateWithoutParticipantsInput>
  }

  export type userCreateWithoutRoom_participationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutRoom_participationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutRoom_participationsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRoom_participationsInput, userUncheckedCreateWithoutRoom_participationsInput>
  }

  export type roomUpsertWithoutParticipantsInput = {
    update: XOR<roomUpdateWithoutParticipantsInput, roomUncheckedUpdateWithoutParticipantsInput>
    create: XOR<roomCreateWithoutParticipantsInput, roomUncheckedCreateWithoutParticipantsInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutParticipantsInput, roomUncheckedUpdateWithoutParticipantsInput>
  }

  export type roomUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    messages?: messageUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type userUpsertWithoutRoom_participationsInput = {
    update: XOR<userUpdateWithoutRoom_participationsInput, userUncheckedUpdateWithoutRoom_participationsInput>
    create: XOR<userCreateWithoutRoom_participationsInput, userUncheckedCreateWithoutRoom_participationsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRoom_participationsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRoom_participationsInput, userUncheckedUpdateWithoutRoom_participationsInput>
  }

  export type userUpdateWithoutRoom_participationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutRoom_participationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type roomCreateWithoutDm_pair_uniqueInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: messageCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutDm_pair_uniqueInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutDm_pair_uniqueInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutDm_pair_uniqueInput, roomUncheckedCreateWithoutDm_pair_uniqueInput>
  }

  export type roomUpsertWithoutDm_pair_uniqueInput = {
    update: XOR<roomUpdateWithoutDm_pair_uniqueInput, roomUncheckedUpdateWithoutDm_pair_uniqueInput>
    create: XOR<roomCreateWithoutDm_pair_uniqueInput, roomUncheckedCreateWithoutDm_pair_uniqueInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutDm_pair_uniqueInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutDm_pair_uniqueInput, roomUncheckedUpdateWithoutDm_pair_uniqueInput>
  }

  export type roomUpdateWithoutDm_pair_uniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messageUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutDm_pair_uniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type userCreateWithoutMessagesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutMessagesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutMessagesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessagesInput, userUncheckedCreateWithoutMessagesInput>
  }

  export type roomCreateWithoutMessagesInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
    room_view?: room_viewCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutMessagesInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutMessagesInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutMessagesInput, roomUncheckedCreateWithoutMessagesInput>
  }

  export type message_reactionCreateWithoutMessageInput = {
    emoji: string
    createdAt?: Date | string
    user: userCreateNestedOneWithoutMessage_reactionsInput
  }

  export type message_reactionUncheckedCreateWithoutMessageInput = {
    userId: string
    emoji: string
    createdAt?: Date | string
  }

  export type message_reactionCreateOrConnectWithoutMessageInput = {
    where: message_reactionWhereUniqueInput
    create: XOR<message_reactionCreateWithoutMessageInput, message_reactionUncheckedCreateWithoutMessageInput>
  }

  export type message_reactionCreateManyMessageInputEnvelope = {
    data: message_reactionCreateManyMessageInput | message_reactionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type message_readCreateWithoutMessageInput = {
    readAt?: Date | string
    user: userCreateNestedOneWithoutMessage_readsInput
  }

  export type message_readUncheckedCreateWithoutMessageInput = {
    userId: string
    readAt?: Date | string
  }

  export type message_readCreateOrConnectWithoutMessageInput = {
    where: message_readWhereUniqueInput
    create: XOR<message_readCreateWithoutMessageInput, message_readUncheckedCreateWithoutMessageInput>
  }

  export type message_readCreateManyMessageInputEnvelope = {
    data: message_readCreateManyMessageInput | message_readCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutMessagesInput = {
    update: XOR<userUpdateWithoutMessagesInput, userUncheckedUpdateWithoutMessagesInput>
    create: XOR<userCreateWithoutMessagesInput, userUncheckedCreateWithoutMessagesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessagesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessagesInput, userUncheckedUpdateWithoutMessagesInput>
  }

  export type userUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type roomUpsertWithoutMessagesInput = {
    update: XOR<roomUpdateWithoutMessagesInput, roomUncheckedUpdateWithoutMessagesInput>
    create: XOR<roomCreateWithoutMessagesInput, roomUncheckedCreateWithoutMessagesInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutMessagesInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutMessagesInput, roomUncheckedUpdateWithoutMessagesInput>
  }

  export type roomUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type message_reactionUpsertWithWhereUniqueWithoutMessageInput = {
    where: message_reactionWhereUniqueInput
    update: XOR<message_reactionUpdateWithoutMessageInput, message_reactionUncheckedUpdateWithoutMessageInput>
    create: XOR<message_reactionCreateWithoutMessageInput, message_reactionUncheckedCreateWithoutMessageInput>
  }

  export type message_reactionUpdateWithWhereUniqueWithoutMessageInput = {
    where: message_reactionWhereUniqueInput
    data: XOR<message_reactionUpdateWithoutMessageInput, message_reactionUncheckedUpdateWithoutMessageInput>
  }

  export type message_reactionUpdateManyWithWhereWithoutMessageInput = {
    where: message_reactionScalarWhereInput
    data: XOR<message_reactionUpdateManyMutationInput, message_reactionUncheckedUpdateManyWithoutMessageInput>
  }

  export type message_readUpsertWithWhereUniqueWithoutMessageInput = {
    where: message_readWhereUniqueInput
    update: XOR<message_readUpdateWithoutMessageInput, message_readUncheckedUpdateWithoutMessageInput>
    create: XOR<message_readCreateWithoutMessageInput, message_readUncheckedCreateWithoutMessageInput>
  }

  export type message_readUpdateWithWhereUniqueWithoutMessageInput = {
    where: message_readWhereUniqueInput
    data: XOR<message_readUpdateWithoutMessageInput, message_readUncheckedUpdateWithoutMessageInput>
  }

  export type message_readUpdateManyWithWhereWithoutMessageInput = {
    where: message_readScalarWhereInput
    data: XOR<message_readUpdateManyMutationInput, message_readUncheckedUpdateManyWithoutMessageInput>
  }

  export type messageCreateWithoutReadsInput = {
    id?: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    author: userCreateNestedOneWithoutMessagesInput
    room: roomCreateNestedOneWithoutMessagesInput
    reactions?: message_reactionCreateNestedManyWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutReadsInput = {
    id?: string
    roomId: string
    authorId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    reactions?: message_reactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageCreateOrConnectWithoutReadsInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutReadsInput, messageUncheckedCreateWithoutReadsInput>
  }

  export type userCreateWithoutMessage_readsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutMessage_readsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutMessage_readsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessage_readsInput, userUncheckedCreateWithoutMessage_readsInput>
  }

  export type messageUpsertWithoutReadsInput = {
    update: XOR<messageUpdateWithoutReadsInput, messageUncheckedUpdateWithoutReadsInput>
    create: XOR<messageCreateWithoutReadsInput, messageUncheckedCreateWithoutReadsInput>
    where?: messageWhereInput
  }

  export type messageUpdateToOneWithWhereWithoutReadsInput = {
    where?: messageWhereInput
    data: XOR<messageUpdateWithoutReadsInput, messageUncheckedUpdateWithoutReadsInput>
  }

  export type messageUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: userUpdateOneRequiredWithoutMessagesNestedInput
    room?: roomUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: message_reactionUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactions?: message_reactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type userUpsertWithoutMessage_readsInput = {
    update: XOR<userUpdateWithoutMessage_readsInput, userUncheckedUpdateWithoutMessage_readsInput>
    create: XOR<userCreateWithoutMessage_readsInput, userUncheckedCreateWithoutMessage_readsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessage_readsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessage_readsInput, userUncheckedUpdateWithoutMessage_readsInput>
  }

  export type userUpdateWithoutMessage_readsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutMessage_readsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type messageCreateWithoutReactionsInput = {
    id?: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    author: userCreateNestedOneWithoutMessagesInput
    room: roomCreateNestedOneWithoutMessagesInput
    reads?: message_readCreateNestedManyWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutReactionsInput = {
    id?: string
    roomId: string
    authorId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    reads?: message_readUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageCreateOrConnectWithoutReactionsInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutReactionsInput, messageUncheckedCreateWithoutReactionsInput>
  }

  export type userCreateWithoutMessage_reactionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutMessage_reactionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutMessage_reactionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessage_reactionsInput, userUncheckedCreateWithoutMessage_reactionsInput>
  }

  export type messageUpsertWithoutReactionsInput = {
    update: XOR<messageUpdateWithoutReactionsInput, messageUncheckedUpdateWithoutReactionsInput>
    create: XOR<messageCreateWithoutReactionsInput, messageUncheckedCreateWithoutReactionsInput>
    where?: messageWhereInput
  }

  export type messageUpdateToOneWithWhereWithoutReactionsInput = {
    where?: messageWhereInput
    data: XOR<messageUpdateWithoutReactionsInput, messageUncheckedUpdateWithoutReactionsInput>
  }

  export type messageUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: userUpdateOneRequiredWithoutMessagesNestedInput
    room?: roomUpdateOneRequiredWithoutMessagesNestedInput
    reads?: message_readUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reads?: message_readUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type userUpsertWithoutMessage_reactionsInput = {
    update: XOR<userUpdateWithoutMessage_reactionsInput, userUncheckedUpdateWithoutMessage_reactionsInput>
    create: XOR<userCreateWithoutMessage_reactionsInput, userUncheckedCreateWithoutMessage_reactionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessage_reactionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessage_reactionsInput, userUncheckedUpdateWithoutMessage_reactionsInput>
  }

  export type userUpdateWithoutMessage_reactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutMessage_reactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type roomCreateWithoutRoom_viewInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueCreateNestedManyWithoutRoomInput
    messages?: messageCreateNestedManyWithoutRoomInput
    channel?: channelCreateNestedOneWithoutRoomInput
    guild?: guildCreateNestedOneWithoutRoomInput
    owner?: userCreateNestedOneWithoutRoomInput
    participants?: room_participantCreateNestedManyWithoutRoomInput
  }

  export type roomUncheckedCreateWithoutRoom_viewInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedCreateNestedManyWithoutRoomInput
    messages?: messageUncheckedCreateNestedManyWithoutRoomInput
    participants?: room_participantUncheckedCreateNestedManyWithoutRoomInput
  }

  export type roomCreateOrConnectWithoutRoom_viewInput = {
    where: roomWhereUniqueInput
    create: XOR<roomCreateWithoutRoom_viewInput, roomUncheckedCreateWithoutRoom_viewInput>
  }

  export type userCreateWithoutRoom_viewInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutRoom_viewInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutRoom_viewInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRoom_viewInput, userUncheckedCreateWithoutRoom_viewInput>
  }

  export type roomUpsertWithoutRoom_viewInput = {
    update: XOR<roomUpdateWithoutRoom_viewInput, roomUncheckedUpdateWithoutRoom_viewInput>
    create: XOR<roomCreateWithoutRoom_viewInput, roomUncheckedCreateWithoutRoom_viewInput>
    where?: roomWhereInput
  }

  export type roomUpdateToOneWithWhereWithoutRoom_viewInput = {
    where?: roomWhereInput
    data: XOR<roomUpdateWithoutRoom_viewInput, roomUncheckedUpdateWithoutRoom_viewInput>
  }

  export type roomUpdateWithoutRoom_viewInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    messages?: messageUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutRoom_viewInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type userUpsertWithoutRoom_viewInput = {
    update: XOR<userUpdateWithoutRoom_viewInput, userUncheckedUpdateWithoutRoom_viewInput>
    create: XOR<userCreateWithoutRoom_viewInput, userUncheckedCreateWithoutRoom_viewInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRoom_viewInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRoom_viewInput, userUncheckedUpdateWithoutRoom_viewInput>
  }

  export type userUpdateWithoutRoom_viewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutRoom_viewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userCreateWithoutEdition_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutEdition_createdInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutEdition_createdInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEdition_createdInput, userUncheckedCreateWithoutEdition_createdInput>
  }

  export type userCreateWithoutEdition_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    table_seats?: table_seatCreateNestedManyWithoutUserInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutEdition_updatedInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    table_seats?: table_seatUncheckedCreateNestedManyWithoutUserInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutEdition_updatedInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEdition_updatedInput, userUncheckedCreateWithoutEdition_updatedInput>
  }

  export type edition_roomCreateWithoutEditionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: tableCreateNestedManyWithoutRoomInput
  }

  export type edition_roomUncheckedCreateWithoutEditionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: tableUncheckedCreateNestedManyWithoutRoomInput
  }

  export type edition_roomCreateOrConnectWithoutEditionInput = {
    where: edition_roomWhereUniqueInput
    create: XOR<edition_roomCreateWithoutEditionInput, edition_roomUncheckedCreateWithoutEditionInput>
  }

  export type edition_roomCreateManyEditionInputEnvelope = {
    data: edition_roomCreateManyEditionInput | edition_roomCreateManyEditionInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutEdition_createdInput = {
    update: XOR<userUpdateWithoutEdition_createdInput, userUncheckedUpdateWithoutEdition_createdInput>
    create: XOR<userCreateWithoutEdition_createdInput, userUncheckedCreateWithoutEdition_createdInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEdition_createdInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEdition_createdInput, userUncheckedUpdateWithoutEdition_createdInput>
  }

  export type userUpdateWithoutEdition_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutEdition_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type userUpsertWithoutEdition_updatedInput = {
    update: XOR<userUpdateWithoutEdition_updatedInput, userUncheckedUpdateWithoutEdition_updatedInput>
    create: XOR<userCreateWithoutEdition_updatedInput, userUncheckedCreateWithoutEdition_updatedInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEdition_updatedInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEdition_updatedInput, userUncheckedUpdateWithoutEdition_updatedInput>
  }

  export type userUpdateWithoutEdition_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    table_seats?: table_seatUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutEdition_updatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    table_seats?: table_seatUncheckedUpdateManyWithoutUserNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type edition_roomUpsertWithWhereUniqueWithoutEditionInput = {
    where: edition_roomWhereUniqueInput
    update: XOR<edition_roomUpdateWithoutEditionInput, edition_roomUncheckedUpdateWithoutEditionInput>
    create: XOR<edition_roomCreateWithoutEditionInput, edition_roomUncheckedCreateWithoutEditionInput>
  }

  export type edition_roomUpdateWithWhereUniqueWithoutEditionInput = {
    where: edition_roomWhereUniqueInput
    data: XOR<edition_roomUpdateWithoutEditionInput, edition_roomUncheckedUpdateWithoutEditionInput>
  }

  export type edition_roomUpdateManyWithWhereWithoutEditionInput = {
    where: edition_roomScalarWhereInput
    data: XOR<edition_roomUpdateManyMutationInput, edition_roomUncheckedUpdateManyWithoutEditionInput>
  }

  export type edition_roomScalarWhereInput = {
    AND?: edition_roomScalarWhereInput | edition_roomScalarWhereInput[]
    OR?: edition_roomScalarWhereInput[]
    NOT?: edition_roomScalarWhereInput | edition_roomScalarWhereInput[]
    id?: StringFilter<"edition_room"> | string
    editionId?: StringFilter<"edition_room"> | string
    name?: StringFilter<"edition_room"> | string
    createdAt?: DateTimeFilter<"edition_room"> | Date | string
    updatedAt?: DateTimeFilter<"edition_room"> | Date | string
  }

  export type editionCreateWithoutRoomsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: userCreateNestedOneWithoutEdition_createdInput
    updater: userCreateNestedOneWithoutEdition_updatedInput
  }

  export type editionUncheckedCreateWithoutRoomsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy: string
  }

  export type editionCreateOrConnectWithoutRoomsInput = {
    where: editionWhereUniqueInput
    create: XOR<editionCreateWithoutRoomsInput, editionUncheckedCreateWithoutRoomsInput>
  }

  export type tableCreateWithoutRoomInput = {
    id?: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: table_seatCreateNestedManyWithoutTableInput
  }

  export type tableUncheckedCreateWithoutRoomInput = {
    id?: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: table_seatUncheckedCreateNestedManyWithoutTableInput
  }

  export type tableCreateOrConnectWithoutRoomInput = {
    where: tableWhereUniqueInput
    create: XOR<tableCreateWithoutRoomInput, tableUncheckedCreateWithoutRoomInput>
  }

  export type tableCreateManyRoomInputEnvelope = {
    data: tableCreateManyRoomInput | tableCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type editionUpsertWithoutRoomsInput = {
    update: XOR<editionUpdateWithoutRoomsInput, editionUncheckedUpdateWithoutRoomsInput>
    create: XOR<editionCreateWithoutRoomsInput, editionUncheckedCreateWithoutRoomsInput>
    where?: editionWhereInput
  }

  export type editionUpdateToOneWithWhereWithoutRoomsInput = {
    where?: editionWhereInput
    data: XOR<editionUpdateWithoutRoomsInput, editionUncheckedUpdateWithoutRoomsInput>
  }

  export type editionUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutEdition_createdNestedInput
    updater?: userUpdateOneRequiredWithoutEdition_updatedNestedInput
  }

  export type editionUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type tableUpsertWithWhereUniqueWithoutRoomInput = {
    where: tableWhereUniqueInput
    update: XOR<tableUpdateWithoutRoomInput, tableUncheckedUpdateWithoutRoomInput>
    create: XOR<tableCreateWithoutRoomInput, tableUncheckedCreateWithoutRoomInput>
  }

  export type tableUpdateWithWhereUniqueWithoutRoomInput = {
    where: tableWhereUniqueInput
    data: XOR<tableUpdateWithoutRoomInput, tableUncheckedUpdateWithoutRoomInput>
  }

  export type tableUpdateManyWithWhereWithoutRoomInput = {
    where: tableScalarWhereInput
    data: XOR<tableUpdateManyMutationInput, tableUncheckedUpdateManyWithoutRoomInput>
  }

  export type tableScalarWhereInput = {
    AND?: tableScalarWhereInput | tableScalarWhereInput[]
    OR?: tableScalarWhereInput[]
    NOT?: tableScalarWhereInput | tableScalarWhereInput[]
    id?: StringFilter<"table"> | string
    roomId?: StringFilter<"table"> | string
    name?: StringFilter<"table"> | string
    positionX?: IntFilter<"table"> | number
    positionY?: IntFilter<"table"> | number
    width?: IntFilter<"table"> | number
    height?: IntFilter<"table"> | number
    capacity?: IntFilter<"table"> | number
    createdAt?: DateTimeFilter<"table"> | Date | string
    updatedAt?: DateTimeFilter<"table"> | Date | string
  }

  export type edition_roomCreateWithoutTablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    edition: editionCreateNestedOneWithoutRoomsInput
  }

  export type edition_roomUncheckedCreateWithoutTablesInput = {
    id?: string
    editionId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type edition_roomCreateOrConnectWithoutTablesInput = {
    where: edition_roomWhereUniqueInput
    create: XOR<edition_roomCreateWithoutTablesInput, edition_roomUncheckedCreateWithoutTablesInput>
  }

  export type table_seatCreateWithoutTableInput = {
    id?: string
    seatIndex: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedOneWithoutTable_seatsInput
  }

  export type table_seatUncheckedCreateWithoutTableInput = {
    id?: string
    seatIndex: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type table_seatCreateOrConnectWithoutTableInput = {
    where: table_seatWhereUniqueInput
    create: XOR<table_seatCreateWithoutTableInput, table_seatUncheckedCreateWithoutTableInput>
  }

  export type table_seatCreateManyTableInputEnvelope = {
    data: table_seatCreateManyTableInput | table_seatCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type edition_roomUpsertWithoutTablesInput = {
    update: XOR<edition_roomUpdateWithoutTablesInput, edition_roomUncheckedUpdateWithoutTablesInput>
    create: XOR<edition_roomCreateWithoutTablesInput, edition_roomUncheckedCreateWithoutTablesInput>
    where?: edition_roomWhereInput
  }

  export type edition_roomUpdateToOneWithWhereWithoutTablesInput = {
    where?: edition_roomWhereInput
    data: XOR<edition_roomUpdateWithoutTablesInput, edition_roomUncheckedUpdateWithoutTablesInput>
  }

  export type edition_roomUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edition?: editionUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type edition_roomUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    editionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatUpsertWithWhereUniqueWithoutTableInput = {
    where: table_seatWhereUniqueInput
    update: XOR<table_seatUpdateWithoutTableInput, table_seatUncheckedUpdateWithoutTableInput>
    create: XOR<table_seatCreateWithoutTableInput, table_seatUncheckedCreateWithoutTableInput>
  }

  export type table_seatUpdateWithWhereUniqueWithoutTableInput = {
    where: table_seatWhereUniqueInput
    data: XOR<table_seatUpdateWithoutTableInput, table_seatUncheckedUpdateWithoutTableInput>
  }

  export type table_seatUpdateManyWithWhereWithoutTableInput = {
    where: table_seatScalarWhereInput
    data: XOR<table_seatUpdateManyMutationInput, table_seatUncheckedUpdateManyWithoutTableInput>
  }

  export type tableCreateWithoutSeatsInput = {
    id?: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    room: edition_roomCreateNestedOneWithoutTablesInput
  }

  export type tableUncheckedCreateWithoutSeatsInput = {
    id?: string
    roomId: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tableCreateOrConnectWithoutSeatsInput = {
    where: tableWhereUniqueInput
    create: XOR<tableCreateWithoutSeatsInput, tableUncheckedCreateWithoutSeatsInput>
  }

  export type userCreateWithoutTable_seatsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberCreateNestedManyWithoutUserInput
    event_created?: eventCreateNestedManyWithoutCreatorInput
    event_updated?: eventCreateNestedManyWithoutUpdaterInput
    faq_created?: faqCreateNestedManyWithoutCreatorInput
    faq_updated?: faqCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionCreateNestedManyWithoutUserInput
    guild?: guildCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberCreateNestedManyWithoutUserInput
    messages?: messageCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionCreateNestedManyWithoutUserInput
    message_reads?: message_readCreateNestedManyWithoutUserInput
    room?: roomCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantCreateNestedManyWithoutUserInput
    room_view?: room_viewCreateNestedManyWithoutUserInput
    user_settings?: user_settingsCreateNestedOneWithoutUserInput
    edition_created?: editionCreateNestedManyWithoutCreatorInput
    edition_updated?: editionCreateNestedManyWithoutUpdaterInput
    game_server_created?: game_serverCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverCreateNestedManyWithoutUpdaterInput
  }

  export type userUncheckedCreateWithoutTable_seatsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    username?: string | null
    role?: string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    displayUsername?: string | null
    lastLogin?: Date | string | null
    channel_memberships?: channel_memberUncheckedCreateNestedManyWithoutUserInput
    event_created?: eventUncheckedCreateNestedManyWithoutCreatorInput
    event_updated?: eventUncheckedCreateNestedManyWithoutUpdaterInput
    faq_created?: faqUncheckedCreateNestedManyWithoutCreatorInput
    faq_updated?: faqUncheckedCreateNestedManyWithoutUpdaterInput
    gamesCreated?: gameUncheckedCreateNestedManyWithoutCreatedByInput
    gamesUpdated?: gameUncheckedCreateNestedManyWithoutUpdatedByInput
    game_session?: game_sessionUncheckedCreateNestedManyWithoutUserInput
    guild?: guildUncheckedCreateNestedManyWithoutOwnerInput
    guild_memberships?: guild_memberUncheckedCreateNestedManyWithoutUserInput
    messages?: messageUncheckedCreateNestedManyWithoutAuthorInput
    message_reactions?: message_reactionUncheckedCreateNestedManyWithoutUserInput
    message_reads?: message_readUncheckedCreateNestedManyWithoutUserInput
    room?: roomUncheckedCreateNestedManyWithoutOwnerInput
    room_participations?: room_participantUncheckedCreateNestedManyWithoutUserInput
    room_view?: room_viewUncheckedCreateNestedManyWithoutUserInput
    user_settings?: user_settingsUncheckedCreateNestedOneWithoutUserInput
    edition_created?: editionUncheckedCreateNestedManyWithoutCreatorInput
    edition_updated?: editionUncheckedCreateNestedManyWithoutUpdaterInput
    game_server_created?: game_serverUncheckedCreateNestedManyWithoutCreatorInput
    game_server_updated?: game_serverUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type userCreateOrConnectWithoutTable_seatsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTable_seatsInput, userUncheckedCreateWithoutTable_seatsInput>
  }

  export type tableUpsertWithoutSeatsInput = {
    update: XOR<tableUpdateWithoutSeatsInput, tableUncheckedUpdateWithoutSeatsInput>
    create: XOR<tableCreateWithoutSeatsInput, tableUncheckedCreateWithoutSeatsInput>
    where?: tableWhereInput
  }

  export type tableUpdateToOneWithWhereWithoutSeatsInput = {
    where?: tableWhereInput
    data: XOR<tableUpdateWithoutSeatsInput, tableUncheckedUpdateWithoutSeatsInput>
  }

  export type tableUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: edition_roomUpdateOneRequiredWithoutTablesNestedInput
  }

  export type tableUncheckedUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutTable_seatsInput = {
    update: XOR<userUpdateWithoutTable_seatsInput, userUncheckedUpdateWithoutTable_seatsInput>
    create: XOR<userCreateWithoutTable_seatsInput, userUncheckedCreateWithoutTable_seatsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTable_seatsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTable_seatsInput, userUncheckedUpdateWithoutTable_seatsInput>
  }

  export type userUpdateWithoutTable_seatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUpdateManyWithoutUserNestedInput
    event_created?: eventUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUpdateManyWithoutUserNestedInput
    guild?: guildUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUpdateManyWithoutUserNestedInput
    messages?: messageUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUpdateManyWithoutUserNestedInput
    message_reads?: message_readUpdateManyWithoutUserNestedInput
    room?: roomUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUpdateManyWithoutUserNestedInput
    room_view?: room_viewUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUpdateOneWithoutUserNestedInput
    edition_created?: editionUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUpdateManyWithoutUpdaterNestedInput
    game_server_created?: game_serverUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUpdateManyWithoutUpdaterNestedInput
  }

  export type userUncheckedUpdateWithoutTable_seatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    displayUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel_memberships?: channel_memberUncheckedUpdateManyWithoutUserNestedInput
    event_created?: eventUncheckedUpdateManyWithoutCreatorNestedInput
    event_updated?: eventUncheckedUpdateManyWithoutUpdaterNestedInput
    faq_created?: faqUncheckedUpdateManyWithoutCreatorNestedInput
    faq_updated?: faqUncheckedUpdateManyWithoutUpdaterNestedInput
    gamesCreated?: gameUncheckedUpdateManyWithoutCreatedByNestedInput
    gamesUpdated?: gameUncheckedUpdateManyWithoutUpdatedByNestedInput
    game_session?: game_sessionUncheckedUpdateManyWithoutUserNestedInput
    guild?: guildUncheckedUpdateManyWithoutOwnerNestedInput
    guild_memberships?: guild_memberUncheckedUpdateManyWithoutUserNestedInput
    messages?: messageUncheckedUpdateManyWithoutAuthorNestedInput
    message_reactions?: message_reactionUncheckedUpdateManyWithoutUserNestedInput
    message_reads?: message_readUncheckedUpdateManyWithoutUserNestedInput
    room?: roomUncheckedUpdateManyWithoutOwnerNestedInput
    room_participations?: room_participantUncheckedUpdateManyWithoutUserNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutUserNestedInput
    user_settings?: user_settingsUncheckedUpdateOneWithoutUserNestedInput
    edition_created?: editionUncheckedUpdateManyWithoutCreatorNestedInput
    edition_updated?: editionUncheckedUpdateManyWithoutUpdaterNestedInput
    game_server_created?: game_serverUncheckedUpdateManyWithoutCreatorNestedInput
    game_server_updated?: game_serverUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type channel_memberCreateManyUserInput = {
    channelId: string
    addedAt?: Date | string
  }

  export type eventCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
    location?: string | null
    image_url?: string | null
  }

  export type eventCreateManyUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    start_time: Date | string
    end_time: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
    location?: string | null
    image_url?: string | null
  }

  export type faqCreateManyCreatorInput = {
    id?: number
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
  }

  export type faqCreateManyUpdaterInput = {
    id?: number
    question: string
    answer: string
    published?: boolean
    position?: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
  }

  export type gameCreateManyCreatedByInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
  }

  export type gameCreateManyUpdatedByInput = {
    id?: string
    size_gb: number
    title: string
    folder_slug: string
    version?: string | null
    genres: string
    platforms?: string | null
    game_modes: string
    is_featured?: boolean
    date_updated?: Date | string | null
    date_added?: Date | string | null
    editor_name?: string | null
    main_process_name?: string | null
    cover?: string | null
    logo?: string | null
    screenshots: string
    description?: string | null
    start_command?: string | null
    max_players: number
    use_notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
  }

  export type game_sessionCreateManyUserInput = {
    id?: string
    game_slug: string
    start_time: Date | string
    end_time?: Date | string | null
    total_seconds?: number | null
  }

  export type guildCreateManyOwnerInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type guild_memberCreateManyUserInput = {
    id?: string
    guildId: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
  }

  export type messageCreateManyAuthorInput = {
    id?: string
    roomId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type message_reactionCreateManyUserInput = {
    messageId: string
    emoji: string
    createdAt?: Date | string
  }

  export type message_readCreateManyUserInput = {
    messageId: string
    readAt?: Date | string
  }

  export type roomCreateManyOwnerInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    guildId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type room_participantCreateManyUserInput = {
    roomId: string
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_viewCreateManyUserInput = {
    roomId: string
    lastSeenAt?: Date | string
  }

  export type editionCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type editionCreateManyUpdaterInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type table_seatCreateManyUserInput = {
    id?: string
    tableId: string
    seatIndex: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type game_serverCreateManyCreatorInput = {
    id?: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    updated_by: string
  }

  export type game_serverCreateManyUpdaterInput = {
    id?: number
    game_slug: string
    game_title: string
    type: string
    port: number
    description?: string | null
    name: string
    monitor?: boolean
    last_detection_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: string
  }

  export type channel_memberUpdateWithoutUserInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: channelUpdateOneRequiredWithoutMembersNestedInput
  }

  export type channel_memberUncheckedUpdateWithoutUserInput = {
    channelId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channel_memberUncheckedUpdateManyWithoutUserInput = {
    channelId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    updater?: userUpdateOneRequiredWithoutEvent_updatedNestedInput
  }

  export type eventUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: userUpdateOneRequiredWithoutEvent_createdNestedInput
  }

  export type eventUncheckedUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventUncheckedUpdateManyWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type faqUpdateWithoutCreatorInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: userUpdateOneRequiredWithoutFaq_updatedNestedInput
  }

  export type faqUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type faqUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type faqUpdateWithoutUpdaterInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutFaq_createdNestedInput
  }

  export type faqUncheckedUpdateWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type faqUncheckedUpdateManyWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type gameUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: userUpdateOneRequiredWithoutGamesUpdatedNestedInput
  }

  export type gameUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type gameUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type gameUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: userUpdateOneRequiredWithoutGamesCreatedNestedInput
  }

  export type gameUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type gameUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    size_gb?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    folder_slug?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: StringFieldUpdateOperationsInput | string
    platforms?: NullableStringFieldUpdateOperationsInput | string | null
    game_modes?: StringFieldUpdateOperationsInput | string
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    date_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_added?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editor_name?: NullableStringFieldUpdateOperationsInput | string | null
    main_process_name?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    screenshots?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_command?: NullableStringFieldUpdateOperationsInput | string | null
    max_players?: IntFieldUpdateOperationsInput | number
    use_notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type game_sessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type game_sessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type game_sessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_slug?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_seconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUpdateManyWithoutGuildNestedInput
    members?: guild_memberUpdateManyWithoutGuildNestedInput
    room?: roomUpdateManyWithoutGuildNestedInput
  }

  export type guildUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: channelUncheckedUpdateManyWithoutGuildNestedInput
    members?: guild_memberUncheckedUpdateManyWithoutGuildNestedInput
    room?: roomUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type guildUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutMembersNestedInput
  }

  export type guild_memberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: roomUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: message_reactionUpdateManyWithoutMessageNestedInput
    reads?: message_readUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactions?: message_reactionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: message_readUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type message_reactionUpdateWithoutUserInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type message_reactionUncheckedUpdateWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_reactionUncheckedUpdateManyWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_readUpdateWithoutUserInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUpdateOneRequiredWithoutReadsNestedInput
  }

  export type message_readUncheckedUpdateWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_readUncheckedUpdateManyWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roomUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    messages?: messageUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    guild?: guildUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    guildId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_participantUpdateWithoutUserInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    room?: roomUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type room_participantUncheckedUpdateWithoutUserInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_participantUncheckedUpdateManyWithoutUserInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_viewUpdateWithoutUserInput = {
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: roomUpdateOneRequiredWithoutRoom_viewNestedInput
  }

  export type room_viewUncheckedUpdateWithoutUserInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_viewUncheckedUpdateManyWithoutUserInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type editionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: userUpdateOneRequiredWithoutEdition_updatedNestedInput
    rooms?: edition_roomUpdateManyWithoutEditionNestedInput
  }

  export type editionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    rooms?: edition_roomUncheckedUpdateManyWithoutEditionNestedInput
  }

  export type editionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type editionUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutEdition_createdNestedInput
    rooms?: edition_roomUpdateManyWithoutEditionNestedInput
  }

  export type editionUncheckedUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    rooms?: edition_roomUncheckedUpdateManyWithoutEditionNestedInput
  }

  export type editionUncheckedUpdateManyWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type table_seatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: tableUpdateOneRequiredWithoutSeatsNestedInput
  }

  export type table_seatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_serverUpdateWithoutCreatorInput = {
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: userUpdateOneRequiredWithoutGame_server_updatedNestedInput
  }

  export type game_serverUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type game_serverUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: StringFieldUpdateOperationsInput | string
  }

  export type game_serverUpdateWithoutUpdaterInput = {
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutGame_server_createdNestedInput
  }

  export type game_serverUncheckedUpdateWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type game_serverUncheckedUpdateManyWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    game_slug?: StringFieldUpdateOperationsInput | string
    game_title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    monitor?: BoolFieldUpdateOperationsInput | boolean
    last_detection_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type channelCreateManyGuildInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type guild_memberCreateManyGuildInput = {
    id?: string
    userId: string
    nickname?: string | null
    roles?: string | null
    joinedAt?: Date | string
  }

  export type roomCreateManyGuildInput = {
    id?: string
    type: $Enums.room_type
    name?: string | null
    ownerId?: string | null
    channelId?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type channelUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: channelUpdateOneWithoutChildrenNestedInput
    children?: channelUpdateManyWithoutParentNestedInput
    members?: channel_memberUpdateManyWithoutChannelNestedInput
    room?: roomUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: channelUncheckedUpdateManyWithoutParentNestedInput
    members?: channel_memberUncheckedUpdateManyWithoutChannelNestedInput
    room?: roomUncheckedUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateManyWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutGuild_membershipsNestedInput
  }

  export type guild_memberUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type guild_memberUncheckedUpdateManyWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roomUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUpdateManyWithoutRoomNestedInput
    messages?: messageUpdateManyWithoutRoomNestedInput
    channel?: channelUpdateOneWithoutRoomNestedInput
    owner?: userUpdateOneWithoutRoomNestedInput
    participants?: room_participantUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dm_pair_unique?: dm_pair_uniqueUncheckedUpdateManyWithoutRoomNestedInput
    messages?: messageUncheckedUpdateManyWithoutRoomNestedInput
    participants?: room_participantUncheckedUpdateManyWithoutRoomNestedInput
    room_view?: room_viewUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type roomUncheckedUpdateManyWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumroom_typeFieldUpdateOperationsInput | $Enums.room_type
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channelCreateManyParentInput = {
    id?: string
    guildId: string
    name: string
    slug: string
    type?: $Enums.channel_type
    topic?: string | null
    position?: number
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type channel_memberCreateManyChannelInput = {
    userId: string
    addedAt?: Date | string
  }

  export type channelUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutChannelsNestedInput
    children?: channelUpdateManyWithoutParentNestedInput
    members?: channel_memberUpdateManyWithoutChannelNestedInput
    room?: roomUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: channelUncheckedUpdateManyWithoutParentNestedInput
    members?: channel_memberUncheckedUpdateManyWithoutChannelNestedInput
    room?: roomUncheckedUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: Enumchannel_typeFieldUpdateOperationsInput | $Enums.channel_type
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channel_memberUpdateWithoutChannelInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutChannel_membershipsNestedInput
  }

  export type channel_memberUncheckedUpdateWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type channel_memberUncheckedUpdateManyWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dm_pair_uniqueCreateManyRoomInput = {
    id?: string
    userA: string
    userB: string
  }

  export type messageCreateManyRoomInput = {
    id?: string
    authorId: string
    type?: $Enums.message_type
    content?: string | null
    attachments?: string | null
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type room_participantCreateManyRoomInput = {
    userId: string
    joinedAt?: Date | string
    isMuted?: boolean
    isPinned?: boolean
  }

  export type room_viewCreateManyRoomInput = {
    userId: string
    lastSeenAt?: Date | string
  }

  export type dm_pair_uniqueUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
  }

  export type dm_pair_uniqueUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
  }

  export type dm_pair_uniqueUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userA?: StringFieldUpdateOperationsInput | string
    userB?: StringFieldUpdateOperationsInput | string
  }

  export type messageUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: userUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: message_reactionUpdateManyWithoutMessageNestedInput
    reads?: message_readUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactions?: message_reactionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: message_readUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: Enummessage_typeFieldUpdateOperationsInput | $Enums.message_type
    content?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type room_participantUpdateWithoutRoomInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutRoom_participationsNestedInput
  }

  export type room_participantUncheckedUpdateWithoutRoomInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_participantUncheckedUpdateManyWithoutRoomInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isMuted?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_viewUpdateWithoutRoomInput = {
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRoom_viewNestedInput
  }

  export type room_viewUncheckedUpdateWithoutRoomInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_viewUncheckedUpdateManyWithoutRoomInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_reactionCreateManyMessageInput = {
    userId: string
    emoji: string
    createdAt?: Date | string
  }

  export type message_readCreateManyMessageInput = {
    userId: string
    readAt?: Date | string
  }

  export type message_reactionUpdateWithoutMessageInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutMessage_reactionsNestedInput
  }

  export type message_reactionUncheckedUpdateWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_reactionUncheckedUpdateManyWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_readUpdateWithoutMessageInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutMessage_readsNestedInput
  }

  export type message_readUncheckedUpdateWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type message_readUncheckedUpdateManyWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type edition_roomCreateManyEditionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type edition_roomUpdateWithoutEditionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: tableUpdateManyWithoutRoomNestedInput
  }

  export type edition_roomUncheckedUpdateWithoutEditionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: tableUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type edition_roomUncheckedUpdateManyWithoutEditionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tableCreateManyRoomInput = {
    id?: string
    name: string
    positionX?: number
    positionY?: number
    width?: number
    height?: number
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tableUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: table_seatUpdateManyWithoutTableNestedInput
  }

  export type tableUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: table_seatUncheckedUpdateManyWithoutTableNestedInput
  }

  export type tableUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    positionX?: IntFieldUpdateOperationsInput | number
    positionY?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatCreateManyTableInput = {
    id?: string
    seatIndex: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type table_seatUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutTable_seatsNestedInput
  }

  export type table_seatUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type table_seatUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatIndex?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}